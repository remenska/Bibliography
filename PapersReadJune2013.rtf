{\rtf1\ansi\deff3\adeflang1025
{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}{\f1\froman\fprq2\fcharset2 Symbol;}{\f2\fswiss\fprq2\fcharset0 Arial;}{\f3\froman\fprq2\fcharset128 Liberation Serif{\*\falt Times New Roman};}{\f4\fswiss\fprq2\fcharset128 Liberation Sans{\*\falt Arial};}{\f5\fnil\fprq0\fcharset128 Arial;}{\f6\fnil\fprq2\fcharset128 WenQuanYi Micro Hei;}{\f7\fnil\fprq2\fcharset128 Lohit Hindi;}{\f8\fnil\fprq0\fcharset128 Lohit Hindi;}}
{\colortbl;\red0\green0\blue0;\red0\green0\blue128;\red17\green85\blue204;\red255\green255\blue255;\red128\green128\blue128;}
{\stylesheet{\s0\snext0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\kerning1\hich\af6\langfe2052\dbch\af7\afs24\alang1081\loch\f3\fs24\lang1033 Normal;}
{\*\cs15\snext15\cf2\ul\ulc0\langfe255\alang255\lang255 Internet Link;}
{\s16\sbasedon0\snext17\sb240\sa120\keepn\hich\af6\dbch\af7\afs28\loch\f4\fs28 Heading;}
{\s17\sbasedon0\snext17\sb0\sa120 Text body;}
{\s18\sbasedon17\snext18\sb0\sa120\dbch\af8 List;}
{\s19\sbasedon0\snext19\sb120\sa120\noline\i\dbch\af8\afs24\ai\fs24 Caption;}
{\s20\sbasedon0\snext20\noline\dbch\af8 Index;}
}{\info{\author Daniela }{\creatim\yr2013\mo6\dy16\hr17\min35}{\author Daniela }{\revtim\yr2013\mo6\dy16\hr17\min35}{\printim\yr0\mo0\dy0\hr0\min0}{\comment LibreOffice}{\vern3500}}\deftab709

{\*\pgdsctbl
{\pgdsc0\pgdscuse195\pgwsxn12240\pghsxn15840\marglsxn1134\margrsxn1134\margtsxn1134\margbsxn1134\pgdscnxt0 Default;}}
\formshade\paperh15840\paperw12240\margl1134\margr1134\margt1134\margb1134\sectd\sbknone\sectunlocked1\pgndec\pgwsxn12240\pghsxn15840\marglsxn1134\margrsxn1134\margtsxn1134\margbsxn1134\ftnbj\ftnstart1\ftnrstcont\ftnnar\aenddoc\aftnrstcont\aftnstart1\aftnnrlc
\pgndec\pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{{\*\bkmkstart docs-internal-guid-3893ea67-4d92-70d3-dfce-905273d24007}{\*\bkmkend docs-internal-guid-3893ea67-4d92-70d3-dfce-905273d24007}\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Papers read March 2013:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Formal Model Driven Engineering for Space Onboard Software }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
From September 2004 to December 2007, the European Space Agency (ESA) led the ASSERT project [1] of the FP6, with the objective of defining a complete system/software engineering process for complex and critical space systems. The ASSERT development process is now supported by a set of tools called TASTE [4]. The main scope of the ASSERT project was the management of non functional requirements, from the capture of system requirements to the automatic generation of code. Formalisation of each step of the development by safe and non-ambiguous languages. \~The following languages have been selected: SysML for the system design. SysML is a graphical modelling language adapted to system engineering and increasingly used in the industry; SCADE Suite for the software design. SCADE is a graphical modelling language mixing automata and data flow views; Ada for the coding. Ada is a programming language targeting the development of critical real time software.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The SysML standard is not always precise enough and leaves an important part of its semantics undefined. The FMDE project has thus adapted the OMEGA profile (previously available for UML) to the SysML language in order to suppress any ambiguity in the system models and to allow formal proof. This requires the addition of new modelling constructs and the definition of a set of rules to clarify some semantics variation points of SysML (e.g. forbidding of bidirectional ports, typing of connectors, port behaviours).}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
SPARK is specifically designed to support the development of software for systems where the correct operation of the software is essential for the safety or security of the system. The language is based on a core subset of Ada and augmented with annotations which describe and}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
support the programming-by-contract approach. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Automatic generation of a skeleton of the software model in SCADE Suite from the system model in SysML. This objective has been achieved by integrating SCADE Suite and the Papyrus SysML modeller through the new SCADE System Designer tool. Having two interconnected meta-models allows consistency to be kept between the system model and the software model. \uc3 \u8592\'e2\'86\'90 for ppt?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Automatic generation of SPARK code from the software model in SCADE Suite by a tool certifiable to DO178B level A. The static semantics of the profile is defined by well-formedness rules formalised in OCL. These rules concern the strong typing principles and the restrictions relative to the structure of IBDs mentioned in the previous section. Further details on the formalisation and the rationale can be found in [7]. One of the first benefits of using the OMEGA profile is the tool support helping system engineers obtain statically valid and well-defined models. For the operational semantics, OMEGA relies on an asynchronous timed execution model. Each basic block with behaviour is considered as a timed automaton, potentially executing in parallel with other blocks and communicating via asynchronous signals or asynchronous operation calls. In order to offer a mechanism for controlling the granularity of concurrency, the semantics takes into account the isActive attribute that SysML blocks inherit from UML classes. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The toolset handles SysML models in XMI 2.1, edited by an editor compliant with Eclipse EMF such as IBM Rhapsody or Papyrus MDT. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This section is about bridging the last two steps of the process: software design and coding. These steps are coupled through automatic code generation from a formal (synchronous) model, which allows generating a fully certifiable code from the software design. This method and technologies have been used for more than 10 years now and are now fully accepted by certification authorities as a safe way to develop code. The added value of the work done in FMDE is to generate SPARK / ADA code (instead of C code) that is amenable to formal proof. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The SPARK Pro Toolset can verify the correctness of programs by using rigorous mathematical analysis. All types of analysis supported by the tools \uc3 \u8212\'e2\'80\'94 from data flow and information flow analysis, through proof of absence of run-time exceptions, to formal verification of correct functionality of the program against a specification \u8212\'e2\'80\'94 are fast: they are performed in polynomial time (there is a trade-off between speed and completeness: the analysis is fast but not every correct program can be proven).\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In its simplest form, SPARK proof demonstrates the absence of run-time errors: it shows before the execution of a program that there will be no errors such as division by zero, buffer overflow or out-of-range assignments to variables during the execution. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The most complete and exhaustive form of proof is the proof of functional correctness of a program against a detailed formal specification. \uc3 \u8592\'e2\'86\'90 for ppt?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Integrated Model Checking of Static Structure and Dynamic Behavior using Temporal Description Logics (2011)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The static structure as described by UML class diagrams is represented formally by description logics while the dynamic behavior is represented by linear temporal logic and state transition systems. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We integrate these descriptions of static and dynamic aspects into a single formalism called LTLDL .}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
LTLDL enables a concise and natural yet precise definition of the behavior of software w.r.t. UML class diagrams and state transition diagrams.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Further, we describe how properties of finite LTLDL models can be analyzed based on bounded model checking and SMT (satisfiability modulo theory) solving. We implemented a restricted SMT solver for finite sets and relations. This SMT solver helped to reduce the model checking runtime significantly as compared to bounded model checking with existing tools. \uc3 \u8592\'e2\'86\'90 SMT solvers could be the future, pay attention!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Description logics are expressive for representing the static structure of some application domain. Their expressiveness is closely related to UML class diagrams [BCG05]. Temporal logics are well-suited to describe the behavior of processes in a formal yet abstract way. We propose to combine these formalisms in a family of temporal description logics called LTLDL , to be able to address both the static and dynamic aspects of modeled systems. This goes beyond existing approaches such as Alloy [Jac02] or Spin [Hol04] which focus either on the static structure or on the dynamic behavior of the modeled system. The state machine example they show is not even syntactically correct probably! }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We aim at representing properties w.r.t. both the static model and the behavior model of some application domain.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In the case of our sample scenario, the following properties may be important to meet:P1 Whenever a customer places an order, the customer will receive some response which may either be the delivery of the order or a notification that the order is pending because of insufficient stock; P2 Orders may not be pending forever, i.e., orders delayed due to insufficient stock will be delivered eventually; P3 If orders are pending then repeatedly incoming stock will eventually cause an order to be delivered; }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We propose LTLDL for the formal representation of such criteria. LTLDL is a modular composition of linear temporal logic LTL [Eme90] and description logic (DL); }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This allows for the representation of properties that address both the static structure and dynamic behavior since the semantics of UML class diagrams can be represented well by DL, and properties of state transition diagrams can be expressed by LTL.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
LTLDL extends LTL by allowing DL formulae in addition to atomic propositions at locations where only atomic propositions are allowed in LTL.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Hence both LTL and DL are contained in LTLDL. The following are ALC formulae expressing properties related to the class diagram of Figure 1: a1 : Delivered Pending Order (Every delivered or pending thing is an order) etc..}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
However, the following LTLALC formulae are neither in LTL nor in ALC: la0 : F(PendingList \uc2 \u172\'c2\'ac\uc3 \u8707\'e2\'88\'83lists.Pending) (The list of pending orders will \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
eventually}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
be empty) }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
LTLDL formulae are interpreted w.r.t. finite }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
relational}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
state transition systems M = (S, R, L, \uc3 \u8710\'e2\'88\'86, I)\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We denote I(s0 ) |= d iff some DL formula d holds at a state s0 \uc3 \u8712\'e2\'88\'88 S according to the semantics of DL connectives and the interpretation I(s0 ) of atomic concepts and roles.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Let M = (S, R, L, \uc3 \u8710\'e2\'88\'86, I) be a finite relational state transition system and f be a LTLDL formula. Let D = \{d1 , ..., dn \}, n \u8712\'e2\'88\'88 N, be the set of DL formulae in f \u8230\'e2\'80\'a6.Let \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
f\uc3 \u8217\'e2\'80\'99 =\uc1 }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
f [d1 /a1 ][d2 /a2 ]...[dn /an ] }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
be the formula derived from f by substituting all description logics formula in f with atomic propositions.... By theorem 1, a model checking algorithm for LTLDL can be constructed by composing a LTL model checker and DL model checker as follows: First, using the DL model checker to calculate the labeling function L in Theorem 1, and then check for M , x |= f using the LTL model checker. This forward approach, however, is not efficient in the case of systems with many states. Hence, we strive for a tighter interaction between the LTL and DL model checker to avoid calculating the entire reduced model M . There are two obvious approaches to achieve this: \uc3 \u8220\'e2\'80\'9con-the-fly model checking\u8221\'e2\'80\'9d [Hol04] and \u8220\'e2\'80\'9cbounded model checking\u8221\'e2\'80\'9d [BCC+ 03]. In this work, we adopted the latter approach because its modular structure simplified the implementation of a LTLDL model checker based on existing tools for bounded model checking and SMT solving.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
As illustrated by Example 3, we transform LTLDL models and formulae into formulae that contain set-type variables and operations corresponding to the semantics of DL connectives. These formulae can be interpreted as SMT formulae with sets and relations as background theory. We define the language SMT(DL) for the representation for such formulae.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We implemented a partial solver for SMT(DL) based on OpenSMT [Bru09] which is an open source SMT solver implemented in C++. State-of-the-art model checkers supporting linear temporal logic are Spin [Hol04], SAL [MOR+ 04], and NuSMV [CCG+ 02].}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
However, the input languages of these model checkers do not support set and relation data types and hence are inefficient for representing properties w.r.t. relational models. (for instance, how do you represent: eventually/always something is a subset of something else)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\ulnone\ulc0\animtext0\rtlch \ltrch
\uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
i have no idea which steps are automated in this work (if any!). How do you go from UML to these formulas? How is the model expressed? Plus I think mu-calculus has the same power of expressivity as this combo of LTL and DL.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Model checking driven static analysis for the real world: designing and tuning large scale bug detection (2013)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Working on the intersection of software model checking and automated static bug detection for real-life systems, we address a number of issues: how to scale for real-life systems of 1,000,000 LoC or more, how to quickly write new checks, and most importantly how to distinguish between relevant and irrelevant bugs and fine tune the analysis accordingly. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The advantage of traditional testing is that functional behavior of the software can be examined for the real implementation on the real hardware. This stands in contrast to, e.g., purely model-based approaches. The disadvantage is that testing explores typically only a limited number of program behaviors. Even if all program paths are explored, only a limited set of inputs can be examined, and significant manual effort is required to find the appropriate test cases. One of the most significant disadvantages is that testing does not scale well to large code bases. There are typically an overwhelming number of test cases to consider to achieve a satisfactory coverage. \uc3 \u8592\'e2\'86\'90 for ppt?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In contrast to traditional testing, static program analysis does not execute the implementation, but analyzes the source code for known dangerous programming constructs, for combinations of those and their causal relationships, and the impact of potentially tainted input. Typical examples in C/C++ are null pointer dereferences, accessing freed memory, memory leaks, or creating exploits through buffer overruns. These types of bugs are only found to the extent in that they affect the functional behavior, and since traditional testing is focused on checking the functional behavior of the system, finding these types of bugs is more often a welcome side effect, rather than intentional. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Static program analysis cannot always be precise, since it does not execute the real code, but examines syntactic relations within the source code. This means, over-approximations are used to estimate the actual program behavior. This almost inevitably leads to false alarms, i.e., warnings which are spurious and do not correlate to any actual execution. In addition to these false alarms, there are warnings that pinpoint code where the programmer bends the rules of the C/C++ standard, often to achieve efficiency. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In recent years those techniques have become popular not only for compiler optimization, but also to find certain patterns in programs that indicate bugs or, more generally, software deficiencies. In most circumstances, a static analysis tool is only regarded as useful if the analysis time is roughly in the same order of magnitude as the compilation process and not several orders of magnitude higher. While may-analysis (overapproximation) can turn up significantly more reported bugs, the bugs may not exist in the actual program behavior due to infeasible paths or infeasible data dependencies. In this context, these warnings are called false positives or false alarms). Must-analysis (underapproximation), however, might miss bugs due to the nature of under-approximation. We call these false negatives.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The basic idea of our approach is to map a C/C++ program to its corresponding control flow graph (CFG), and to label the CFG with occurrences of syntactic constructs of interest. The CFG together with the labels can easily be mapped to the input language of a model checker or directly translated into a Kripke structure for model checking.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For p in Fig. 1a, we automatically label the nodes with labels malloc p , used p and f r ee p , as shown in Fig. 1b. These labels are computed based on a library of predefined patterns. In a next step, given this annotated CFG, checking whether p is used after it is freed then amounts to checking the property in computation tree logic (CTL). CTL uses the path quantifiers A and E, and the temporal operators G, F, X, and U. The (state) formula A\uc2 \u966\'cf\'86 means that \u966\'cf\'86 has to hold on all paths, while E\u966\'cf\'86 means that \u966\'cf\'86 has to hold on some path. In CTL a temporal operator is always immediately preceded by a path quantifier. We implemented the aforementioned framework in our tool Goanna. The core of the tool is implemented in OCaml, but it makes used of a third-party C/C++ parser as its front end (roughly 500k LoC of C code) and has a variant that uses the open source model checker NuSMV [13] as its generic analysis engine. Goanna handles full C/C++ including compiler-dependent switches for the GNU gcc and Microsoft Visual C/C++. Moreover, it comes in variants for the integration in either Eclipse or Microsoft Visual Studio. Under the hood, the main components are the model checking-based static analysis engine, the abstract interpretation framework, and the false path elimination engine. Even for very large projects with millions of lines of code, the analysis typically runs in the order of compilation time.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
From the perspective of testing, it matters if a deficiency occurs always or under certain circumstances only. Bugs that occur predictably in every run are easy to find. The only penalty for finding them through testing is that valuable resources have to be spent. In contrast, deficiencies that are data or configuration dependent are much harder to find, since it requires a developer to find specific test cases that expose the bug. Since exhaustive testing is often prohibitive, these kinds of bugs can go undetected for a long time before they manifest themselves. \~\uc3 \u8592\'e2\'86\'90 for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Currently, our reported defect density is around 3.2 warnings per 1,000 LoC for the Firefox code base. The best state-of-the art checkers provide a defect density of around 0.35 for Firefox.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We see two promising areas of research based on our preliminary findings. Firstly, in the recent years there has been a strong push with much success to improve SMT solvers both in capabilities as well as performance, to make them a real alternative for practical program verification. The advantage of SMT solvers are their rich domain-specific data structure support and solving capabilities that enables program analysis on a much more precise level of abstraction. We envisage the use of SMT solvers, e.g., as a means to improve our false path elimination approach by moving from intervals as the underlying abstraction to a more precise model.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We believe that our approach of combining model-checking and static analysis in a close}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
manner we might be able to make significant improvements, because the very nature of model checkers is to analyze inherently concurrent systems. \uc3 \u8592\'e2\'86\'90 for ppt (...but ironically most of the model checkers are sequential)\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Automated formal analysis and verification: an overview (2013)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The most space is devoted to the approach of model checking, including its basic principles as well as the different techniques that have been proposed for dealing with the state space explosion problem in model checking. This paper, however, includes a brief discussion of theorem proving and static analysis too. All of the discussed approaches are introduced mostly on an informal level, with an attempt to provide the reader with their basic ideas and references to works where more details can be found.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Despite that these techniques have been in use for a long time, research and development devoted to their further improvements is still quite active, producing new methods and methodologies such as search-based testing, model-based design, agile testing, or extreme programming. However, these \uc3 \u8211\'e2\'80\'93 let us say \u8216\'e2\'80\'98traditional\u8217\'e2\'80\'99 \u8211\'e2\'80\'93 methods suffer one important deficiency: they cannot prove a system correct, i.e. they cannot prove it to be free of errors with respect to some specification. That is why one can also witness a strong and ever rising interest in the development and applications of formal verification methods that can remove this constraint. Moreover, it turns out that even in cases in which the formal verification process is not completely finished due to its high cost, or when it is intentionally restricted in some way (e.g. by restricting the depth of the state space of the verified system to be traversed or by intentionally suppressing some generated warnings when it is not sure whether they correspond to real errors or not), it may still be quite valuable. This is because even in such cases, it may find a number of errors that are often different from those found by traditional methods, which is due to the very different principles on which these methods work \u8592\'e2\'86\'90 for ppt! \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We use the term formal verification to denote verification methods based on formal mathematical roots and (at least potentially) capable of proving error freeness of systems with respect to some correctness specification. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The potential to detect all errors with respect to a given specification is called soundness of a method.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
It means that if such a method terminates and claims a system correct with respect to a certain specification, the system is indeed correct. On the other hand, we call a method complete if it does not raise false alarms, i.e. if it does not report spurious errors. As we have already indicated above, sometimes, the potential of a method to be sound is sacrificed in order to increase the efficiency of the approach, leading to an error detection approach with formal verification roots. \uc3 \u8592\'e2\'86\'90 for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A lot of effort is, for instance, invested into testing of concurrent software that is very difficult due to many errors manifest only very rarely when the concurrently running processes or threads are scheduled in a very specific way. In order to increase chances to spot such errors, techniques such as injection of noise into the scheduling of concurrent processes have been proposed and supported by tools such as IBM ConTest (Edelstein, Farchi, Nir, Ratsaby, & Ur, 2002) or ANaConDA (Fiedor & Vojnar, 2012). \~}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Theorem proving \uc3 \u8211\'e2\'80\'93 also called as deductive verification \u8211\'e2\'80\'93 is usually a semi-automated approach using some inference system for deducing various theorems about the examined system from the facts known about the system and from general theorems of various logical theories. This approach is quite close to classical mathematical reasoning, but it is supported by computer-aided tools, the so-called theorem provers (or proof assistants), such as PVS. These tools take care of remembering all of the so far deduced facts and of correctly applying inference rules. The inference process is, however, usually guided by the user. The approach is very general but often very hard to use. The approach is sometimes also weak in generating counterexamples (diagnostic information) to correctness specifications in faulty systems \u8211\'e2\'80\'93 one may have troubles to distinguish whether the effort to prove some property is failing because there is an error in the system being examined, or because the user of the method is not bright enough to prove it correct. On the other hand, there has also been a lot of progress in developing automated decision procedures (or satisfiability solvers) for different logics and logical theories. These solvers are used as a building block within various higher level verification methods. Among the solvers, an important position belongs to the so-called SAT solvers, such as Glucose (Audemard & Simon, 2009), deciding satisfiability of propositional formulae, and hence solving the classical Boolean satisfiability problem, i.e. the SAT problem. Another important category of the solvers is then the category of the so-called SMT solvers,2 such as Z3 (de Moura & Bj\uc2 \u248\'c3\'b8rner, 2008), which support various first-order logical theories with equality (such as linear arithmetic, linear real arithmetic, uninterpreted functions, theory of arrays, and so on). \~\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Static analysis is usually characterized as analysis that collects some information about the behaviour of a system without actually executing it under its original semantics. In many cases, static analyses are not designed for checking correctness of programs but to be used within compiling, optimization, code generation, etc. Static analyses are often highly specialized. Compared to model checking, static analyses have often \uc3 \u8211\'e2\'80\'93 though not always \u8211\'e2\'80\'93 the advantage of not needing any model of the environment in which the system should run and of being able to handle very big code bases (even tens of millions of lines of entire operating system kernels, such as Linux or Windows). The need to model the environment and usually also parts of the system being examined (which would otherwise be too big to be handled) may be quite expensive and may also hide some errors, which may be ruled out by the manual modelling. \~more exact description of the use of data flow analysis in leading commercial tools is, unfortunately, difficult due to their producers keeping all details of their tools secret. According to the limited information available, the use of data flow analysis and bug patterns is often combined, e.g. with further pruning of infeasible paths using various logical solvers to check satisfiability of the conditions that appear on the concerned program paths. Furthermore, the tools also exploit statistical methods to distinguish common and less common coding styles used in a program in order to better identify suspicious parts of the code. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Abstract interpretation (Cousot & Cousot, 1977) is a theory of a sound approximation of the semantics of computer programs that, among other applications, allows for constructing static analyses sound by construction. Abstract interpretation consists in giving a class of programs a concrete and abstract semantics defined on suitable concrete and abstract lattice-based domains. These domains are usually linked by a pair of monotone functions \uc3 \u8211\'e2\'80\'93 the so-called abstraction and concretization, traditionally denoted a and g, respectively \u8211\'e2\'80\'93 that form a Galois connection.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Model checking (Baier & Katoen, 2008; Clarke, Grumberg, & Peled, 1999) is an approach of automated checking whether a system (or a model of a system) satisfies a certain \~specification based on a systematic exploration of the state space of the system. \~The system or model to be verified can be described in a variety of different languages ranging from real-life hardware description languages (such as VHDL or Verilog), common programming languages (like C or Java), and various kinds of Petri nets or process algebras to specialized modelling languages (such as the Promela language of the Spin model checker (Holzmann, 1997)). The specification is typically written in some temporal logic such as linear temporal logic (LTL; Pnueli, 1977), computation tree logic (CTL; Clarke & Emerson, 1981), CTL* (Emerson & Halpern, 1986), or m-calculus (Kozen, 1983), but some simpler specification means such as C-like assertions or end-state and progress labels known from Promela can also be used. Model checking has originally been proposed for verification of finite-state systems. Its roots can be traced back to the works (Clarke & Emerson, 1981; Queille & Sifakis, 1982).12 Model checking can usually be fully automated and can generate error traces explaining why a certain property does not hold in a given system. \uc3 \u8592\'e2\'86\'90 for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
An even more complicated situation arises when one wants to apply model checking to infinite-state systems (such as systems with unrestricted parameters and/or various unbounded data and control structures such as communication queues, dynamic linked data structures, stacks, counters, and so on). Clearly, in this case, one cannot simply enumerate reachable states to verify a given system. Indeed, most interesting verification problems over infinite-state systems are undecidable. \~Yet another problem \uc3 \u8211\'e2\'80\'93 which, however, may arise with some forms of static analysis too \u8211\'e2\'80\'93 is the need to model the environment of the system being verified. This modelling task is usually quite tedious and may hide some errors if the model of the environment ignores some behaviour that is possible in practice (on the other hand, if the model of the environment enables some behaviours that are not possible in reality, many false alarms\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
may be obtained). Model checkers for concurrent and distributed systems include, e.g. Spin (Holzmann, 1997) and DiViNe (Barnat, Brim, Ceska, & Rockai, 2010) using specialized input languages (Promela, DVE) for describing models of the verified systems. One of the most successful software model checkers is the Static Driver Verifier (Ball, Cook, Levin, & Rajamani, 2004) from Microsoft that is successfully used for verifying selected critical properties of Windows drivers. Apart from it, there exist many more experimental academic software model checkers such as the Java PathFinder from NASA for model checking Java programs on the byte code level (Visser, Havelund, Brat, Park, & Lerda, 2003); Blast (Henzinger, Jhala, Majumdar, & Sutre, 2003), CPAChecker (Beyer & Keremoglu, 2011), SatAbs (Clarke, Kroening, Sharygina, & Yorav, 2005), Wolverine (Kroening & Weissenbacher, 2011) for model checking C programs using predicate abstraction (briefly discussed in Section 4.3); or bounded model checkers for the C language such as CBMC (Clarke, Kroening, & Lerda, 2004) or LLBMC (Merz, Falke, & Sinz, 2012). Finally, to give some representatives of tools for model checking of real-time and probabilistic systems too, we can mention Uppaal (Behrmann, David, & Larsen, 2004) and Prism (Kwiatkowska, Norman, & Parker, 2011).}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In the previous section, we have introduced model checking as an automated technique that verifies a system (or its model) against a property specified in some suitable way through a systematic exploration of the state space of the system (or its model). We have said that many different languages can be used for specifying the properties to be verified. We now concentrate on two of these languages that belong among the most often used, namely the LTL (Pnueli, 1977) and the CTL (Clarke & Emerson, 1981). \uc3 \u8592\'e2\'86\'90 for future work\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
LTL and CTL differ primarily in the underlying notion of time. LTL considers time to be linear, and it views the behaviour of a system as a set of linear executions. On the other hand, CTL considers time to be branching, and it views the behaviour of a system as a tree of gradually branching executions. Both of the logics, however, work with logical time only, which allows one to express requirements on the order in which certain states (events) should occur in the system, but unlike physical time, it does not allow one to measure how much time elapses between two states (events). }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Both LTL and CTL allow one to express various safety as well as liveness properties. Intuitively, safety properties state that nothing bad ever happens (and counterexamples to them are finite executions) whereas liveness properties state that something good eventually happens (and counterexamples to them are infinite or at least complete executions, i.e. executions that cannot be extended any more). Examples of safety properties can be the following: \uc3 \u8216\'e2\'80\'98A deadlock never happens\u8217\'e2\'80\'99 or \u8216\'e2\'80\'98The length of a certain buffer never exceeds five elements\u8217\'e2\'80\'99. Examples of liveness properties can be: \u8216\'e2\'80\'98The program eventually terminates\u8217\'e2\'80\'99 or \u8216\'e2\'80\'98Each incoming request is eventually handled by a server\u8217\'e2\'80\'99. \u8592\'e2\'86\'90 for meeting!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In order to verify liveness properties, one usually has to provide some fairness assumptions limiting the non-determinism in the system to be verified in order to avoid artificial counterexamples that never happen in practice. This especially concerns the scheduling of concurrently running processes for which one typically wants to state, without having to precisely describe the scheduler used, that a process that is ready to run will not wait for ever. Formulae of LTL (Pnueli, 1977) are built from atomic propositions allowing one to refer to relevant aspects of the particular states of the system being verified,14 Boolean constants and connectives (coming from and used in the same way as in propositional logic), and, most importantly, temporal operators that allow one to express logical timing requirements. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We can now formalize the semantics of LTL formulae. Let M be a Kripke structure...}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
One of the most common approaches to LTL model checking is the automata-theoretic approach (Vardi, 2007; Vardi & Wolper, 1986) whose basic idea we will now describe. Assume that we are given a Kripke structure M describing the state space of the system to be verified and an LTL formula w describing a correctness requirement on the system. We need to check whether any execution path p starting from any initial state of M satisfies w.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To check this using the automata-theoretic framework, one can use Buchi automata and/or various other finite automata accepting infinite words as follows.17}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
First, one constructs a non-deterministic Buchi automaton A:w that accepts infinite kwords corresponding exactly to those execution paths that do not satisfy w. Second, the Kripke structure is converted to a non-deterministic Buchi automaton AM accepting infinite words corresponding exactly to all the execution paths of M. Third, the product automaton AM ^ A:w , which accepts the intersection of the languages of AM and A:w, is constructed. Finally, emptiness of the language of AM ^ A:w is checked. If the language of the product automaton is empty, the system modelled by M satisfies w. Otherwise, the language of the product automaton consists of words corresponding exactly to those executions of M that break the specification w. \uc3 \u8592\'e2\'86\'90 monitoring process\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The translation from a Kripke structure to a non-deterministic Buchi automaton is easy. Essentially, the Kripke structure M is converted to a non-deterministic Buchi automaton AM by using 2AP as the alphabet, adding a new initial state with outgoing transitions leading to all initial states of M, moving the labelling of the states of M to their incoming transitions, and making all states accepting. On the other hand, the construction of the non-deterministic Buchi automaton A:w is far beyond the scope of this article. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We just note that its size may be exponential in the size of the formula: indeed, LTL model checking is linear in the size of M but PSPACE-complete in the size of w. However, various heuristics for keeping the size of A:w as small as possible have been proposed and implemented in freely available translators from LTL to Buchi automata, such as the LTL2BA tool implementing the translation proposed in Gastin and Oddoux (2001). \uc3 \u8592\'e2\'86\'90 for future work \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Note also that the non-deterministic Buchi automaton is constructed for the negation of w. A construction of the automaton for w, followed by complementing the automaton, is possible, but it is typically avoided since complementation of non-deterministic Buchi automata is quite complicated and costly. \uc3 \u8592\'e2\'86\'90 for meeting: complementing the formula is easier than complementing the automaton itself Finally, let us note that despite LTL model checking is linear in the size of the Kripke structure and exponential in the size of the formula being checked, it is usually the size of the Kripke structure that is problematic. This comes from that the formulae of interest are often very small, but the Kripke structures tend to be very large. Indeed, they represent the state space of the system being verified, which is often exponentially larger than the system itself. To cope with this situation, various heuristics are used. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
First of all, one can use the so-called on-the-fly model checking (Holzmann, 1996) in which the Kripke structure is not generated first and only then explored. Instead, the property Buchi automaton is composed with the Kripke structure during the generation of the latter. This has two advantages. First, one can stop the state space generation as soon as an error is found, possibly avoiding generation of many further states (which can be quite useful since erroneous systems tend to have more states because they do not observe various invariants they should otherwise observe). Moreover, one can avoid generation of parts of the state space for which it is clear that they do not compose with the property automaton (and hence cannot lead to any error). The state space generation is thus property driven. \uc3 \u8592\'e2\'86\'90 for future work\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Formulae of CTL (Clarke & Emerson, 1981) are built from atomic propositions, Boolean constants and connectives, temporal operators, }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
and universal and existential path quantifiers A and E. Compared to LTL, the path quantifiers are added, which is consistent}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
with CTL being a branching time logic. The use of the path quantifiers is, however, restricted in CTL in that the temporal operators and path quantifiers must regularly interleave, leading to 10 non-propositional connectives: AX, EX, AF, EF, AG, EG, AU, EU, AR, and ER.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The satisfaction relation of CTL formulae is defined for each state of a Kripke structure, taking into account all execution paths that originate from that state. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
As in the case of LTL, the above-introduced set of connectives is not minimal. In particular, to preserve the expressive power of CTL, it is enough to use atomic propositions, negation, disjunction, and the following three non-propositional connectives: EX, EG, and EU. The meaning of the other non-propositional connectives can be obtained...}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For a given Kripke structure M and a CTL formula F, we can now define the so-called satisfaction set Sat\uc2 \u240\'c3\'b0F\u222\'c3\'9e 1\uc3 \u8260\'e2\'81\'844 \{s [ Sj s o F\}, i.e. the set of all the states of M that satisfy F. \u8592\'e2\'86\'90 it is state-based\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Let M 1\uc3 \u8260\'e2\'81\'844 \uc2 \u240\'c3\'b0S; S0 ; R; L\u222\'c3\'9e be a Kripke structure over a non-empty finite set of atomic propositions AP, and let F be a CTL formula over AP. The basic algorithm of CTL model checking (i.e. checking whether M o F holds) is rather straightforward. It consists in computing the satisfaction sets for all sub-formulae of F, followed by checking that the set S0 of initial states of M is included in Sat (F).\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Although many relevant properties of systems to be verified can be specified both in LTL}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
and CTL, the expressive power of these logics is, in fact, incomparable. Some properties}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
expressible in LTL (e.g. FG p) cannot be expressed in CTL while some properties expressible in CTL (e.g. AG EF p) cannot be expressed in LTL. The CTL* logic proposed in Emerson and Halpern (1986) combines features of both LTL and CTL and is more expressive than any of them. The syntax of CTL* is easy to obtain from that of CTL by lifting the restriction on the regular interleaving of path quantifiers and temporal connectives. A commonly used temporal logic that is even more expressive than CTL* is then the modal m-calculus (Kozen, 1983), which is based on allowing one to explicitly use least/greatest fixpoint operators on sets of states (thus essentially allowing one to define new specialized modalities) \uc3 \u8592\'e2\'86\'90 for future work, also meeting!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The state explosion stems from a huge number of possible interleavings of concurrently running processes (a system with n processes, each having k states, may have up to k n reachable states) and/or from a huge number of possible data values that may be handled by the system to be verified (indeed, a single 32-bit-wide integer variable can have 232 possible values, n of such variables then have 232.n possible values). The first possible approach to cope with the state space explosion problem is to store state spaces as compactly as possible. One way to achieve compactness is to store state spaces in a hierarchical way.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Another approach is to use the so-called symbolic verification that, instead of exploring individual states one by one, works with sets of states at the same time. These sets must, of course, be encoded in a way allowing for an efficient manipulation with them. The most famous symbolic verification method is probably the one based on binary decision diagrams (Bryant, 1986; Burch, Clarke, McMillan, Dill, & Hwang, 1992), commonly abbreviated as BDDs. The use of BDDs is behind many successes of model checking, especially in hardware. When using BDDs for symbolic model checking, one needs to use BDDs not only to represent sets of reachable states but also the transition relation of the system being examined. Moreover, one needs to be able to compute satisfaction sets of temporal formulae purely on the level of BDDs (and hence, equivalently, propositional formulae).}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For that, fixpoint characterizations of temporal operators, such as those used in Section 3.4, are useful since they can be easily written as (quantified) propositional formulae. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Sometimes, the compact representation of state spaces may disregard some information in which case soundness of model checking is deliberately sacrificed in order to achieve efficiency. This way, an error detection method with formal verification roots is obtained. An example of such an approach is the bit-state hashing method \uc3 \u8592\'e2\'86\'90 error detection method with formal verification roots\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The goal of state space reduction techniques is to avoid generation and exploration of states for which it is clear that their properties are not important with respect to the specification being checked, or their properties are covered by the properties of other explored states. We are by far, of course, not able to describe all the numerous state space reduction techniques studied in the literature, and so we will briefly present just three of them that are quite commonly used. One of the commonly used ways to reduce the generated and explored portion of the state space of a system being verified is the on-the-fly model checking (Holzmann, 1996) when the property to be examined is checked in parallel with the state space generation. As we have already mentioned in Section 3.2, this approach builds on the fact that the state space generation can sometimes be driven by the property being checked. For instance, when using an automata-theoretic approach to model checking, one can avoid generation and exploration of certain paths in the state space once it is clear from their already generated prefixes that they cannot be accepted by the automaton describing undesirable behaviours. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Another commonly used state space reduction is the so-called symmetry reduction. Intuitively, this approach builds on identifying sets of the so-called symmetrical states that can be made identical by exchanging the roles of some of their components. Out of the sets of symmetrical states, it is then enough to explore just one representative state. One can, e.g. rotate the philosophers in the well-known dining philosophers problem since it is not really important whether the first one is eating and the others are thinking, or the third one is eating and the others are thinking, and so on (cf. Figure 2). Clearly, similar situations are likely to arise in many practical scenarios when dealing with replicated components, objects, processes, and the like. The use of symmetries is especially important in the context of verification of systems with dynamically instantiated processes or objects. where the use of fresh identifiers of processes or objects being regularly destroyed and created may cause a very significant state explosion. Of course, a problem that must be addressed when applying symmetries is how to detect symmetrical states efficiently or, even better, how to transform states into a canonical form in order not to loose too much time by testing whether some states are or are not symmetrical (which is to be performed every time a potentially new state is generated).}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Another very important state space reduction, particularly successful in model checking of concurrent systems, is the so-called partial-order reduction or commutativity-based reduction. This reduction aims at reducing the amount of interleaving of concurrently enabled actions. In particular, if some concurrently enabled actions are independent (i.e. they do not mutually influence the enabledness and the effect of each other) and, moreover, the order of executing the actions is not visible through the property being checked (i.e. the order of executing the actions is not important for the validity of the property), the actions are fired in one of the possible orders only. The main practical issue with partial-order reduction is how to efficiently decide which actions are independent in order for the overhead of the reduction not to be higher than what it brings.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
When abstraction is combined with model checking (Clarke, Grumberg, & Long, 1994), only some selected aspects of states are tracked, hopefully yielding a smaller abstract state space to be explored. For instance, instead of remembering that a state in which the variable x has value 100 and the variable y has value 10 is reachable, they may remember that a state where}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
x>y is reachable only. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A further way to cope with the state space explosion problem is to bound the state space exploration in some way. As in the case of the above-mentioned bit-state hashing, this usually results in an unsound technique which can, however, be still very well used as a systematic testing approach. One natural way how the state space exploration can be bounded is to restrict the depth of the state space exploration, leading to the classical notion of bounded model checking (Biere, Cimatti, Clarke, Strichman, & Zhu, 2003). In this case, the behaviour of the system is unfolded some given number of steps. An important observation is that the unfolded behaviour can easily be captured by a formula that can subsequently be conjoined with another formula describing undesirable behaviours, and the constantly increasing power of various SAT or SMT solvers can then be utilized to check satisfiability of the resulting formula. Yet another approach is to use more computational power in the form of distributed computing environments, external storage (instead of RAM), multiprocessor systems, graphics processing units, and so on. For examples of such approaches, see, e.g. Barnat...However, dealing with infinite-state systems is common in practice due to using various unbounded data and control structures (such as queues, stacks, counters, dynamic linked data structures, or unrestricted dynamic creation of processes, objects, and so on) or due to using parameterized designs. That is why techniques for model checking of such systems are also highly needed and studied. In their case, however, one clearly cannot use a systematic enumeration of all individual reachable}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
states. One possibility of verifying infinite-state systems via model checking is to use the so-called cut-offs. Despite the immense amount of work that has been invested into the development of the different techniques of formal analysis and verification, }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
there is still a lot of space for improving their generality, efficiency, and degree of automation}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. \uc3 \u8592\'e2\'86\'90 for ppt: my focus is on automation\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Works going in these directions are constantly appearing and are likely to appear in the future too since the interest in all forms of automated verification is currently very high, and it is likely that the interest will further grow due to the ever increasing impact of computer systems on human lives.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Expressing Property Specification Patterns with OCL}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The textual Object Constraint Language (OCL) is an official part of the Unified Modeling Language (UML). OCL is primarily used to formulate restrictions over UML modsels, in particular, invariants and operation pre- and post-conditions in the context of class diagrams. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
However, OCL is missing means to specify constraints over the dynamic behavior of a UML model. We have therefore developed a temporal extension of OCL that enables modelers to specify behavioral state-oriented constraints.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
That work provides an alternative to the rather cryptic temporal logic formulae that are commonly used to specify behavioral system properties. OCL is a declarative language, not a programming language, i.e., evaluation of OCL expressions does not have side effects on the corresponding UML model. To integrate constraints into the visual modeling approach of UML, invariants, pre- and postconditions are modeled as comments and are attached to the respective graphical model elements in class diagrams. However, OCL constraints can become quite complex, such that they are often specified separately. We briefly explain how to read that OCL invariant. The class name that follows the keyword \uc3 \u8217\'e2\'80\'99context\u8217\'e2\'80\'99 specifies the class for which the following expression should hold. The keyword \u8217\'e2\'80\'99inv\u8217\'e2\'80\'99 indicates that this is an invariant specification, i.e., for each object of the context class the following expression must evaluate to true at all times. But note that it is possible that an invariant is violated during execution of an operation. More precisely, an invariant therefore has to hold only for an object when none of its operations is currently executed. However, it is not formally defined in the official UML 1.5 specification when invariants are exactly to be checked, but it is commonly agreed that each time after the object\u8217\'e2\'80\'99s status has changed, its invariants have to hold (e.g., immediately after completion of an operation).\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Though UML has received increasing attention to model software systems in recent years, it is missing sufficient means to specify constraints over the dynamic behavior of a UML model. However, it is essential to be able to for \~mulate such temporal constraints already in early phases of development in order to specify correct system behavior, in particular in the domain of time-dependent systems. W}{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
hile other research approaches focus on UML Collaboration and Sequence Diagrams and consider temporal OCL constraints for event communication (e.g., [2, 9]), we here investigate \~consecutiveness of states and state transitions in UML Statecharts. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this article, we now show that the chosen approach is powerful enough to express system properties that frequently appear in practical systems development. We take the property specification patterns identified by Dwyer et al. [3, 4] and demonstrate that it is possible to formulate according temporal OCL expressions in each case. Note that beyond those general patterns, our OCL extension also covers explicit timing aspects, i.e., additional timing intervals can be attached to temporal OCL expressions to further delimit pattern scopes. Due to space limitations, we can only provide an informal semantics description of the temporal OCL expressions. \uc3 \u8592\'e2\'86\'90 for ppt: this is so far only an informal semantics description...\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Experiences in the domain of formal specification have shown that the full power of temporal logics, which allow for arbitrarily nested formulae, is not needed in practice. In this context, Dwyer et al. have developed a pattern system based upon more than 500 property specifications from different projects in the area of finite-state verification. That pattern system provides a structured set of commonly occurring property specifications and examples of how to translate these into different formal specification languages, such as Linear Temporal Logic (LTL), Computation Tree Logic (CTL), or Graphical Interval Logic (GIL). These formulae can be directly applied in different verification tools, \~e.g., the model checking tools SPIN (accepts LTL) or SMV (accepts CTL).1 As such verification tools require rather cryptic temporal logic formulae as one part of the input for the verification task, the pattern approach aims to support developers in a way that abstracts from the formal syntax of temporal logics. \uc3 \u8592\'e2\'86\'90 for meeting\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Dwyer et al. have identified different scopes applicable to a pattern. A scope is the part of the system execution path over which a pattern has to hold. \uc3 \u8592\'e2\'86\'90 for meeting\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The patterns themselves are hierarchically ordered as shown in Figure 3. In an online repository, for each pattern, each scope, and each formalism an according formal description is provided. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this section, we demonstrate how to express patterns of the pattern system presented in Section 2 by means of our temporal state-oriented OCL extension}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. UML Statecharts are for modeling the reactive object behavior of objects. Basically, they are an object-oriented version of Harel Statecharts [8]. In a UML Statechart, the term \uc3 \u8217\'e2\'80\'99current state\u8217\'e2\'80\'99 cannot be applied without causing confusion, as it can have composite (i.e., nested and orthogonal) states and thus may reside in more than one state at the same time. The following concepts and operations have been newly introduced to OCL to be able to express the specification patterns. Note that we keep compliant with the existing standard OCL syntax and reuse as often as possible existing collection operations like forAll(), exists(), includes(), and excludes(). The only state-related operation of the current OCL standard as well as the new OCL 2.0 proposal is called oclInState(s:OclState). It is defined over objects of user-defined classes that have an associated State-chart. Operation oclInState(s:OclState) returns true if state s is currently active. In addition to OCL invariants declared by the keyword inv, we introduce a new clause called init. In contrast to an invariant over an object obj that has to hold each time after obj\u8217\'e2\'80\'99s status has changed, the expression of an init-clause has to hold only at the starting point of execution. Nevertheless, note that the expression of the init-clause may be a temporal OCL expression. Temporal OCL expressions are a new concept introduced to enable specification of dynamic, behavioral constraints. In our approach, temporal OCL expressions make use of a special temporal operation with signature post(a:Integer,b:OclAny).\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We newly introduce the boolean operation startsWith(g:Sequence(T)), which can be applied to sequences of objects of some type T. That operation checks whether a given sequence starts with a sequence specified by parameter g.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
example ocl property:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li1440\ri0\lin1440\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
context Machine}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li1440\ri0\lin1440\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
inv: self.oclInConf(Loading) implies}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li1440\ri0\lin1440\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
self@post(1,100)->forAll( g |}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li1440\ri0\lin1440\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
g->includes(Sequence\{Working,Unloading,Idle\}))}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
bljak? This kind of property is heavily related to what is called chained precedence and response in the original pattern system. But note that we additionally can make use of time limitations. We think that this work can help to increase the acceptance of formal specification in the domain of object-oriented modeling with UML. Developers familiar with the UML standard should easily understand our OCL extension, as \uc3 \u8211\'e2\'80\'93 in contrast to other approaches \u8211\'e2\'80\'93 it keeps compliant with current OCL syntax and language concepts. \u8592\'e2\'86\'90 also a problem is to what extent are developers familiar with a declarative lanugage such as OCL, even though it\u8217\'e2\'80\'99s part of UML? \u8592\'e2\'86\'90 for meeting? future work?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
All 1999 article patterns are described in OCL expressions which is cool. But state machines are necessary as design artifact.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A Library of OCL Specification Patterns for Behavioral Specification of Software Components (2006)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
One current problem in component specifications comes from the fact that editing OCL constraints manually is time consuming and error-prone. To simplify constraint definition we propose to use specification patterns for which OCL constraints can be generated automatically. In this paper we outline this solution proposal and present a library of reusable OCL specification patterns.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The behavioral specification of a component is based on its interface specification and on its specification data model and consists of OCL expressions that constrain the components operations. It guarantees that different sales orders always differ in the value of their id \uc3 \u8211\'e2\'80\'93 that is the attribute id is a semantic key for sales orders. By defining an invariant this constraint needs only to be formulated once and does not need to be repeated in several pre-and postconditions. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The disadvantages of earlier formal methods are reduced by UML OCL [18]: The notation of OCL has a comparatively simple structure and is oriented towards the syntax of object-oriented programming languages. Software developers can therefore handle OCL much easier than earlier formal methods that were based on set theory and predicate logic. This is one reason why OCL is recommended by many authors for the specification of software components. Despite its advantages OCL can not solve all problems associated with the use of formal methods: One result of two case studies specifying business components [1,2] was the insight that editing OCL constraints manually is nevertheless time consuming and error-prone. Similar experiences were made by other authors that use OCL constraints in specifications (outside the component area), e.g. [12,15]. They conclude that it takes a considerable effort to master OCL and use it effectively. Solution strategies to simplify OCL specifications include better tool support (to reduce errors) and an automation of constraint editing (to reduce effort) \uc3 \u8211\'e2\'80\'93 the latter can e.g. be based on use cases or on predefined specification patterns. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Under (OCL) specification pattern we understand an abstraction of OCL constraints that are similar in intention and structure but differ in the UML model elements used. Each pattern has one or more pattern parameters (typed by elements of the UML metamodel) that act as placeholder for the actual model elements. With pattern instantiation we denote a specific OCL constraint that results from binding the pattern parameters with actual UML model elements. \uc3 \u8592\'e2\'86\'90 for future work!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
If such OCL specification patterns are collected, formally described and integrated into a specification tool the specification can be simplified. Note that the tool can be built in such a way that it restricts the input to those model elements that are allowed for a pattern \uc3 \u8211\'e2\'80\'93 in section 3 of Fig. 4 for instance you can see that the tool only offers the attributes of class SalesOrder for selection. In this section we introduce a list of OCL specification patterns that are useful for behavioral specification of software components. To obtain this list we first studied several case studies (dealing with business components) and publications about component specifications and identified frequently occurring patterns [3]. In a second step we analyzed the preliminary list and identified additional patterns that are useful but could not be found in the first step. (Reasons to include additional patterns were for instance extending patterns to other relevant UML metamodel elements or symmetry considerations like including a constraint for deleted instances if there is one for created instances.) As result we obtained a library of altogether 18 OCL specification patterns which are subdivided into four categories. \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The behavioral specification of software components refers to the interface specification (cf. Fig. 1) and the specification data model (cf. Fig. 2). \uc3 \u8592\'e2\'86\'90 but these are really static views :( :(\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Using this pattern one can e.g. demand that the field must be greater than zero or contain a specific element of an enumeration. The second category (cf. Table 2) features patterns that only concern the specification data model. They are independent from operation calls and thus all invariants. The third pattern category (cf. Table 3) contains patterns that deal with the exis-}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
tence of specific class instances for an operation call. The fourth pattern category (cf. Table 4) collects further patterns that allow specifying prerequisites from model instances for an operation call and consequences of operation calls for model instances. Pattern 15 (Postcondition for an Instance Attribute) describes a postcondition that can be used to assure that an attribute of a given class instance has a certain value (or value range) at the end of an operation call. The specification patterns identified in Sect. 5 need to be described precisely in order to be reusable for component specifications. For that we propose to use on one hand a description scheme and on the other hand a formal specification. The formal specification is done by using OCL itself and addresses OCL experts and tool builders who wish to implement constraint generators. The description scheme addresses users of specification patterns \uc3 \u8211\'e2\'80\'93 for this it contains all relevant specification details in a more informal way. To confront a pattern user with the full OCL specification would contradict the goal to support specifications by non-OCL experts as well. In this section we present both description approaches.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The first characteristic is the pattern name that identifies the pattern and serves as a short semantic explanation. The characteristic pattern intent contains a short statement about intention and rationale of the pattern. The characteristic pattern parameter lists the parameters of the pattern together with their type. Parameters can be of elementary type (like String) or are elements from the UML metamodel (layer M2 in the four-layer metamodel hierarchy of UML [17]). Parameters of pattern 7 are the class cl (of type Class) and the list of key attributes keyList (of type ordered set of Property). The characteristic restrictions denotes what conditions the pattern parameters must fulfill. In our case it is required that all elements of keyList are attributes of cl. The remaining three characteristics describe the OCL constraint the pattern represents. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
With constraint type we denote if the constraint is an invariant, pre- or postcondition. \uc3 \u8592\'e2\'86\'90 these are the only constraint types that the paper tackles\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Note that the chosen notation for the characteristic constraint body is sufficient to give an idea of the generated OCL expression but has its limitations if patterns are variable. The basic idea how to formally describe the specification patterns is as follows: For each OCL specification pattern a specific function (called OCL pattern function) is defined. The pattern parameters are the input of the pattern function. Result of the pattern function is a generated OCL constraint which is returned and (if integrated with the specification tool) automatically added to the corresponding UML model element. The OCL pattern functions themselves are specified by OCL. All pattern functions are assigned as operations to a new class OclPattern which logically belongs to the layer of the UML metamodel. By defining OCL pattern functions for the specification patterns it became possible to formally specify the patterns completely and quite elegantly: the pattern parameters can be found as function parameters and the function specification (which uses again OCL) describes the prerequisites to apply the pattern and the properties of the constraint to be generated. One big advantage is that this approach only uses known specification techniques and does not require the invention of new ones. There is only one new class OclPattern that encapsulates the definition of all patterns. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\ulnone\ulc0\animtext0\rtlch \ltrch
\uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
but this paper does not yet introduce temporal properties? Like before/until etc...}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
STAIRS towards formal design with sequence diagrams (2005)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
STAIRS has been designed to facilitate the use of interactions for requirement capture as well as test specification. STAIRS assigns a precise interpretation to the various steps in incremental system development based on an approach to refinement known from the field of formal methods and provides thereby a foundation for compositional analysis. An interaction may characterize three main kinds of traces. A trace may be (1) positive in the sense that it is valid, legal or desirable, (2) negative meaning that it is invalid, illegal or undesirable, or (3) inconclusive meaning that it is considered irrelevant for the interaction in question. The basic increments in system development proposed by STAIRS, are structured into three main kinds referred to as supplementing, narrowing and detailing. Supplementing categorizes inconclusive traces as either positive or negative. Narrowing reduces the set of positive traces to capture new design decisions or to match the problem more adequately. Detailing involves introducing a more detailed description without significantly altering the externally observable behavior.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A UML interaction is a specification of how messages are sent between objects or other instances to perform a task. Interactions are used in a number of different situations. They are used to get a better grip of a communication scenario for an individual designer or for a group that needs to achieve a common understanding of the situation. Interactions are also used during the more detailed design phase where the precise inter-process communication must be set up according to formal protocols. When testing is performed, the behavior of the system can be described as interactions and compared with those of the earlier phases. \uc3 \u8592\'e2\'86\'90 for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Interactions seem to have the ability to be understood and produced by professionals of computer systems design as well as potential end-users and stakeholders of the (future) systems. \uc3 \u8592\'e2\'86\'90 for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Interactions will typically not tell the complete story. There are normally other legal and possible behaviors that are not contained within the described interactions. Some people find this disturbing and some project leaders have even tried to request that all possible behaviors of a system should be documented through interactions in the form of e.g. sequence diagrams or similar notations. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Our position is that UML interactions are expressed through notations that lend themselves well to conveying important information about the interplay between objects, but interactions are not so well suited to define the complete behavior. \uc3 \u8592\'e2\'86\'90 for ppt: I beg to differ: just like a procedural programming should describe the entire/complete intended behavior of a system, in the same manner sequence diagrams should be able to tell the whole story\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
STAIRS views the process of developing the interactions as a process of learning through describing. From a fuzzy, rough sketch, the aim is to reach a precise and detailed description applicable for formal handling. To come from the rough and fuzzy to the precise and detailed, STAIRS distinguishes between three main sub-activities: (1) supplementing, (2) narrowing and (3) detailing. Supplementing categorizes (to this point) inconclusive behavior as either positive or negative recognizing that early descriptions normally lack completeness. The initial requirements concentrate on the most obvious normal situations and the most obvious exceptional ones. Supplementing supports this by allowing less obvious situations to be treated later. Narrowing means reducing the allowed behavior to match the problem better. Detailing involves introducing a more detailed description without significantly altering the externally observable behavior. Under-specification as described in the previous paragraph gives rise to non-determinism in the specification. Under-specification allows the system developer to choose between several potential behaviors. Sometimes, however, it is essential to retain non-determinism in the implementation reflecting choice. \~It is quite different, however, to reduce nondeterminism if each alternative represents a distinct and intended behavior. As a consequence, we need to distinguish explicit non-determinism capturing mandatory behavior from non-determinism expressing potential behavior. Should allow specification of negative behavior in addition to positive behavior. Interactions are not only suited to capture system requirements. They may just as well describe illegal or undesirable behavior. Should support compositional analysis, verification and testing. Models are of little help if they cannot be used}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
as a basis for analysis, verification and testing. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The most visible aspects of a UML interaction are the messages between the lifelines. The sequence of the messages is considered important for the understanding of the situation. The data that the messages convey may also be very important, but the interactions do not focus on the manipulation of data even though data can be used to decorate the diagrams. \uc3 \u8592\'e2\'86\'90 for ppt: we also don\u8217\'e2\'80\'99t focus on data manipulation here, though it\u8217\'e2\'80\'99s not less relevant for the purpose of model checking. We do however include the data in the model.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Interactions focus on the interplay between objects. In the tradition of telecommunications these objects are independent and themselves active as stand-alone processes. Therefore, when a message is sent from one lifeline to another, what happens on the sending lifeline is independent}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
from what happens on the receiving side. The only invariant is that the sending of a message must occur before the reception of that very message. Most people find this obvious. \uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
FOR PPT! This misconception seems to continue from the telecommunications history. Nowadays these are not processes but are objects! }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The sending of a message and the reception of a message are examples of what we call events. An event is something that happens on a lifeline at one point in time. An event has no duration/. \uc3 \u8592\'e2\'86\'90 for ppt!!!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A trace is a sequence of events ordered by time. A trace describes the history of message-exchange corresponding to a system run. A trace may be partial or total. Interactions}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
may be timed in the sense that they contain explicit time constraints. \uc3 \u8592\'e2\'86\'90 we do not treat time in this context because we don\u8217\'e2\'80\'99t deal with realtime systems \u8592\'e2\'86\'90 for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this section we will give a very brief introduction to the trace semantics of UML 2.0 interactions expressed in sequence diagrams and interaction overview diagrams}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The interaction of Fig. 2 shows two messages both originating from L1 and targeting L2. The order of the events on each lifeline is given by their vertical positions, but the two lifelines are independent. Each of the messages has the semantics given for the message in Fig. 1, and they are combined with what is called weak sequencing. Weak sequencing takes into account that L1 and L2 are independent. The weak sequencing operator on two interactions as operands is defined by the following invariants:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
1. The ordering of events within each of the operands is maintained in the result. 2. Events on different lifelines from different operands may come in any order. 3. Events on the same lifeline from different operands are ordered such that an event of the first operand comes before that of the second operand.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Thus, if we denote the weak sequencing operator by seq}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
according to UML 2.0, we get:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
W = !x, ?x seq !y, ?y}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
= \{ !x, ?x, !y, ?y , !x, !y, ?x, ?y \}}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The sending of x must be the first event to happen, but after that either L1 may send y or L2 may receive x. Intuitively, an interaction occurrence is merely shorthand for the contents of the referenced interaction. \uc3 \u8592\'e2\'86\'90 they mean interaction reference probably\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In Fig. 4 we introduce another construct called combined fragment. Combined fragments are expressions of interactions combined differently according to which operator is used. In fact, also weak sequencing is such an operator. In Fig. 4 we have an alternative combined fragment. In Fig. 9 we show a more elaborated scenario where this negative scenario has been included through a combined fragment with the operator neg. This indicates that all traces in this fragment are \uc3 \u8220\'e2\'80\'9cnegative\u8221\'e2\'80\'9d or undesirable. In combination with other traces this negative fragment gives negative traces for every trace leading up to it. In our example the intuition is simple; any trace that gives no money back when the receipt says it should have, is a negative scenario. The subtraces that will follow the negative fragment, the return of the card, certainly does not make\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
the scenario less negative. Still we have not defined all possible scenarios of withdrawing money in an ATM. At this stage it is up to our imagination and the scope of our specification what cases we care to describe. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Semantically, each negative behavior is represented by a trace. Ignoring mandatory behavior that is the issue for the next section, but considering both positive and negative behavior, the semantics of an interaction may be represented by a pair of sets ( p, n) where n contains the negative traces and p contains the positive traces. The same trace should not be both positive and negative. Traces that are neither negative nor positive are inconclusive, i.e. considered irrelevant for the specification. On the other hand, we would like to convey that every ATM should offer withdrawal of native money. We specify that this is a mandatory requirement. We need a way to say that it is provisional whether both euros and US dollars are offered, but there is no choice not to offer withdrawal of native money. The latter distinction cannot be expressed directly by the operators of UML 2.0, but we have introduced a small extension and called this choice between alternatives that are mandatory as xalt. \uc3 \u8592\'e2\'86\'90 this is what \u8220\'e2\'80\'9cmandatory\u8221\'e2\'80\'9d behavior is based on in their approach. story ends.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Supplementing means reducing the set of inconclusive traces by defining more traces as either positive or negative. Any originally positive trace remains positive, and any originally negative trace remains negative.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
When the designers have reached a description that they consider sufficiently complete, they will focus on making the descriptions suitable for implementation. Typically an implementation may decline to produce every positive potential trace. We define narrowing to mean reducing underspecification by eliminating positive traces without really changing the effect of the system.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In our context of interactions, reducing the variability/under-specification means to move traces from the sets of positive traces to the set of negative. The semantics of sequence diagrams is defined by a function [[ ]] that for any sequence diagram d yields a set [[d]] of interaction obligations. As explained in Sect. 3.4, an interaction obligation is a pair ( p, n) of sets of traces where the first set is interpreted as the set of positive traces and the second set is the set of negative traces. The term obligation is used to explicitly convey that any implementation of a specification is obliged to fulfill each specified alternative. More complex sequence diagrams are constructed through the application of various operators. We focus on the operators that we find most essential, namely negation (neg), potential choice (alt), mandatory choice (xalt), paral-}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
lel execution (par), and weak sequencing (seq)...}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Notice that a negative trace cannot be made positive by reapplying neg. Negative traces remain negative. Negation is an operation that characterizes traces absolutely and not relatively. The intuition is that the focus of the neg construct is on characterizing the positive traces in the operand as negative. Negative traces will always propagate as negative to the outermost level. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The alt construct defines potential traces. The semantics is the union of the trace sets for both positive and negative. The xalt construct defines mandatory choices. All implemen tations must be able to handle every interaction obligation. \~}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Weak sequencing is the implicit composition mechanism combining constructs of a sequence diagram. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Refinement means to add information to a specification such that the specification becomes closer to an implementation. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This may also be characterized as a two-layer approach }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
as it takes the basic message sequence charts as starting point and add modal characteristics upon those. The modal expressiveness is strong in LSC since charts, locations, messages and conditions are orthogonally characterized as either mandatory or provisional. Since LSC also includes a notion of subchart, the combinatory complexity can be quite high.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Mandatory as in LSC should not be confused with mandatory as in STAIRS, since the latter only specifies traces that must be present in an implementation while the first specifies all allowed traces. Hence, mandatory as in STAIRS does not distinguish between universal or existential interpretation, but rather gives a restriction on what behaviors that must be kept during a refinement. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Refining UML interactions with underspecification and nondeterminism (I have a similar one!)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Formal verification of UML state diagrams: a petri net based approach}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
From scenarios to code: An air traffic control case study\uc3 \u8221\'e2\'80\'9d.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
They define a mapping algorithm that produces statecharts from sequence diagrams, and they show how code can be generated from the models. \uc3 \u8592\'e2\'86\'90 perhaps useful?\uc1 }
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------s}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Extracting Models from Source Code in Software Modernization}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
TEPE: A SysML Language for Time-Constrained Property Modeling and Formal Verification \uc3 \u8592\'e2\'86\'90 really, for realtime systems\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A property expression language, a formal semantics, and a tool. The paper introduces TEPE, a graphical TEmporal Property Expression language based on SysML parametric diagrams. TEPE enriches the expressiveness of other common property languages in particular with the notion of physical time and unordered signal reception. TEPE is further instantiated in the AVATAR real-time UML profile. TTool, an open-source toolkit, implements a press-button approach for the formal verification of AVATAR-TEPE properties with UPPAAL. The strength of the AVATAR-TEPE combination is that requirement capture, analysis, design, property description and verification tasks can seamlessly be accomplished in the same language, namely UML, and in the same environment [ASS09]. The designer is merely required to have minor UML skills and does not need to familiarize with formal languages like CTL or UPPAAL. As the objective is to verify sequential behaviors - and their timing -, the property descriptions could surely rely on state machines. However, overusing UML Statecharts both for modeling and property purposes is probably not a good idea. Indeed, if property description does not rely on a different formalism, it runs the risk of being hampered by the same errors in reasoning as the model.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Apart from Statecharts, formally defined descriptions for sequential behavior fall short in UML. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For example, scenario-based models like Sequence Diagrams fail to describe relations between attributes of various instances (e.g., attribute x of instance I0 is equal to attribute y of instance I1 ),}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
and they might be inadequate for describing complex situations, in particular to reference past events. Additionally, the integration of equations that have to be fulfilled as a function of the system behavior is not straightforward in UML and requires the usage of OCL, thereby circumventing the graphical notation.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A specification in TEPE represents functional and nonfunctional properties in a formal way, using Parametric Diagrams. As opposed to informal SysML PDs, TEPE PDs are amenable to automated verification. A small set of operators can be leveraged to make up complex properties.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In TEPE, }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
each property is expressed as a graph of Signals, Attributes, Constraints (Equations, Logical Constraints, Temporal Constraints) and Properties.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The AVATAR profile reuses eight of the SysML diagrams (Package diagrams are not supported). It further structures Sequence Diagrams using an Interaction Overview Diagram (a diagram supported by UML2, not by SysML). The AVATAR profile is syntactically and semantically defined by a meta-model. Besides a syntax, a semantics and a tool support, a profile is also characterized by a methodology.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For each property defined in a Parametric Diagram, a corresponding observer automata [FSsA08] is derived. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The latter makes states and transitions related to verification explicit in the UPPAAL model. In so doing, proving the satisfiability of a given TEPE property is reduced to searching for the accessibility or liveness of a given observer state, using the UPPAAL verifier. TTool is interfaced to verification tools that implement reachability analysis and model-checking. For example, to decide whether some UML action is reachable or not, it suffices to right click on the corresponding action\uc3 \u8217\'e2\'80\'99s symbol: The UPPAAL verifier is invoked with corresponding CTL formula, and the result is displayed on UML diagrams.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Diagrams can automatically be formally checked out only when they target the reachability or liveness of one specific state of an AVATAR State Machine. Otherwise, they must be translated by hand. Their full translation is under development.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
After having structured the system in terms of blocks, attributes and signals, the developer may proceed with the formal model of the properties to be verified (}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
see Figure 6),}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
corresponding to requirements (Req1 to Req4 ). \~\uc3 \u8592\'e2\'86\'90 the \u8220\'e2\'80\'9cblocks\u8221\'e2\'80\'9d are like classes; See figure 6, seems again blocks and signals, not exactly a scenario of sort...\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The case study demonstrates the applicability of TEPE language for the verification of system properties. While sharing the most important semantics with other temporal logics like CTL, TEPE enriches their expressiveness with the notion of physical time and an operator matching a set of unordered signals. The granularity and the abstraction level of diagrams is in line with the system model; }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
system transitions are referred to using signals and state variable modifications. }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
These elements are familiar to the designer as he/she introduced them during the design phase. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
By combining static equations and sequential operators, a temporal scope is attached to the former. \~\uc3 \u8592\'e2\'86\'90 this is really good, for future work, also meeting! (introduced during design: objects, methods,async calls, variable changes etc)\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A formal definition however opens the door for an automatic verification on the fly during simulation or by transformation into an UPPAAL model enhanced with observers. A}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
lthough nothing prevents from using the textual from of TEPE, the graphical representation based on Parametric Diagrams far outreaches the latter in terms of readability.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Moreover, an adequate coloring of operators facilitates the clear distinction between timed (signals) and untimed parts (properties) of the diagram. Properties are built up upon logical and temporal relations between block attributes and signals.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A graphical interval logic for specifying concurrent systems (1994!!) \uc3 \u8592\'e2\'86\'90 bullshit\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Experience has shown that most software engineers find standard temporal logics difficult to understand and use. The objective of this article is to enable software engineers to specify and reason about temporal properties of concurrent systems more easily by providing them with a logic that has an intuitive graphical representation and with tools that support its use. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The most critical real applications often involve concurrency, which increases the dificulty of system development and validation. Modern methods of structured programming, which are quite effective for sequential programs, are notoriously inadequate for concurrent ones. Moreover, the nondeterminism inherent in applications that involve concurrency and the reactive character of those applications makes them hard to test. Aggravating these problems is the need to explore large spaces of possible executions, which grow exponentially with the number of independent threads of control. \uc3 \u8592\'e2\'86\'90 for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In practice, however, system developers seldom make significant use of formal specification and verification methods. We believe that this is due, in large part, to the reliance of those methods on mathematical formalisms that are difficult to understand and to use. Formal speci cation and analysis methods must be made accessible to system designers and software engineers if they are to be used in the development of real world systems. Users must be able to express the properties of the systems about which they wish to reason as naturally as possible and to conform mechanically that the specifications, designs, testing criteria and sample executions have the required properties. Temporal logics 2, 19, 21, 32] are well-suited for specifying temporal properties of concurrent systems. Experience has shown, however, that specifications of even moderate-sized systems are too complex to be readily understood. This complexity stems chie y from the need to establish the temporal context within which properties, such as bounded liveness and invariance, must hold. Interval logics 11, 31] address this problem by defining temporal intervals to represent such contexts.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Stylized pictures often show complex timing relationships and dependencies more clearly than linear textual representations of the same information. Such diagrams correspond more closely to common conceptualizations than does linear text. Software engineers often draw timing diagrams, like those used to denote signal levels in hardware designs, when describing and reasoning about properties of systems. Even logicians who are fluent in temporal logic find timing diagrams helpful to explain the meanings of temporal logic formulas and to motivate lines of reasoning (see for example 6]). However, because timing diagrams often lack a formal semantics, they cannot be used for rigorous analysis of system properties. Pictorial documentation is all too often ad hoc and liable to ambiguous interpretation. \uc3 \u8592\'e2\'86\'90 for future work\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Graphical Interval Logic (GIL) has a formal model-theoretic semantics and is more expressive than propositional temporal logic with Until and without Next 27]. It thus provides an intuitive and natural visual notation in which to express system speci cations without sacri cing the bene ts of a formal notation. A visual editor allows GIL speci cations to be easily constructed and to be stored in and retrieved from les. The editor also provides a visual interface to a proof checker and model generator, which permit veri cation of temporal inferences. When reasoning about temporal properties exhibited by a concurrent system during a computation, it is convenient to regard the system as passing through a sequence of states. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
GIL specifications for a system describe properties of legal state sequences. \~\uc3 \u8592\'e2\'86\'90 so not events/actions but states?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A GIL formula is evaluated at a state in an infinite sequence of states. Infinite state sequences, therefore, provide the contexts within which formulas are evaluated. Intervals permit the speci cation of contexts within which properties hold. As suggested by the representation, every interval has an initial point (state). However, since contexts are infinite, we do not regard an interval as having a final point. The logic provides two search primitives for use in specifying intervals. Search to a target formula f , and Search to the right end of the context. Searches can be composed sequentially, with each successive search starting from the point, if any, located by the previous search. GIL provides a special syntax for expressing invariants and eventualities. To assert that a formula holds at every point in an interval, the formula is drawn indented directly below the interval. To assert that a formula holds at some point within an interval, the formula is drawn left justified directly below a diamond 3 drawn on the interval \uc3 \u8592\'e2\'86\'90bullshit\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A major advantage of using a visual logic, such as GIL, is that pictures (of the implications) representing the inferences used in the proof of a requirement can show the temporal ow of the argument. The graphical representation of the timeline allows one to align appropriate points in the picture. \~\uc3 \u8592\'e2\'86\'90 wtf proofs are graphical\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A general framework for formalizing UML with formal languages}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Safety-Liveness Semantics for UML 2.0 Sequence Diagrams (2005)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We provide an automata-theoretic solution to one of the main open questions about the UML standard, namely how to assign a formal semantics to a set of sequence diagrams without compromising refinement? Our solution relies on a rather obvious idea, but to our knowledge has not been used before in this context: that bad and good sequence diagrams in the UML standard should be regarded as safety and liveness properties, respectively. Proceeding in this manner, we obtain a semantics that essentially complements the set of behaviors associated with the set of sequence diagrams, thereby allowing us to use the standard notion of refinement as language inclusion. We show that refinement in this setting is compositional with respect to sequential composition, alternative composition, parallel composition, and star+ composition.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Various researchers have realized the importance of equipping SDs with a formal semantics, thereby providing SDs with a precise and unambiguous intention, and forming the basis for powerful analysis algorithms and tools. In spite of these successes, there is still no unanimous agreement on one of the main questions about SDs, namely how can one assign a formal meaning to a set of SDs without compromising refinement? The standard notion of refinement via simulation or language inclusion requires that each observable behavior of an implementation is also an observable behavior of the specification. An SD, however, may be composed with other SDs via sequential composition, alternative composition, parallel composition and star+ composition (looping), and a direct translation of SDs to automata (or partial orders) leads to implementations with a larger number of behaviors than their corresponding specifications.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Our semantic treatment of SDs proceeds roughly as follows: (i) Given a set of SDs, we translate each SD to a hierarchic automaton that may contain negative states. (ii) We separate the negative states from the positive ones by defining a construction that extracts a negative hierarchic automaton and a positive hierarchic automaton from the original hierarchic automaton. (iii) }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We construct a safety Buchi automaton from the negative hierarchic automaton and a liveness Buchi automaton from the positive one. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The safety and liveness automata ensure that a trace that may either lead to the completion of a bad scenario or prevent the completion of a good scenario is rejected. (iv) We take the product of these two automata as the operational semantics of the original set of SDs and the corresponding language as the denotational semantics. (v) We define refinement in terms of language inclusion; there is no need to consider finer (more behavioral) notions of refinement as our automata are input enabled. (vi) We show that refinement is compositional with respect to sequential composition, alternative composition, parallel composition and star+ composition. High-level sSDs are referred to as \uc3 \u8220\'e2\'80\'9cinteraction overview diagrams\u8221\'e2\'80\'9d in the UML 2.0 standard.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A basic SD focuses on the message interchange among a set of processes. Each process is represented by a life-line drawn as a (dashed) vertical line beneath a box containing the name of the process, and each message is represented by an arrow drawn from the sender to the receiver and decorated with a message identifier. \uc3 \u8592\'e2\'86\'90\uc1 }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
dafuq? It\uc3 \u8217\'e2\'80\'99s not a process!! it\u8217\'e2\'80\'99s an object!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A high-level SD is intended to serve as an overview of the flow of control among its constituent SDs, and is essentially a flowchart whose nodes are either initial, final or decision/merge points, or non-recursive references to basic or high-level SDs. To increase readability, high-level SDs may also contain fork and join points which allow one to compose SDs in parallel.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The main UML 2.0 interaction operators include sequencing, alternation,}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
option (representing a choice between the enclosed operand and an invisible empty operand \uc3 \u8592\'e2\'86\'90 exactly, for NFM rebuttal\uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
), parallel, looping, and }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
negative, which designates an invalid execution sequence.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Since most interaction operators, with the notable exception of negative, can be captured by high-level SDs, we assume for simplicity that basic SDs are flat (non-nested), but allow the negative operator (denoted neg) to be applied to SDs. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The formal semantics of SDs is traditionally given in terms of a process algebra }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
or partial orders. If, however, SDs are bounded (see Section 4.3), }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
one can equivalently use nondeterministic finite automata as a semantic framework}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. Such semantics are closed-world in the sense that given a set of SDs, no new SDs may be added to it without compromising refinement. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Definition 1 (NFA) A nondeterministic finite automaton (NFA) A = \uc2 \u931\'ce\'a3, S, \u948\'ce\'b4, S0 , F over an input alphabet \u931\'ce\'a3 is a 5-tuple such that:\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\ulnone\ulc0\animtext0\rtlch \ltrch
\uc3 \u8226\'e2\'80\'a2 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
\uc2 \u931\'ce\'a3 is the input alphabet. \uc3 \u8226\'e2\'80\'a2 S is a finite set of states. \u8226\'e2\'80\'a2 \uc2 \u948\'ce\'b4 \uc3 \u8838\'e2\'8a\'86 S \uc2 \u215\'c3\'97 \u931\'ce\'a3 \uc3 \u8746\'e2\'88\'aa \{ \} \uc2 \u215\'c3\'97 S is the transition relation.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\ulnone\ulc0\animtext0\rtlch \ltrch
\uc3 \u8226\'e2\'80\'a2 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
S0 \uc3 \u8838\'e2\'8a\'86 S is a set of initial states. \u8226\'e2\'80\'a2 F \u8838\'e2\'8a\'86 S is a set of accepting states.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
An input sequence \uc2 \u963\'cf\'83 = \u963\'cf\'831 . . .\u963\'cf\'83n is accepted by A if there is a state sequence s = s0 . . .sn such that s0 \uc3 \u8712\'e2\'88\'88S0 , sn \u8712\'e2\'88\'88F and for each i, the tuple (si , \uc2 \u963\'cf\'83i+1 , si+1 ) is in \u948\'ce\'b4. L(A), th\uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
e set of all accepted input sequences, is called the language of A (nondeterministic finate automaton A)}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. \uc3 \u8592\'e2\'86\'90 for future work and meeting \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The UML 2.0 semantics for SDs is based on an asynchronous interpretation of communication, where the sending and receiving of a message are considered to be distinct events. A natural way of capturing this semantics is to associate a partial order (PO) with each basic SD, where events are ordered from top to bottom along process lifelines and where the sending event at the tail of a message arrow is uniquely related to and precedes the receiving event at the head of the message arrow. Given the PO, one can obtain an NFA from it by applying the classical PO-to-NFA translation scheme of [7]: (1) The states of the automaton correspond to cuts, which are sets closed w.r.t. the partial order; the empty cut is the initial state and the cut with all events}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
is the accepting state. (2) If cut d equals cut c plus a single event e, then there is an edge from c to d labeled with l(e). The labeling function l is given with respect to an input alphabet \uc2 \u931\'ce\'a3, which is partitioned into sending tuples m:n!a and receiving tuples n:m?a. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
UML 2.0 SDs are intended to capture the behavior of reactive systems: those whose role is to maintain an ongoing interaction with their environment rather than produce some final value upon termination.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
NFAs are therefore not an appropriate formal model for reactive systems, since termination should be viewed as an error rather than a desirable outcome. A more suitable formal model for SDs are \uc2 \u969\'cf\'89-automata: automata over infinite words. In particular, Buchi automata are \u969\'cf\'89-automata requiring an accepting state to be visited infinitely often for every accepted input sequence. \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In the rest of this section, we show how to construct a B \uc2 \u776\'cc\'88 chi automaton for a given SD. \uc3 \u8592\'e2\'86\'90! \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A standard way of avoiding (premature) termination within a finite automaton is to allow the automaton to loop forever in each accepting state. To be more specific about the fact that processes may operate at different speeds, but not too specific, we add a \uc2 \u964\'cf\'84 self-loop to every state. Interaction fragments (and, thus, SDs) can be positive or negative, with the latter indicated by the interaction operator neg. Positive and negative SDs, however, are intended to capture orthogonal properties, namely liveness and safety. The negative NFA is obtained by turning all negative nodes into accepting sink nodes (without outgoing transitions), and all other nodes non-accepting. The positive NFA is obtained by removing all negative nodes and all their associated transitions. \uc3 \u8592\'e2\'86\'90 wtf?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
According to the UML 2.0 standard [24], a negative fragment describes traces that are invalid and should therefore never happen in an execution of the system. In other words, a negative fragment is intended to capture a safety property. An automaton is limit-closed if all its infinite behaviors are completely characterized by its finite behaviors. According to the UML 2.0 standard [24], the positive fragments describe traces that are valid and should be possible. As a consequence, each finite execution should be extendible to an execution where the positive trace eventually happens. In other words, the positive fragments are intended to capture liveness properties. We now present a transformation that leads to an automaton that is open to new behaviors, but rejects the ones preventing positive traces from happening, by infinitely stuttering in a non-accepting state}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Given a reduced Buchi automaton A representing the positive high-level NFA P , define Live(A) to be the Buchi automaton derived from A as follows: (i) Construct the automaton}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Uns(A)=\uc2 \u172\'c2\'acSafe(A). (ii) Take the union A \uc3 \u8746\'e2\'88\'aa Uns(A). \u8592\'e2\'86\'90 for future work, how you construct liveness automaton.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Given a reduced Buchi automaton B = \uc2 \u172\'c2\'acN , define Safe(B) to be the version of B in which every state has been transformed into an accepting state. \uc3 \u8592\'e2\'86\'90 for future work, how to construct safety automaton. \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Taking the product (conjunction) of the safety automaton of Figure 6(b) and the liveness automaton of Figure 7(b), one obtains the desired automaton for the SD of Figure 1(b). \uc3 \u8592\'e2\'86\'90 really??\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
An interesting trace-based approach is advocated in STAIRS [16], where SD behaviors are classified into positive, negative and inconclusive. While intuitively appealing, the formal treatment is essentially restricted to a closed-world view of the positive behaviors.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
More formally, given a set of UML SDs, for each SD in the set, we construct two B \uc2 \u776\'cc\'88 chi automata, one expressing safety and one expressing liveness, and take their product as the SD\uc3 \u8217\'e2\'80\'99s semantics. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Checking the validity of scenarios in UML models (2005) \uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
definitely important for future work, as it shows how to define monitoring processes for cases of negation/universal/existential scenarios}
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In the UML, sequence diagrams are used to state scenarios, i.e., examples of interactions between objects. As such, sequence diagrams are being developed in the early design phases where requirements on the system are being captured. Their intuitively appealing character and conceptual simplicity makes them an ideal tool for formulating simple properties on a system, even for non-experts. Besides guiding the development of a UML model, sequence diagrams can thus furthermore be used as a starting point for the verification of the UML model. \uc3 \u8592\'e2\'86\'90 for future work! \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this paper, we show how the requirements on the system as stated in sequence diagrams can be (semi-automatically) validated for UML models consisting of class diagrams, state machines and structure diagrams. The sequence diagrams that we consider can be universally or existentially quantified or negated, i.e., state scenarios that should always, sometimes or never occur. \uc3 \u8592\'e2\'86\'90 this is good, really good!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For validating them in a UML model, we translate both model and sequence diagrams into a formal specification language (the process algebra CSP), and develop procedures for employing the standard CSP model checker (FDR) for checking their validity.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The UML is a modelling language which supports modelling with different views. Its various diagram types allow for the description of different though not necessarily disjoint aspects of a system: Class diagrams model the static behaviour (data and operations), state machines the dynamic behaviour (protocols), structure diagrams the architectural composition and sequence diagrams typical application scenarios (plus possibly further diagrams for other aspects). Together they model the system to be built. Such a complex model composition immediately poses the question of consistency: is the architectural composition consistent with the interface description of the components, are static and dynamic behaviour non-contradictory, is the scenario as stated in the sequence diagrams actually allowed in the model, etc.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The starting point for our study are UML 1.5 sequence diagrams [24] which we extend with features for stating negation and universal and existential quantification (partially coming from UML 2.0 sequence diagrams1 ). \uc3 \u8592\'e2\'86\'90 nooooooo!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To achieve the necessary precision in the model (which is mandatory for a verification) we additionally use the Z notation [21, 13] for writing attributes and methods in class diagrams. The question is then whether the sequence diagrams are consistent with the UML model in that the restrictions on the overall behaviour (as laid down in the diagrams) do not prevent desired or allow forbidden scenarios. We develop a technique which allows to automatically check for this kind of consistency. To this end, we translate both sequence diagrams and the rest of the UML model into a formal specification language. The translation of class diagrams, state machines and structure diagrams follows a technique proposed in [16], the translation of the sequence diagrams is inspired by [10] and given in this paper. \uc3 \u8592\'e2\'86\'90 checkout paper [10] == \u8220\'e2\'80\'9cAn algebraic semantics for message sequence chart documents.\u8221\'e2\'80\'9d 1998?!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
You need license for this FDR shit, plus last update 2010! CSP algebra }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
from website \uc3 \u8220\'e2\'80\'9cDatatypes may not be parameterised (T may not have arguments). The datatype corresponds to the variant-record construct of languages like Pascal. At the simplest level it can be used to define a number of atomic constants\u8221\'e2\'80\'9d \u8592\'e2\'86\'90 tja..\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For the modelling we use a UML profile for reactive systems as being built out of processes (active objects) working concurrently and communicating with each other. \~The reactive system itself is modelled by a structure diagram. Structure diagrams describe the architecture of systems, i.e., their components and their interconnection. A capsule in a structure diagram is drawn as a rectangle with ports (white or black ) indicating their protocols. Two ports (and thus two capsules) can be connected if they refer to the same protocol. A port residing on the border of the outermost capsule (capsule System) describes the interface of the system towards its environment. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For this purpose the specification formalism Z [21, 13] is employed. If such a specification is supplied for all methods and attributes a precise and unambigious meaning can be given to the UML model. This is the prerequisite for formally checking the validity of scenarios. For our example, we only show the signatures of methods in interface since we will refer to them when translating sequence diagrams. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We always assume to have one class (here called User ) which models the environment of our system. The interface of this class can be determined from the structure diagram: all protocols of ports residing on the borders of the outermost capsule System are also protocols of the environment class (complementing methods and channels, inputs and outputs). The behaviour of the environment remains unspecified, thus we assume it to behave chaotically (all behaviour allowed). \uc3 \u8592\'e2\'86\'90 for ppt?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Here, we use a very simple form of sequence diagrams since our main focus is not on giving a semantics but on checking their validity (for semantics for message sequence charts, the precursors of sequence diagrams, see for instance [10, 14, 15]; for a semantics for UML 2.0 interactions diagrams see [22]). For the banking system we might for instance like to specify that a user never gets money when the ATMs question for enough credit is answered with \uc3 \u8221\'e2\'80\'9dno\u8221\'e2\'80\'9d\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Given a UML model of a system and a number of sequence diagrams specifying allowed or forbidden scenarios we are interested in knowing whether these scenarios are actually possible (or not possible) in the model. We refer to this as the validity of the scenario in the model. Checking the validity of scenarios should at the best be fully automatic; here we propose a technique which is partially automatic. \~\uc3 \u8592\'e2\'86\'90 this is what it\u8217\'e2\'80\'99s all about \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A translation of models in our specific UML profile to CSP can be found in [16]. Roughly, the translation proceeds as follows: The class diagram together with the Z formalisation of interfaces, attributes and methods is translated to Object-Z [20]. The Object-Z classes of capsules are then augmented with CSP process descriptions which are derived from the state machines. A specific CSP process is computed for the outermost capsule System. This process describes the architecture of the system and consists of the parallel composition of the capsules in the system. Together, these}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
classes form a CSP-OZ [8] specification. CSP-OZ is a combination of Object-Z and CSP and has a semantics in terms of the semantic model of CSP. Thus we hereby end with a CSP semantics for our UML model. \~}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In the next step we equip the sequence diagrams with a CSP semantics as well. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
As a language for formalising the diagrams we again employ Z. As we have already explained, all channels must have two special parameters which are used for adressing the partners in a communication. CSP processes are built over events. An event consists of a channel name together with values for parameters, e.g. answer .b.a1.true is an event consisting of the name answer plus values b (for parameter from), a1 (for to) and true (for ok ). The notation? denotes that any value can be accepted for a parameter. A partial event is one in which some of the values for parameters are missing, e.g. answer .b.a1 is only a partial event. \~\uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
partial events with any-value-for-parameter, useful for future work! meeting also!}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In sequence diagrams events will appear as labels of arrows between objects. Whenever values for parameters are left out (which is most often the case) we assume the value to be ?_}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To distinguish two arrows with the same label connecting the same lines we attach a unique identifier to each arrow. The values for parameters to and from of an event attached to an arrow have to agree with the objects connected by the arrow.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Additionally, every sequence diagram is equipped with an occurrence condition stating whether the specified scenario should never/sometimes or always happen.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Condition ::= negative | existential | universal}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Here we employ alphabetised parallel composition: for every process in a parallel composition its alphabet of events is given, and synchronisation has to take place on events in the intersection of alphabets. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The translation proceeds in two steps. The CSP process of the sequence diagram is the parallel composition of the CSP processes belonging to every lifeline of an object. These processes synchronise on shared events. Due to the parameters to and from in events, an event belongs to the alphabet of exactly two objects (and thus to exactly two CSP processes). }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
\uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
process per lifeline. Also:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The CSP processes of the lifelines are simply the sequential composition of the events on their arrows. Having defined the CSP semantics of simple sequence diagrams and UML models, it is now possible to check the validity of the scenario in the UML model. \uc3 \u8592\'e2\'86\'90 but it\u8217\'e2\'80\'99s not in temporal logic, strange, how can it be checked as a property then? see below..(it\u8217\'e2\'80\'99s a tester/monitoring process run in parallel with the system)\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For the simple sequence diagrams defined in this paper, there are of course only finite runs; \~\uc3 \u8592\'e2\'86\'90 can this be a problem in future work? How do I define infinite runs with SDs?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
below: \~\uc3 \u8220\'e2\'80\'9cTo establish these occurrence conditions, it is sufficient to verify the following assertions\u8221\'e2\'80\'9d \u8230\'e2\'80\'a6 [formulas]\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Since this is neither a refinement check in one of CSP\uc3 \u8217\'e2\'80\'99s semantic models nor a check for deadlock- or divergence-freedom, \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
we cannot directly use FDR but first have to reformulate the problem in a way tractable by FDR. The general idea is to use an auxiliary process (\uc3 \u8216\'e2\'80\'98tester\u8217\'e2\'80\'99), which performs pattern matching for the sequence s on the stream of events it is offered. This process is then put in parallel to the process P for the system to be analysed, synchronizing on the whole alphabet of the system. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\i0\ul\ulc0\b0\rtlch \ltrch\loch\fs22\loch\f5
So, for negative and existential conditions (assertions) in SDs:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In order to perform this check for some specific sequence of events s, a process S_match is constructed from s, which always accepts all events in E until it has performed s; in that case it performs an event match \uc3 \u8712\'e2\'88\'88 E and stops (deadlocks)\uc1 }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Next we put P and S_match in parallel, synchronising on the whole alphabet E of P and hide all of E , since we are only interested in the occurrence of match. \uc3 \u8592\'e2\'86\'90 for ppt! \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Thus, for checking validity of sequence diagrams with negative conditions we use FDR to check (\uc3 \u8727\'e2\'88\'97), if this fails the sequence diagram is valid in the UML model; for sequence diagrams with existential conditions we use (\u8727\'e2\'88\'97) as well and validity holds if the test is successful.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\i0\ul\ulc0\b0\rtlch \ltrch\loch\fs22\loch\f5
Universal assertion:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This task is a little more complicated, because of the universal quantification. We cannot use the simple traces model here, but need to take deadlock and divergence into account: if s is to occur on all runs of P , then P must neither be able to deadlock nor to diverge until it has performed s. Furthermore, each (non diverging) infinite run of P has to contain s. Therefore we split this task into two checks. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For the first one a process Sdiv is constructed from s, which differs from Smatch only in the definition Ss = div}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
that is, it diverges immediately after performing s instead of performing an additional event and stopping. The second test requires an auxiliary process Snot , which always accepts any event in E , except when it has already performed all but the last event of s, in which case Snot refuses exactly that event, but no other. Summarising, we have:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\ulnone\ulc0\animtext0\rtlch \ltrch
\uc3 \u8211\'e2\'80\'93 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
P cannot deadlock until it has performed s and}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\ulnone\ulc0\animtext0\rtlch \ltrch
\uc3 \u8211\'e2\'80\'93 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
P cannot diverge until it has performed s and}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\ulnone\ulc0\animtext0\rtlch \ltrch
\uc3 \u8211\'e2\'80\'93 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
P has no infinite trace (non-diverging) which does not contain s,}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
i.e., any finite or (non-diverging) infinite run of P contains s}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Validity of sequence diagrams with universal condition can hence be checked using the above two tests. Besides single words the language of a sequence diagram can also contain more than one word. This is the case if the sequence diagram specifies certain interactions to be concurrent. The corresponding CSP process will then contain all possible interleavings in its set of runs. The simplest, yet slightly inefficient way to perform the necessary tests for a set L, is to construct the respective processes for all the s \uc3 \u8712\'e2\'88\'88 L and to use them all at once, i.e., to put them in parallel, synchronising on E . Using labelled trasition systems, [4] defines behavioural consistency for combinations of UML behavioural diagrams (including statecharts and sequence diagrams) as deadlock freedom. They use the SPIN model checker for analysis, \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
but do not give a formal translation from UML to SPIN\uc3 \u8217\'e2\'80\'99s input language. \u8592\'e2\'86\'90 for ppt: I will not give a formal translation, just to make it clear. This needs to be done, probably things need to be polished as well. \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The work most closest to us is that carried out in the context of life sequence charts (LSCs) [6]. LSCs are an extension of sequence diagrams with special features for modelling liveness requirements. The work [3] proposes validity checking for LSCs}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
by translating them to the temporal logic LTL and checking them against Statemate models. Based on LSCs, the play in play out approach [11] uses a collection of \uc3 \u8216\'e2\'80\'98played in\u8217\'e2\'80\'99 examples to specify a whole system, instead of using them only as requirements for an explicit model.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A Pattern-Based Approach to Formal Specification Construction (2011, see related work why previous approaches are not good?) \uc3 \u8592\'e2\'86\'90 lousy paper in fact\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Difficulty in the construction of formal specifications is one of the great gulfs that separate formal methods from industry. Though more and more practitioners become interested in formal methods as a potential technique for software quality assurance, they have also found it hard to express ideas properly in formal notations. This paper proposes a pattern-based approach to tackling this problem where a set of patterns are defined in advance. Each pattern provides an expression in informal notation to describe a type of functions and the method to transform the informal expression into a formal expression, which enables the development of a supporting tool to automatically guide one to gradually formalize the specification. \~In this paper, we put forward a pattern-based approach to dealing with this challenge. It adopts the three-step approach in SOFL (Structured Object-oriented Formal Language) [3], which builds specification through informal, semiformal and formal stages. Based on a set of inter-related patterns, guidance will be generated for specifying functions in terms of pre- and post-conditions step by step from semi-formal to formal stage, which enables developers to work only on the semantic level without struggling with complicated formal notations. These patterns are pre-defined, each providing an informal expression to describe certain function and the formalization method of such expression. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Although researchers proposed many patterns to help handle commonly occurred problems on specification constructions, such as the well-known design patterns [4], developers have to understand the provided solutions before they can apply}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
them to specific problems. By contrast, our patterns are hidden from developers; it is the understandable guidance that interacts with developers, which is produced based on patterns in our approach.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Such process is not expected to be fully automatic due to the need for human decisions, but it is expected to help the developer clarify ambiguities in the informal expression and select appropriate formal expressions. \~Konrad et al. [10] created real-time specification patterns in terms of three commonly used real-time temporal logics based on an analysis of timing-based requirements of several industrial embedded system applications and offered a structured English grammar to facilitate the understanding of the meaning of a specification. This work is complementary to the notable Dwyer et al.\uc3 \u8217\'e2\'80\'99s patterns here it is: \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In spite of enthusiasm in academics, specification patterns are not yet widely utilized in industry mainly because of the difficulties in applying them. As can be seen from the related work, the patterns they established force their users to make a full understanding of them before selecting and applying appropriate ones. Statistical data shows that large amount of patterns have been developed, whereas users may not fully understand how to leverage them in practice Our approach treats patterns as knowledge that can be automatically analyzed}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
by machines to generate comprehensible guidance for users. Thus, developers need neither to be educated on the patterns nor to be trapped in tedious and sophisticated formal notations; they can only focus on function design and make critical decisions on the semantic level. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To avoid potential errors in specifications, each designated value v is required to be legal, which means v is a combination of constants and variables that can be found in the data definition part of the specification. After all the elements are legally specified, a concrete constituents is obtained where each element is bounded with a concrete value. If the user is not familiar with the pattern notation, he will only be required to provide a general intention first by selecting patterns. This task is easy because: (1) pattern names are written in natural language and allows the selection to be easily done on semantic level, (2) the unique meaning of each pattern name differentiates itself from others and therefore avoids wrong selection, (3) the}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
explanation items can help confirm the decision. Once the semi-formal elements of p have been specified, a corresponding informal expression is generated automatically on the basis of the syntax item of p and added to the corresponding pre- or post-condition. Advanced users can choose to directly write expressions in pattern notation for pre- and post-conditions. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
according to the formalization result it maps to, alter( \uc2 \u771\'cc\'83account store) is formalized into:\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
let x inset \~\uc2 \u771\'cc\'83obj and x.accountN o = inf\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
in union(dif f ( \uc2 \u771\'cc\'83obj, \{x\}), alter(x, f alse, N ull, N ull, originBased(alter)))\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
nonsense paper}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Integrating UML and Formal Methods}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
UML is a widespread language used in both industry and academia, despite the fact that its semantics is still informal and allows ambiguities. On the other hand, OhCircus is a formal specification language which unifies Z, CSP, the refinement calculus of Morgan and object-oriented theories. In this work we integrate UML class diagrams and OhCircus by written UML elements in terms of OhCircus constructs. However, instead of a simply syntactical mapping, we also propose the concept of a class model to capture associations and global constraints. Finally, we use this integration to prove the refinement of associations as attributes, a result that relates analysis to design to implementation and which is very common in industry. As informal notation, UML [18,20] deserves special attention. UML has become a de facto standard; nevertheless it can also express ambiguities and is insufficient to represent even simpler properties, as pointed out in [19].}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
OhCircus [4] was chosen as our formal language because it has an intuitive representation of constructions like classes and inheritance and is based on a refinement theory. Furthermore, OhCircus is a language which integrates well-established concepts on the formal community: the model-based language Z, the process algebra CSP [22], the refinement calculus, and object-orientation, providing an unified language of classes and processes.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Our goal in this work is the translation of UML class diagrams elements into OhCircus constructs. \~\uc3 \u8592\'e2\'86\'90 oh darn, only static structure\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Class diagrams are the most common diagrams used in software development projects. They model concepts from the domain of the application and the structural aspects of the system using classifiers and relationships as their building blocks. They are also named static view, representing information that never changes.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In particular, the attempts of integration between Z and process algebras (CSP-Z, CSP-OZ [8]) consider state and communicating aspects of concurrent systems in an unified language, taking advantage of the existing theories and tools. A similar formalism is Circus [31], which proposes a refinement calculus to that integration. Moreover, it is familiar to those who knows Z and CSP and enables the reuse of existing and well-established tools, like FDR [10] and Z/EVES [24]. OhCircus is an extension of Circus which adds classes, inheritance, dynamic binding and other features from the object-oriented paradigm.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
[...static parts transformation bullshit...]}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A direct consequence of the mapping we have proposed is the ability to explore UML refinement in formal ways: refinement of UML models can be assured by data refinement in OhCircus. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
bullshit the rest really..}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Specification and Formal Verification Of Temporal Properties of Production Automation Systems (2004)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We focus on the graphical MFERT notation and RT-OCL (Real-Time Object Constraint Language) for the specification of state-oriented real-time properties. RT-OCL is an extension of the Object Constraint Language (OCL) that is part of the Unified Modeling Language (UML). We introduce the formal semantics of RT-OCL based on a formal model of UML Class and State Diagrams and provide a mapping to temporal logics. The applicability of our approach is demonstrated by the case study of a manufacturing system with automated guided vehicles.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
However, due to the complexity of those systems, simulation can never provide coverage for complete verification for those systems. \~The model checker returns either \uc3 \u8216\'e2\'80\'98true\u8217\'e2\'80\'99 or generates a counter example in cases when the model does not satisfy the property. The counter example demonstrates an execution of the model that leads to a situation which falsifies the property. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The most remarkable advantage of model checking is that the task of verifying is fully automated. However, model checking has two main obstacles in practical application. The first one is the state explosion problem in dependence to the number of possible inputs. The second one is due to the specification of properties in temporal logics, since it often turns out that designers and programmers are not familiar with formal methods and regard it as a task too cumbersome to specify and understand properties in temporal logics. For production automation systems, the correct time-critical behavior of required properties is of particular interest. This is already important in early phases of development to avoid expensive and time-consuming changes to the system under development at later stages. Though classical model checking is mainly for the verification of cycle-accurate behavior without timing properties, there are a few tools like the RAVEN model checker [36] that support the formal verification of time-annotated system models and additionally provide basic timing analysis.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The main idea was that in a first step the designer specifies a model in a graphical specification language, namely MFERT. The model, i.e., the MFERT description, is then translated into an annotated state machine-based formalism (i.e., I/O-Interval Structures [38]) for model checking. Additionally, properties are specified and translated into temporal logics (i.e., Clocked Computation Tree Logic, CCTL [37]) for formal verification with the RAVEN model checker}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
OCL was introduced as a language for the specification of constraints in the context of the Unified Modeling Language (UML) de-facto standard [29], focusing on Class Diagrams and on guards in behavioral diagrams. The syntax of OCL comes in a \uc3 \u8216\'e2\'80\'98programmer-friendly\u8217\'e2\'80\'99 style using dot-notation and operation calls as known from object-oriented languages. With the wide acceptance of UML, OCL has also received a considerable visibility. However, OCL currently lacks sufficient means to specify constraints over the temporal behavior, i.e., the evolution of state activations and state transitions as well as timing constraints. Since it is essential to be able to specify such timing constraints for time-dependent systems to guarantee correct system behavior, we developed an OCL extension, i.e., RT-OCL, that overcomes this limitation and at the same time keeps compliant with the syntax and semantics of the latest version of OCL, i.e., Version 2.0. To seamlessly integrate RT-OCL with the domain-specific language MFERT, we defined UML Profiles for both MFERT and RT-OCL and defined mappings to the formal means of I/O-Interval Structures and CCTL, respectively. CCTL was introduced by Ruf and Kropf in [37] for the specification of properties over I/O Interval Structures. CCTL formulae are composed from propositions denoting predicates in combination with Boolean connectives and time-annotated temporal operators. The temporal CCTL operators build upon the common CTL operators and are annotated by timing intervals, such as AF[a,b]. \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Several approaches to support property specification have been developed. In the following subsections, we distinguish the areas of (a) pattern-based specification, (b) graphical property languages, and (c) temporal extensions of OCL. \uc3 \u8592\'e2\'86\'90 for future work and meeting! Basicalyl these are the different types of support for property specification. Except for (c) \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To support temporal logic property specification, some approaches identify patterns which provide the user with structured application of formulae. First attempts in pattern classification led to taxonomies that coarsely distinguish between safety and liveness properties. A detailed pattern-based classification is published by Dwyer et al. in [14]. That pattern system is based on the investigation of more than 500 examples for property specification and presents a semantically ordered hierarchy of property patterns. For instance, absence, eventual existence, and global existence of states/events are combined as so-called occurrence patterns.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The idea of patterns was adopted not just to classify but also to construct specifications for finite state verification. In a more general approach of natural language oriented specification, the PROSPER project aims at the specification through an English language subset In the early phases of the GRASP project, we developed an interactive visual framework that employs structured English sentences [23] as given in Figure 2. Compared to other pattern-based approaches, we provide a richer set of specifications, in particular, as we additionally cover explicit timing annotations.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In contrast to temporal logic formulae-based approaches, non-experts can more easily capture the final sentence in structured English than just by CTL or LTL. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
However, it turned out that this approach leads to quite long sentences and remains too cumbersome for more complex applications, so that we started to investigate alternative approaches.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Regarding property specification by visual means we can distinguish two different kinds of approaches. The first ones are still syntactically based on CTL or LTL specifications. Those frameworks provide support to visually compose segments of specifications, e.g., by enabling and disabling parts of specifications during the development process. To create specifications with this approach, the user must know how to apply and to control temporal logic formulae. Other approaches have an abstract graphical notation, which is translated to temporal logic formulae before checking. Examples are Symbolic Timing Diagrams (STDs) [15] and Life Sequence Charts (LSCs). Ramakrishnan et al. [30] extend the OCL syntax by additional grammar srules with unary and binary future-oriented temporal operators (e.g., always and never) to specify safety and liveness properties.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Distefano et al. [13] define Object-Based Temporal Logic (BOTL) to facilitate the specification of static and dynamic properties. BOTL is not directly an extension of OCL. It rather maps a subset of OCL into object-oriented CTL. Bradfield et al. [2] extend OCL by useful causality-based templates for dynamic constraints. A template consists of two clauses, i.e., the cause and the consequence. The cause clause starts with the keyword after followed by a Boolean expression, while the consequence is an OCL expression prefaced by eventually, immediately, infinitely, etc. The templates are formally defined by a mapping to observational \uc2 \u956\'ce\'bc-calculus, a two-level temporal logic with OCL on the lower level.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
An MFERT model is based on production elements and production processes. Production elements represent objects whose properties are changed by processes and transformations. Properties of production elements are described by attributes. A production element obtains its own identity, composed out of the description and the element\uc3 \u8217\'e2\'80\'99s correlative status. In that context, recall that the model checker RAVEN is able to verify whether a model (a set of I/O-Interval Structures) satisfies a given property (a CCTL formula)\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The Object Constraint Language is an integral part of UML [29, Chapter 6]. OCL constraints are defined over a given UML model to restrict the values of object properties. OCL is mainly applied to define invariants for classes and pre- and postcondition of operations. As OCL is a declarative expression-based language, evaluation of OCL expressions does not have side effects on the corresponding UML model. \uc3 \u8592\'e2\'86\'90 for future work?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Standard OCL currently lacks means to specify constraints over the dynamic behavior of a UML model. Constraints covering the consecutiveness of states and state transitions as well as time-bounded constraints cannot be defined. \~\uc3 \u8592\'e2\'86\'90 for future work? \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
More recently, in reply to the OMG\uc3 \u8217\'e2\'80\'99s OCL 2.0 Request for Proposals, the extensive OCL 2.0 language proposal by Ivner et al. [25] became available, which addresses a seamless integration of OCL to relevant parts of UML. In October 2003, this proposal has been adopted by the OMG as the official OCL 2.0 Specification [28]. Based on the metamodel provided in these documents, we developed a more lightweight approach by defining a UML Profile for our temporal OCL extension [22].\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
While the syntactic integration of the temporal OCL extension is straightforward, the definition of the semantics needs more investigation. The OCL 2.0 specification provides extensive semantic descriptions by both a metamodel-based as well as a formal mathematical approach, but unfortunately, those are currently neither consistent nor complete [18]. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
However, this information is not sufficient to evaluate OCL expressions, as system states do not comprise currently activated states and messages that have been sent. We therefore have to extend the formal model and system states accordingly, such that the resulting extended object model M. The final formal semantics for our temporal OCL expressions is given in [22, 17]. While those articles also provide a general mapping to CCTL formulae, we here give some typical specification examples in the next section.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Further examples of time-bounded state-oriented OCL constraints in the context of other UML and MFERT models can be found in [20, 4, 17]. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In [21], we additionally demonstrated that it is possible to express the property specification patterns of Dwyer et al}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. [14]}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The approach demonstrates that an OCL extension by means of a UML Profile towards temporal real-time constraints can be seamlessly applied on the M2 layer of UML, i.e., the OCL metamodel. Nevertheless, some extensions have to be made also on the user model level (i.e., M1 layer) in order to enable modelers to use our temporal OCL extensions. The presented extensions are based on a future-oriented temporal logic.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A Formal Semantic for Scenario - Based Model Using Algebraic Semantics Framework for MOF (January 2013!) \uc3 \u8592\'e2\'86\'90 WTF is this work!?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
However, these concepts, especially within MOF standard, are not yet formally define which will be difficult to check the consistency between metamodel and models. Therefore, defining a formal semantic for MOF-based metamodel is essential for discovering the meaning of the model and to ensure a structural and behavioral conformance between metamodel and its model. In this paper, we define a formal semantic for a scenario-based model called Performability Failure Behavior Awareness Metamodel (PerFAM) by applying algebraic semantics for MOF framework which provides a formal stage: metamodel, model and model conformance. For this purpose, a formal consistency checking can be applied as to ensure the accuracy of the produced model towards its metamodel. \uc3 \u8592\'e2\'86\'90 bad english\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
However, the MOF framework does not provide a standard notion for formally defining the metamodel semantics in a systematic way However, when the metamodel is not formally defined in the syntax and semantic definition, problems such as misinterpretation of models among developers cannot be avoided [4]. This problem could cause some metamodel derivation problems when interpreting from a metamodel to its model. Therefore, it is important to have a formal semantic for metamodel and models so as to ensure the consistency for models production from its metamodel and the correctness of system design. The PerFAM model [5] is an intermediate model, between the UML sequence diagram and analysis model (DTMC, Petri Nets, etc.). This model provides a modeling view for performance and reliability aspects, particularly for outlining failure behavior of timing requirements. The idea is underlying in model-driven development where the UML sequence diagram with performance annotation from MARTE profile is then transformed into a PerFAM model for performance and reliability viewing models. The PerFAM model is then transformed into analysis model for in depth analysis. Figure 1 shows the PerFAM metamodel and its model in Figure 2.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A formal semantic for both PerFAM metamodel and model is needed to ensure that the consistency of model inheritance conforms to its metamodel. The formal semantic can also provide the accuracy of the model and provide for the development of a tool support. MOF is a semiformal approach to define a modeling language. Generally, this framework consists of three levels of notions, namely, metamodel, model and model conformance. The metamodel is usually described as a data or theory. However, at present, the MOF based metamodel lack of mathematical representations as to provide the accuracy of the metamodel towards its model. Therefore, this framework provides two additional notions of metamodels called metamodel realization and model type. A metamodel realization enables a precise mathematical representation for metamodel using MEL theory to describe its model types. The formal semantics for the PerFAM metamodel are defined within the context of its metamodel elements, action, data types, attributes and associations. Thus, from this metamodel, we can define the formal semantics for its correspondence model contributing to concrete syntax, system and configuration state.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
[...afterwards the rest is \uc3 \u8220\'e2\'80\'9cwhat the fucking fuck\u8221\'e2\'80\'9d...]\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The main contribution of the paper is a systematic approach for defining the PerFAM formal semantics by partitioning the PerFAM metamodel, the PerFAM model and its model conformance. In this respect, we use the algebraic semantics for MOF framework to define a formal semantic for PerFAM where this framework is established within three semantic notions, namely, metamodel, model and model conformance. In order to ensure the consistency of model generation from its corresponding metamodel, a model conformance is defined as checking the consistency of its syntax and semantic. The main advantages of our contributions are the formal semantics that we proposed which can be used to check the correctness of the developed model, as well as its model conformance. In particular, these formal semantics open up a wide opportunity for model-driven development in terms of tools support for model development. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
No tool support yet, planned in future work (systematically check the consistency between a PerFAM metamodel and models during the system design process.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Semantics of UML models for dynamic behavior: a survey of different approaches}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
I should pick one in which my approach fits? When choosing a modeling language and accompanying semantics, a number of things need to be taken into consideration, such as who are the users of the models, what is the purpose of the models, what kind of application is being modeled, and what are the essential features that must be captured When modeling embedded systems, an essential aspect is the interaction between hardware and software. Hence, we need to capture the behavior of the hardware and software components. For capturing the dynamic behavior of components, modeling languages like UML sequence diagrams, state machines and similar notations are often used. This paper surveys different approaches to formally capturing the semantics of models expressed using languages of this kind. Some models are intended to be processed automatically, for example by code generators or model checkers, while other models are used as an aid in communication between for example system developers and client representatives. The semantics given for the languages range from natural language explanations of modeling language constructs and examples to highly formal mathematical or logical definitions.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Another question is: What is the purpose of the models? If the models are to be used for giving formal proofs of system properties, then the language must be supported by a formal semantics defined in clear mathematical or logical terms. If the models will be used for code generation or automatic model checking then we need to ensure that the semantics can also be processed by a computer. On the other hand, if the models are intended for communicating with client representatives then a natural language explanation of the language features may be appropriate.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A third question is: What kind of system is being modeled, and what are the essential features or properties that need to be captured by the models? For example, capturing real-time requirements may be essential when modeling an emergency communication network, but of little importance when designing a chocolate automaton. \uc3 \u8592\'e2\'86\'90 for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For capturing dynamic component behavior, modeling languages like UML [1] sequence diagrams and state machines are currently the most highly profiled. \uc3 \u8592\'e2\'86\'90 for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This paper surveys approaches to giving formal semantics to models expressed in UML sequence diagrams, state machines or similar notations, such as MSC [2], LSC [3], the Statecharts language [4], SDL [5], etc. An overview is given of different types of semantics and their strong and weak points. The survey is not exhaustive, but covers the most common variants. The survey does not address semantics for hybrid models which is a field in its own}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A model is a description of a system in some modeling language, such as the UML. The semantics of a model explains what the model means. More exactly, the semantics of a model is a function mapping the syntactically well-formed models of the modeling language into syntactically well-formed expressions in a language that is well understood. What is a well-understood language depends on the intended users of the semantics. It often makes sense to define several equivalent semantics for the same modeling language; for example, an axiomatic semantics for logical deduction, a denotational semantics for mathematical reasoning, an operational semantics for building tools, and a natural language semantics to explain the language to its end-users. \uc3 \u8592\'e2\'86\'90 for ppt! ZAPAMTI!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Finally, there is the issue of the kinds of features or properties that can be captured by the modeling language. Properties can be categorized according to the basis on which they are falsified: Properties that can be falsified on the basis of a single trace are called trace properties, while properties that are falsified on the basis of a set of traces are called trace-set properties [8].4 Examples of trace properties are safety and liveness [9, 10], while permissions often used in relation to policies and many information flow properties are examples of trace set properties. Most modeling languages are well-suited to capture trace properties, but only some allow us to specify trace-set properties as something distinguishable from underspecification. Distinguishing trace-set properties from underspecification is necessary since trace-set properties should be preserved}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
under refinement while this is not the case for underspecification. \uc3 \u8592\'e2\'86\'90 for future work!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Hence, a formal semantics is needed for the development process. There are, however, different styles of formalizing semantics, each with their strong and weak points. For the graphical modeling languages we are concerned with in this paper, denotational and operational semantics are the most relevant styles. The }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
denotational}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
semantics}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
method maps a program directly to its meaning, called its denotation. The denotation is usually a mathematical value, such as a number or function. No interpreters are used; a valuation function maps a program directly to its meaning. The basic idea is to give a denotation to every element of the language. This means to map the syntactical expressions of the language to a well-known domain. Denotational semantics typically allows a fairly abstract system description. As they also build on known domains, they are well suited for mathematical reasoning and formal proof of properties. On the negative side, a denotational semantics provides little guidance for tool developers and will typically be too complex for users. Expressing states and operations is usually difficult with a denotational semantics. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The operational semantics method uses an interpreter to define a language. The meaning of a program in the language is the evaluation history that the interpreter produces when it interprets the program. The evaluation history is a sequence of internal configurations. As a methodology for language development he suggests that \uc3 \u8220\'e2\'80\'9ca denotational semantics is defined to give the meaning of the language\u8221\'e2\'80\'9d and that \u8220\'e2\'80\'9cthe denotational definition is implemented using an operational definition\u8221\'e2\'80\'9d.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
An operational semantics of a programming language is one that defines not the observable overall effect of a program but rather suggests a complete set of possible individual steps which may be taken in its execution. The observable effect can then be obtained by embedding the steps into an iterative loop.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Major advantages of operational semantics is that such semantics provides good formalization of implementation and is well suited for building tools. It is also typically well suited for state-based languages. On the other hand, operational semantics tends to be very detailed, and it is often difficult to derive formal proof from operational semantics. Besides, an operational semantics relies on the underlying semantics of the abstract computer on which the interpreter is assumed to run}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In 1996, a new MSC standard was defined, called MSC-96 [20]. In this standard, high-level constructs and high-level MSCs were introduced, a kind of diagrams that show how control flows between basic MSCs. Further an event-centric textual syntax7 and a new semantics were defined [21]. This semantics is also a kind of process algebra, but holds substantial differences from the MSC-92 semantics. Finally, the MSC-96 standard was revised in 1999 and became MSC-2000 [2], but kept the MSC-96 semantics.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The UML standard defines the semantics of sequence diagrams informally. Most notably, this is a trace-based semantics: Basic trace model: The semantics of an Interaction8 is given by a pair [P, I] where P is the set of valid traces and I is the set of invalid traces. P \uc3 \u8746\'e2\'88\'aa I need not be the whole universe of traces.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A trace is a sequence of event occurrences denoted \{e1, e2, ..., en\}}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In the following we present briefly different denotational (like trace semantics?) and operational semantics of sequence diagrams and similar notations. The STAIRS semantics [28, 29] is a trace based formalization of sequence diagrams based on an extension of the semantic model of the UML standard, and hence distinguishes between positive, negative and inconclusive traces. But instead of a single pair (p, n) of positive and negative traces the semantic model of STAIRS is a set of pairs \{(p1 , n1 ), . . . , (pm , nm )\}. Such a pair of sets of traces (pi , ni ) is referred to as an interaction obligation. The word \uc3 \u8220\'e2\'80\'9cobligation\u8221\'e2\'80\'9d is used in order to emphasize that an implementation of a specification is required to fulfill every pair captured by the specification. This semantic model makes it possible to define trace-set properties. Refinement is defined as refinement of each interaction obligation, and refinement of interaction obligations is defined as reducing the set of positive traces by making them negative and reducing the set of inconclusive traces by making them positive or negative. In [27], Kruger defines a variant of Message Sequence Charts that is supported by formal definitions of the semantics, as well as refinement relations. The semantics is defined in terms of streams, which consist of a sequence of system channel valuations and a sequence of state valuations. A system is represented semantically by a set of streams, and the existence of more than one stream indicates nondeterminism.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Storrle [30, 31, 32] defines a denotational trace based semantics for UML 2.x sequence diagrams that is quite similar to the STAIRS semantics. Among the notable differences are that St \uc2 \u776\'cc\'88rrle does not treat choices as underspecification. Further, S \u776\'cc\'88rrle gives a different treatment of negative behavior where sequence diagrams are not allowed to be inconsistent and the negative operator can indirectly specify positive traces. Refinement is defined, but are more restricted as there is no treatment of underspecification in the semantics. Cengarle and Knapp [33] defines denotational semantics for UML 2.x sequence diagrams. Their denotational semantics is trace based and similar to STAIRS and the semantics of St \u776\'cc\'88rrle with respect to the positive parts of sequence diagrams. In difference from STAIRS and St \u776\'cc\'88rrle, they make a prefix closure of negative traces, but does not allow inconsistent sequence diagrams. Their refinement relation differs from STAIRS in that the set of inconclusive traces may be increased, something which is a problem with respect to the monotonicity of the composition operators.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In [34], K \uc2 \u776\'cc\'88 ster-Filipe gives an LSC inspired denotational semantics of UML 2.x sequence diagrams based on partially ordered sets. The partially ordered sets of sequence diagrams is used to build event structures, and modal logic constraints over these event structures are used to express negative behavior, as well as must and may behavior.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
[ Denotational Semantics with Time... \uc3 \u8592\'e2\'86\'90 don\u8217\'e2\'80\'99t care much, skipping]\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Performance Message Sequence Chart (PMSC) [41, 42] extends MSC with syntactic constructs for expressing performance requirements. The aim is to integrate performance characteristics, such as response time and throughput, in functional specifications. \~Sets of acceptable probabilities, rather than a single probability, can be assigned to alternatives. Hence, it is possible to express requirements such as \uc3 \u8220\'e2\'80\'9cthe probability of receiving a reply within 5 seconds after sending a request should be at least 0.9\u8221\'e2\'80\'9d or, for a machine simulating a coin toss, \u8220\'e2\'80\'9cthe probability of getting a heads outcome should be between 0.4 and 0.6\u8221\'e2\'80\'9d\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Operational Semantics:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
MSC-92 has a lifeline-centric syntax and its semantics is based on characterizing each lifeline as a sequence (total order) of events. These sequences are composed in parallel and a set of algebraic rules transforms the parallel composition into a structure of (strict) sequential composition and choice. The causality of messages is obtained by a special function that removes from the structure all paths that violate the invariant. In a way this semantics is not a proper operational semantics since a diagram first has to be transformed into the event structure before runs can be obtained. This transformation replaces parallel composition with choice and hence creates an explosion in the size of the representation of the diagram. In addition, the lifeline-centric syntax is not suitable for defining nested high-level constructs. Compared to UML semantics, the most notable thing about this semantics is that it has no notion of negative behavior, and therefore also makes no distinction between negative behavior and inconclusive behavior (behavior that is neither positive nor negative). This is no surprise since MSC does not have the negative operator of UML 2.x. The only available meta-level is a flat transition graph, and this does not give sufficient strength to extend the semantics with negative behavior. Nor is it possible to define trace-set properties over this transition graph. The semantics has no explicit communication medium; the communication model is \uc3 \u8220\'e2\'80\'9chard-coded\u8221\'e2\'80\'9d in the semantics by the \u8220\'e2\'80\'9cgeneralized operators\u8221\'e2\'80\'9d and does not allow for variation.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
However, the semantics is heavily based on synchronization of lifelines on the entry of referenced diagrams and combined fragments and diverges in this respect from the intended semantics of MSCs and UML sequence diagrams. Further, the same strategy as for the MSC-92 semantics is applied; interleaving is defined by means of choice, and the message invariants obtained by removing deadlocks. This results in an unnecessary amount of computation, especially in the cases where we do not want to produce all traces but rather a selection of the traces that a diagram defines. \uc3 \u8592\'e2\'86\'90 for ppt?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Realizability of MSCs is the focus of both [36, 52] and [53]. They define synthesis of MSC to concurrent automata and parallel composition of labeled transition systems (LTS), respectively. (Each lifeline is represented as an automaton or LTS; the lifelines are then composed in parallel.) Further they define high-level MSCs as graphs where the nodes are basic MSCs. In addition, [53] defines both syntax and semantics for negative behavior. In both approaches the translation of high-level MSCs to concurrent automata/LTSs }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
removes the semi-global nature of choices in a specification (YES)}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
, }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
and the high-level MSC graphs are nonhierarchical, disallowing nesting of high-level operators (NOO)}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. In [53] communication sis synchronous \uc3 \u8592\'e2\'86\'90 for ppt? Ne valja ova a?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Petri Net semantics: one approach does not allow for nesting of high-level operators; another one:translation of the choice operator is sketched, but no loop defined; yet another one: semantics for UML 1.x sequence diagrams is presented, but as with the Petri-net semantics of basic MSCs it has major limitations }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
How about this? sounds a bot like my approach ppt:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Jonsson and Padilla [59] present a semantics for MSC which is based on syntactic expansion and projection of diagram fragments during execution. Each lifeline is represented by a thread of labels where the labels refer to events or diagram fragments. The threads are executed in parallel and when a label referring to a fragment is reached the fragment is projected and expanded into the threads. Expansions may happen at arbitrary points since there are no rules in the semantics itself for when to expand. This creates a need for execution strategies, and the approach may be seen as having an informal meta-level where}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ad hoc strategies are described. However, if completeness is to be ensured, or if the semantics is to be extended with negative behavior or trace-set properties, this meta-level must be formalized. The semantics requires explicit naming of all diagram fragments and this yields an unnecessary complicated syntax. It sdoes not have an explicit communication medium; the communication model is \uc3 \u8220\'e2\'80\'9chard-coded\u8221\'e2\'80\'9d into the semantics and does not allow for variation In [62, 63] an operational semantics for UML 2.x sequence diagrams that is equivalent to the denotational semantics defined in [33] (see above) is given.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
This operational semantics has some similarities to the operational semantics of [60, 61]}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
; for every execution step an event is produced and at the same time the syntactical representation of the diagram is reduced by the removal of the event produced. }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
Contrary to [60, 61], their semantics treats sequence diagrams as complete specifications (with no inconclusive behavior)}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. The rules are defined so that a given diagram produces a set of positive and negative traces that together exhaust the trace universe. The negative operator is replaced by a \uc3 \u8220\'e2\'80\'9cnot\u8221\'e2\'80\'9d operator. This operator is defined so that the sets of positive and negative traces are swapped, with the result that specifying some behavior as negative means also specifying the complement of this behavior as positive. \u8592\'e2\'86\'90 for ppt!!! (this is the paper \u8220\'e2\'80\'9cOperational Semantics of UML 2.0 Interactions\u8221\'e2\'80\'9d from Alex. Knapp \u8592\'e2\'86\'90 I already have a paper from this author, maybe for ppt mention that your underlying semantics shares similarities)\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In [64], Cavarra and K \uc2 \u776\'cc\'88ster-Filipe present an operational semantics for UML 2.x sequence diagrams inspired by Live Sequence Charts (LSC) (see below). The arguments of choices have guards and there is nothing to prevent the guards of more arguments in a choice to evaluate to true. In this case the uppermost operand will be chosen, which means that the choices essentially are treated as nested if-then-else statements and may not be used for underspecification. Each lifeline is executed separately which means that synchronization at the entry of choices is necessary to ensure that all lifelines choose the same operand. They also make the same assumption about negative behavior as in LSCs, that if a negative fragment is executed, then execution aborts. Grosu and Smolka [\uc3 \u8220\'e2\'80\'9cSafety-Liveness Semantics for UML 2.0 Sequence Diagrams\u8221\'e2\'80\'9d] provide a semantics for UML 2.x sequence diagrams based on translating the diagrams to Buchi automata. The approach is based on composing simple sequence diagrams (no high-level operators) in high-level sequence diagrams (interaction overview diagrams), where a simple diagram may be a positive or a negative fragment of the high-level diagram it belongs to. Positive behavior is interpreted as liveness properties and negative behavior as safety properties. Hence, for a high-level diagram two B \uc2 \u776\'cc\'88chi automata are derived; a liveness automaton characterizing the positive behavior of the diagram and a safety automaton characterizing the negative behavior. The diagrams are composed by strict sequencing rather than weak sequencing, and hence has implicit synchronization of lifelines when entering or leaving a simple diagram.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this section we present some of the approaches that have been taken for assigning formal semantics to models expressed in UML state machines and similar languages. An example of an approach that uses abstract state machines is [85], which employs multi-agent abstract state machines to model the dynamic semantics of UML state machines. Their model is intended to define rigorously the UML event handling scheme so that semantic variation points become explicit, while reflecting the original structure of UML state machines. Furthermore, object interaction is formalized by combining control and data flow. This work is further extended by the authors in [86] to cover concurrent states, while [84] surveys their previous work in order to further discuss semantic variation points and unclarities of UML state machines from a formal point of view.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In [87], J \uc2 \u776\'cc\'88rjens extends the semantics given in [85, 86] by modeling actions, internal activities, and their operations and parameters explicitly, as well as providing message passing between different diagrams. This constitutes a further step toward formal modeling of complete UML specifications and the goal of executable UML specifications. A thorough presentation of J \u776\'cc\'88rjens\uc3 \u8217\'e2\'80\'99 work on formalization of UML is given in [88], which provides a formal semantics for UML state machines (as well as other UML languages such as sequence diagrams and static structure diagrams) in terms of so-called UML Machines and UML Machine Systems. UML Machines are inspired by abstract state machines; they are transition systems whose states are algebraic structures. In addition, UML Machines have built-in communication mechanisms similar to the corresponding mechanisms in UML. UML Machines interact by exchanging messages which are dispatched from (or received in) multi-set buffers called output queues (or input queues). Based on UML Machines, [88] defines refinement relations, as well as security properties such as integrity and authenticity, and provides proofs of preservation of security properties under refinement.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Table 4.2 (important, print!)}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
, we see that most of the approaches are evaluated to support underspecification. The general rule is that an approach providing an explicit mechanism for specifying nondeterministic choice supports underspecification, unless such choices are interpreted as must behavior, }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The final evaluation criteria we want to comment upon is the support for incomplete models. This is difficult to assess, as we can always choose to interpret a sequence diagram as an incomplete model. The evaluation was therefore based on the approaches\uc3 \u8217\'e2\'80\'99 treatment of negative behavior, their support for existential behavior, and their definitions of refinement. \u8592\'e2\'86\'90 for ppt!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A few comments to Table 4.3 are also needed. First, we notice that none of the approaches capture incomplete models. The reason is that state machines, unlike sequence diagrams, focus on describing a single component rather than an interaction scenario. All state machine variants we are aware of describe only the behavior that the component may exhibit; behavior not explicitly described is negative in the sense that it should not occur. There is, therefore, no explicit operator for expressing negative behavior, and all behavior is either positive or negative \uc3 \u8211\'e2\'80\'93 there is no inconclusive behavior. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
As the evaluation reveals there is no lack of approaches to formal semantics for UML sequence diagrams and state machines, and many of these have desirable properties. We do not proclaim a winner, but we have established that formal semantics of relevant modeling languages are readily available for the developers of embedded systems. We have not evaluated to what degree the approaches presented in this paper are supported by suitable tools, nor to what degree they have been put to practical application. Still, judging from our evaluation, there should be a large potential for applying UML models supported by formal semantics in the development of embedded systems. It is up to developers to choose a suitable approach based on the nature of the system to be developed, and the background and experience of the development team. \uc3 \u8592\'e2\'86\'90 for ppt!!!!!!!!!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
UML 2 Interaction Overview Diagram Validation}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
UML 2 interaction overview diagram, IOD for short, is a variant of UML activity diagrams where the nodes may be interaction diagrams. Introduced on the UML 2 version, this diagram gathers benefits related to specific and global behaviors. When the nodes are sequence diagrams, it allows a valuated control flow specification. \uc3 \u8592\'e2\'86\'90 for ppt? or future work?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We propose in this paper an approach to validate the IOD notation. The validation is made by model checking using the hierarchical Petri nets derived from the IOD diagrams. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Even though the lack of semantics is even advocated as a beneficial ingredient for the usefulness of the UML, checking the model correctness requires a formal semantics for the notation. UML 2.0 [11] brought more precision on UML 1.x. but it remains informal and lacks tools for automatic analysis and validation \uc3 \u8592\'e2\'86\'90 for ppt!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Many works have already dealt with the semantics of UML 2 activity and sequence diagrams [1], [3], [4], [5], [9], [15]. However, only few works results are communicated on the formalization of the overview interaction diagram which may be used to combine interactions into a kind of dataflow reminiscent of activity diagrams, where the places of activity states are taken by interactions. We aim at formalizing the IOD by mapping it into a formalism which complies on one hand with its nature and on the other hand with its structure. Hierarchical Colored Petri nets (HCPNs) seem to be convenient to this purpose. The derived HCPNs are analyzed by means of PROD [13], a model checker tool for predicate/ transition nets.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The stronger side of the IOD is the fact that it can show dependence between the important sequences of a system, which can be presented by an activity diagram. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The used notation incorporates constructs from sequence diagrams with fork, join, decision and merge nodes from activity diagrams. IODs are special kinds of activity diagrams where the activity nodes are actions or interactions and the activity edges denote control flow only.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The idea behind HCPNs theory is to allow the construction of a large model by using a number of small Petri nets, called pages, which are related to each other in a well-defined way. In a HCPN, the Petri net framework is represented by means of a net called prime page where some transitions called substitution transitions abstract subnets called pages. Each substitution transition is surrounded by places called In/Out-port places. The latter constitute the interface through which the page communicates with its surroundings. The idea is analogous to the hierarchy constructs found in many graphical languages such as IODs. At one level, a simple description of the modeled activity is given without having to consider internal details about how it is carried out. At another level, the more detailed behaviour is specified. Moreover, the detailed specification is integrated with the more crude description and this integration is done in such a way that it becomes meaningful to speak about the behaviour of the combined system}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For formalizing the IOD by mapping it into a formal semantic domain, it is convenient to opt for a language that supports hierarchical modeling. HCPNs appear to be suitable for this purpose. Thus, we propose to liken the IOD to a HCPN prime page and the interaction nodes to HCPN pages abstracted by means of substitution transitions.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Table 1 shows the transformation of the IOD constructs into HCPNs. For each IOD construct, it yields the equivalent HCPN construct expressed by an intuitive transformation as well as a more formal transformation. \uc3 \u8592\'e2\'86\'90 for future work, how I should formalize?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For a more precise validation, specific properties of the system can be written by the designer in Linear temporal Logic (LTL) or Computational Tree Logic (CTL) and then, verified by PROD. Since the main motivation of this work is that the UML designer may reach a valid modeling without needs for knowledge of formal techniques, it is only reasonable that the properties are expressed by the modeler in the OCL language [12] and afterwards, are automatically translated in LTL and CTL logics.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
OCL which is a part of UML for the expression of constraints over UML models, in particular invariants, is appropriate to data value handling. The IOD data is extracted from the interaction nodes described by sequence diagrams. This data provides the HCPH initial marking. However, OCL does not support the expression of temporal properties. So, to deal with an appropriate translation of OCL into the temporal logic supported by the model checker PROD, we first propose to extend OCL with temporal operators and then to translate it into LTL and CTL logics. This work is presented in [2].}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To test the derivation approach, we built a translator whose semantic functions are drawn from the conversion rules we have set. We also developed a graphic interface for the construction of the IOD diagram. This diagram constitutes the input of the translator whose outputs result into predicate/transition nets specified in PROD syntax, see figure 3. Afterwards, PROD was executed to verify the Petri net specification. The basic properties defined above, were first checked and then, some system\uc3 \u8217\'e2\'80\'99s invariants were expressed in OCL, translated into LTL properties and then verified on the HCPNs. Many works tackled the formalization of the sequence and activity diagrams separately.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The first and more important research papers on the UML 2 activity diagrams are those of St\uc2 \u246\'c3\'b6rrle. He analyzed in minute detail the semantics of these diagrams and proposed an approach to their formalization\uc1 }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
[15]. More recent studies carried out by Staines [14] states that UML 2 activity diagrams are based on Petri nets. \~In spite of the research extent on the activity diagrams, no investigation is undertaken on the interaction overview diagram. The only work we encountered is the one of Kloul and K\uc2 \u252\'c3\'bcster-Filipe [8] who show how to model mobility using IODs and propose a formal semantics to the latter by translating them to the stochastic process algebra PEPA nets. The translation abstracts the object behavior inside an IOD node - a sequence diagram in occurrence - reducing it to a typed token. Therefore, the hierarchical modeling of the whole of the system dynamics is missing. This mapping rests on the hierarchical feature of the two notations. A convenient colored marking is also proposed to achieve the HCPN dynamics based on valuated objects. This proposal has never been tackled by previous research works. The derived HCPNs have been validated by model checking. The verification concerned both the model correctness and faithfulness.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Graphical scenarios for specifying temporal properties: an automated approach (2007!)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
(a journal version of \uc3 \u8220\'e2\'80\'9c\uc1 }{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A Scenario Based Notation for Specifying Temporal Properties\uc3 \u8221\'e2\'80\'9d))\uc1 }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 \uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
very important for inspiration}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
These properties are typically specified as linear-time formulae in temporal logics. Unfortunately, the level of inherent sophistication required by these formalisms too often represents an impediment to move these techniques from \uc3 \u8220\'e2\'80\'9cresearch theory\u8221\'e2\'80\'9d to \u8220\'e2\'80\'9cindustry practice\u8221\'e2\'80\'9d. \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The objective of this work is to facilitate the non trivial and error prone task of specifying, correctly and without expertise in temporal logic, temporal properties.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Then we present a scenario-based visual language called Property Sequence Chart (PSC) that, in our opinion, fixes the highlighted lacks of these notations by extending a subset of UML 2.0 Interaction Sequence Diagrams}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. We also provide PSC with both denotational and operational semantics. The operational semantics is obtained via translation into B \uc2 \u776\'cc\'88chi automata and the translation algorithm is implemented as a plugin of our Charmy tool. Expressiveness of PSC has been validated with respect to well known property specification patterns.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In other words, there is a substantial gap between natural language and the LTL language. Holzmann in (Holzmann, 2002) states, for example, that one of the \uc3 \u8220\'e2\'80\'9cmost underestimated problems in applications of automated tools to software verification\u8221\'e2\'80\'9d is \u8220\'e2\'80\'9cthe problem of accurately capturing the correctness requirements that have to be verified\u8221\'e2\'80\'9d. In the same paper Holzmann shows that writing LTL formulae is an error prone task. \u8592\'e2\'86\'90 for ppt!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In (Smith et al., 2002) the authors notice that these problems are not only related to the chosen notation, in fact \uc3 \u8220\'e2\'80\'9cno matter what notation is used, however, there are often subtle, but important, details that need to be considered\u8221\'e2\'80\'9d. For this reason, the introduction of temporal logic-based techniques in an industrial software life-cycle requires specific skills and good tool support. As a matter of fact, industries are not willing to use the above mentioned techniques and this slows down the transition of software verification tools from \u8220\'e2\'80\'9cresearch theory\u8221\'e2\'80\'9d to \u8220\'e2\'80\'9cindustry practice\u8221\'e2\'80\'9d. In order to mitigate this problem, in (Smith et al., 2002) the authors propose PROPEL that, by building upon property patterns previously identified, introduces pattern templates which are represented using both disciplined natural language and finite state automata. Many other works in the last years propose solutions to overcome this problem. While one proposal is to construct a library of predefined LTL formulae from which a user can choose (Dwyer et al., 1999), other works propose the specification of temporal properties through graphical formalisms (Smith et al., 2001), (Dillon et al., 1994), (Zanolin et al., 2003), (Alfonso et al., 2004; Braberman et al., 2005), and (Kugler et al., 2005). Any of these solutions have advantages and disadvantages.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Based on these considerations, we believe that an accurate analysis is necessary in order to understand what is required in a formalism to express a \uc3 \u8220\'e2\'80\'9cuseful set\u8221\'e2\'80\'9d of temporal properties while keeping in mind that easy use and simplicity are mandatory requirements to make a formalism adopted by industries. Thus, in our opinion, the \u8220\'e2\'80\'9cperfect\u8221\'e2\'80\'9d language should find the \u8220\'e2\'80\'9cright\u8221\'e2\'80\'9d balance between expressive power and simplicity of use. \u8592\'e2\'86\'90 for future work! meeting also!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Within the PSC language, a property is seen as a relation on a set of exchanged system messages, with zero or more constraints. Our language may be used to describe both positive scenarios (i.e., the \uc3 \u8220\'e2\'80\'9cdesired\u8221\'e2\'80\'9d ones) and negative scenarios (i.e., the \u8220\'e2\'80\'9cunwanted\u8221\'e2\'80\'9d ones) for specifying interactions among the components of a system. For positive scenarios, we can specify both mandatory and provisional behaviors. In other words, it is possible to specify that the run of the system must or may continue to complete the described interaction. In order to unambiguously determine which execution sequences are allowed or not, we formally define a trace-based denotational semantics of PSC by associating to each PSC the set of all the invalid traces.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
It is well known that an LTL formula can be translated into a Buchi automaton (Buchi, 1960) that can be used by model checkers (Holzmann, 2003) or component assemblers (M.Tivoli and M.Autili, 2004). Although this representation looks more intuitive, it can be very difficult to correctly and directly represent a property as a Buchi automaton. Therefore, in order to overcome this problem and to provide PSC also with an operational semantics, we propose an algorithm, called Psc2Ba, to translate PSC specifications into Buchi automata. The algorithm has been implemented as a plugin of our tool Charmy (Charmy Project, 2004) which is a framework (based on the model checker Spin (Holzmann, 2003)) for software architecture design and verification with respect to temporal properties. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We measured the expressiveness of our language with respect to the set of property specification patterns proposed in (Dwyer et al., 1999) that captures recurring solutions to design and coding problems. \uc3 \u8592\'e2\'86\'90 for meeting, for future work!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Even though PSC is yet another properties specification language, it aims at proposing a language that, building on results and experience of already existent and valuable works in the Literature, aims at balancing expressive power and simplicity of use.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To this purpose, we analyzed existing solutions in order to figure out graphical notations and associated semantics that might be appropriate to facilitate the introduction of our language in an industrial software life-cycle while retaining enough power to express the targeted useful set of temporal properties, i.e., the one identified by the properties specification patterns (Dwyer et al., 1999) (in the middle of Figure 1). The properties that we want to specify express temporal relations between messages exchanged among parts of the system. For this reason the starting point of our analysis has been the tools that are commonly used in industries for specifying component-based systems that interact by message passing. Visual formalisms for scenario-based modeling that are commonly and extensively used within industrial software development practice are Message Sequence Charts (MSCs) (ITU-T Recommendation Z.120., 1999) and UML 2.0 Sequence Diagrams.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Concerning the features that had to be added, if other languages in the Literature (different from UML and MSC) already had one of these features we inherit it from them. For instance, our notion of constraints (that we will introduce in Section 5) has been inspired by Timeedit (Smith et al., 2001) and we have directly inherited part of its graphical notation. Thus, one way to propose a new language is to extend an existing one retaining its original semantics. In the case of UML and MSC it is not possible to completely follow this way since these languages have neither a native formal semantics nor a widely accepted one despite the several attempts to define formal semantics for these two languages. Thus, we inherit graphical elements from UML sequence diagrams and MSC only when these elements have a native informal semantics that is consistent with the formal semantics we define, substituting those graphical elements having an ambiguous semantics. This is for instance the case of message types for which we used Timeedit graphical elements instead of UML assert, optional, and neg frames. However, for the purpose of using MSC to describe temporal properties, the MSC language lacks in expressive power as discussed and itemized in the following: In other words it is not possible to clearly distinguish between mandatory messages and provisional ones. Alternative: it is useful to be able to specify two or more different sequences of messages that can be unconditionally chosen. The MSC language deals with alternatives by means of high-level MSCs; Loop: sometimes a sequence of messages has to be repeated several times. MSC deals with repetitions by also using hMSC but it is not possible to specify a lower and upper bound to the number of repetitions.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Many of the previously identified features have been added in the UML 2.0 Interaction Sequence Diagrams. The authors propose that either MSC should be retired or should become a profile of UML 2.0}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
assert is used to specify mandatory messages; neg is used to describe forbidden scenarios. Both of them are defined as operators (i.e., InteractionOperators), they support nesting and they can be applied to a set of messages. These operators are graphically represented as a frame box with a compartment displaying the name. If an operator has two or more operands, they are divided by dashed lines. This graphical notation can be very expressive when dealing with more than one message and with nesting, but UML 2.0 has yet again not provided a formal semantics. Specifically, it is unclear what happens if there are several neg/assert operators nested or intermixed with other operators}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Thus, as noticed in (St \uc2 \u776\'cc\'88rrle, 2003), neg and assert should be modeled as attributes of a single message rather than operators. \~In accordance with this idea, as we will see later on, the graphical notation we use for neg and assert is different from the one used by UML 2.0. This has been done in order to be closer to the notion of attribute and to make the notation more clear and intuitive;\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Graphical Interval Logic (GIL) (Dillon et al., 1994) is sufficiently expressive but its formulae become potentially difficult to understand. This difficulty comes from the fact that its graphical notation is very close to temporal logic syntax. On the contrary, Timeedit (Smith et al., 2001) (also called TimeLine Editor ) has a more intuitive notation but it was specifically developed to capture long running on complex chains of dependent events (the specification patterns people (Dwyer et al., 1999) call them \uc3 \u8220\'e2\'80\'9cchain patterns\u8221\'e2\'80\'9d). LSCs are an extension of MSCs with the aim of dealing with liveness. This is done by introducing the difference between mandatory and provisional messages that have the same meaning of our Regular and Required messages respectively. LSC is a project started before UML 2.0 and it played an important role in suggesting features of UML 2.0 Interaction Diagrams. In fact, many LSC features are today parts of UML 2.0 Interaction Diagrams. For this reason we have developed the translation algorithm defining PSC as a conservative extension of this language.\uc1 }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The main advantage of PSC with respect to LSC is its ability to specify intraMsg and especially chain constraints. In fact a constraint allows the specification of what can be performed before and after a message exchange. This is very useful to describe causes, effects and precedence and response relations. The translation algorithm proposed by Ghezzi et al. (Zanolin et al., 2003) gets as input a LSC and produces an automaton and a LTL formula, both necessary to express the correct temporal properties.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We also assume components to communicate by synchronous communication channels and hence, send and receive events of the same message are considered to occur simultaneously. Thus, we can restrict to sendevents only and, hereafter, we uniquely associate a message (and hence its label) to its send-event.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
It is worthwhile noticing that, PSC can also be used to specify properties for asynchronous component-based systems since, as pointed out in (Uchitel et al., 2004), \uc3 \u8220\'e2\'80\'9ca bounded asynchronous communication can be modeled by introducing buffer abstraction to decouple message passing\u8221\'e2\'80\'9d. Of course, this could lead to ugly and cluttered specification of both the system models and the properties themselves.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Since we are interested in expressing properties for specifying execution sequences of a system in terms of message passing, we define an ordering relation among the system messages by abstracting with respect to the absolute time. This abstraction is acceptable since, at the moment, we are not interested in real-time systems for which modeling time becomes relevant. \uc3 \u8592\'e2\'86\'90 for ppt same!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Crucial for ppt: }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Within a PSC scenario we identify a set of horizontal dotted lines t0 , . . . , tn+1 (see Figures 2 and 3). These lines are called structural time-lines (or simply time-lines) and identify a point in time. For each time-line only one arrowMSG is allowed, except for time-line t0 and tn+1 that cannot have associated messages. }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
Time-lines are totally ordered from top to bottom and the pair time-line and its associated arrowMSG uniquely identifies the sender and the receiver (and hence the corresponding send-event). Note that, the use of time-lines is only a means for structuring the lifelines. In fact, time-lines are totally ordered but this ordering is only (graphical-)structural.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
That is a designer can also specify a partial ordering of messages by using constraints and operators that we shall define later.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In order to identify the sender and the receiver components, the intraMSG labels are prefixed by the name of the sender component and postfixed by the name of the receiver component. For example, the label Ci .l.Cj denotes the message labeled by l sent from the component Ci to the component Cj. \uc3 \u8592\'e2\'86\'90 have this already in the other paper below.. The filled circles are two constraints that (by the identifier b) ref- erence the message label UserInterface.logout.ATM. The constraint associated to wReq states that the pair of messages login and wReq is a valid precondition for the uDB request iff the intra-message logout is not exchanged after login and before wReq. It is useful to note that, while the messages login, wReq and uDB create the main structure of the property, the constraint \uc1 }{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
b }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
over the unwanted message logout is used to refine the main structure by imposing restrictions on what can happen over the time intervals between login and wReq, and between wReq and uDB. \~\{ b= UserInterface.logout.ATM \} PSC distinguishes among three different types of arrowMSGs:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
- message types:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Regular messages: the labels of such messages are prefixed by \~\uc3 \u8220\'e2\'80\'9ce:\u8221\'e2\'80\'9d. They denote messages that constitute the precondition for a desired (or an undesired) behavior. It is not mandatory for the system to exchange a Regular message (or a set of sequential Regular messages), however, if it (or they all) happens the precondition for the continuations has been verified. This kind of messages can be mapped into UML 2.0 \~and MSC provisional messages\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
- Required messages: are identified by the \uc3 \u8220\'e2\'80\'9cr:\u8221\'e2\'80\'9d label prefix. It is mandatory for the system to exchange this type of messages provided that their (possible) precondition is met. By means of these messages we can specify liveness properties. Required messages have the same meaning of UML 2.0 assert messages that are used to identify the only valid continuations. Fail messages: their label is prefixed by \u8220\'e2\'80\'9cf:\u8221\'e2\'80\'9d. They identify messages that should never be exchanged. Fail messages are used to express undesired behaviors and hence safety properties. UML 2.0 neg operator expresses the same notion. In fact, the operator neg is used to represent unwanted traces. - Strict ordering: in order to explicitly choose a strict ordering between a pair of messages, we define the strict operator. A loose ordering is assumed otherwise. Within a lifeline, between a pair of messages m and m on time-lines ti and ti+1 respectively, the strict operator specifies that no other messages can be exchanged. Graphically, the strict operator is a thick line that links the pair of messages \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For this operator UML 2.0 uses the same graphical notation (i.e., a named frame box) as the one used for the neg and assert operators described in Section 3. Differently from us, in UML 2.0 it is also permitted to specify strict ordering within more than one lifeline.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We think that the strict operator is well defined as a relation between two contiguous messages within a single lifeline (see Figure 4). In fact, by referring to Figure 5.a, it does not make sense to state that the message m between C1 and C2 must be strictly followed by the message m between C3 and C4. On the contrary, as it showed in Figure 5.b a loose ordering of two messages m and m exchanged between independent pairs of components is allowed.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
- constraints: constraints of an arrowMSG m impose \uc3 \u8220\'e2\'80\'9crestrictions\u8221\'e2\'80\'9d on intraMSGs of m. Restrictions specify either a chain of intraMSGs (chain constraints) or a set of intraMSGs that the system must not exchange (unwanted messages constraints). Informally, an unwanted messages constraint is satisfied iff all the set of intraMSGs specified as unwanted messages are not exchanged. As noticed in (Dwyer et al., 1999) chains are very useful for describing a relationship between a single arrowMSG m and a sequence of intraMSGs m1 , . . . , mn .\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
As will be clear later, both wanted and unwanted chains are different from sequences of required, regular, or fail messages since chains consider the sequence of messages as a whole.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
timelines vs lifelines, notice!}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this section we give the PSC operational semantics in terms of Buchi automata that can be seen as operational representations of PSC scenarios. In fact, it is well-known (Gerth et al., 1995; Clarke et al., 2001) that all LTL formulas, and hence also all the PSC scenarios, can be translated into a Buchi automaton. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A well known method for describing sets of acceptable or unacceptable behaviors of a system is by using automata over infinite words and Buchi automata represent a popular formulation of infinite word automata. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
An accepting state is graphically represented with a double-circled state. The problem of \uc2 \u772\'cc\'84model checking using automata assumes that both the system model and the property are specified by automata. Let us suppose that we want to model check the system M. Let A be the automaton representing the system M such that the behavior of M is the language L(A). Let S be an automaton such that L(S), the corresponding language, contains the set of allowed behaviors. The system A satisfies S when L(A) \uc3 \u8838\'e2\'8a\'86 L(S). That is, if the intersection L(A) L(S) contains behaviors, each of them corresponds to a counterexample. Therefore the model checker requires to have the negation of S to perform the analysis. Since to negate a B \uc2 \u776\'cc\'88chi automaton is\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
an expensive task, and we use B \uc2 \u776\'cc\'88chi automata to give semantics to PSC, the translation algorithm from PSC to B \u776\'cc\'88chi automata directly derives the B \u776\'cc\'88chi automaton corresponding to the negation of the desired temporal property. That is, when an execution of the automata is accepting then the property is violated.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In the following, we present the translation rules and the pseudo-code of the algorithms used to translate a PSC into its corresponding Buchi automaton. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Figures 8, 9 and 10 \uc3 \u8592\'e2\'86\'90 rather important!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Before giving a detailed description of the chain constraints, which are used to express relationships between chains of intraMSGs and arrowMSGs, we recall that we distinguish between wanted and unwanted chains (Section 5.1). Informally, a wanted chain constraint (either in the past or in the future) related to an arrowMSG a represents a sequence of intraMSGs (m1 , . . . , mn ) of a and it is satisfied if the messages are exchanged following the loose ordering imposed by the chain itself. Focusing on the rule e future unwanted chain constr, we note that the valid continuation is in every state after a has been exchanged and the chain is not completely performed. In fact, since we do not want the messages (m1 , . . . , mn ) to be exchanged in the order of the corresponding wanted chain, before that the corresponding wanted chain has been completely accomplished, each state is a final state (and hence, a valid continuation). In e past unwanted chain constr we have a valid continuation only if a happens before the chain has been completely accomplished. Conversely, in the case of e future wanted chain constr, after a happens, the valid continuation is reached when the chain has been completely accomplished. Complementarily, in the rule e past wanted chain constr, the valid continuation is obtained when a happens after the chain.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Figures 11, 12 and 13 \uc3 \u8592\'e2\'86\'90 rather important!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Fail messages have only two chain constraint rules since the system has no future after a fail message has been exchanged. In this section we present subroutines used for composing B \uc2 \u776\'cc\'88chi automata and special composition rules for PSC operators: parallel, loop and alternative. These rules are meta-rules because they are used for translating the mentioned operators that do not have a prefixed number of messages as arguments. For this reason there is no direct mapping into B \u776\'cc\'88chi automata but they require a dedicated translation algorithm.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Parallel: the next function permits to derive the B \uc2 \u776\'cc\'88chi automaton corresponding to the parallel operator. The parallel operator par(\u969\'cf\'89 h,k ,sp(h, k)) with sp(h, k)=\{(h, q), (q + 1, z), . . . , (t + 1, k)\} \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
interleaves}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
the linearizations \uc2 \u969\'cf\'89 h,q , \u969\'cf\'89 q+1,z , . . . , \u969\'cf\'89 t+1,k \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
in any way as long as the ordering imposed by each linearization as such is preserved}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. \uc3 \u8230\'e2\'80\'a6. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In continuation: plenty of message semantics + operator semantics formulas!}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
And a theorem that operational and denotational semantics are equivalent.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ok;}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
As already discussed, since scenario specifications are less informative with respect to LTL formulae, the set of properties that can be specified in this way is just a subset of LTL properties. However, this does not appear to be a significant restriction since the subset of specifiable properties, as confirmed by several case studies we have considered so far, appears sufficiently expressive for a software designer. \uc3 \u8592\'e2\'86\'90 for future work! meeting?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
More precisely, Psc2Ba can graphically express a useful set of both liveness and safety properties: Liveness: by means of required messages we are able to express that a message is mandatory. Safety: by means of fail messages we can express that a message should not happen. By means of constraints we can raise an error when a message in a constraint happens before the message containing the constraint.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We are able to represent in PSC all the defined patterns (PSC Project, 2005). Since PSC is an event-based formalism in terms of exchanged messages among components, and since in event-based formalisms the underlying model does not allow two events to coincide (Dwyer et al., 1999), we disallow the specification of simultaneous events. \uc3 \u8592\'e2\'86\'90 VERY IMPORTANT!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
page 50: \uc3 \u8220\'e2\'80\'9cSimilary to what done..\u8221\'e2\'80\'9d\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
(seems like between q and r scope is not very naturally presented with the PSC, see fig.16!)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Focusing on the Precedence Chain 1 cause-2 effects within the between q and r scope, the \uc3 \u8220\'e2\'80\'9cafter q\u8221\'e2\'80\'9d notion is represented as a regular message.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In the other example, Precedence Chain 2 causes-1 effect within the after q scope, the two causes are s and t and the effect is p. The \uc3 \u8220\'e2\'80\'9cafter q\u8221\'e2\'80\'9d scope is represented as a regular message. There is an error if we have the effect without having the chain of causes. Thus, the error is represented as a fail message p with a past unwanted chain constraint of s and t. Note that the PSC formula is scalable, in fact, if we want to write a 3 causes-1 effect, we have to add the third cause, z, as a third element in the tuple g.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Case Study: are the buchi automata automatically generated? Yes:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The Psc2Ba algorithm has been implemented as a plugin for Charmy. The plugin permits to design the PSC scenarios and to produce the corresponding B \uc2 \u776\'cc\'88chi automata. The current implementation produces a B \u776\'cc\'88chi automaton in the form of never claim, which is \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
the syntactical textual representation of B \uc2 \u776\'cc\'88chi automata.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
(}{{\field{\*\fldinst HYPERLINK "http://www.di.univaq.it/charmy" }\scaps0\caps0\cf3\strike0\i0\ul\ulc0\b\animtext0{\fldrslt \cf2\ul\ulc0\langfe255\alang255\lang255\rtlch \ltrch\loch\fs22\loch\f5
http://www.di.univaq.it/charmy}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
}} }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
last update 2006!!!)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this paper we proposed a formalism for specifying temporal properties aimed at being simple, (sufficiently) powerful and user-friendly. After having examined Message Sequence Charts (ITU-T Recommendation Z.120., 1999), and UML 2.0 Interaction Sequence Diagrams (Object Management Group (OMG), 2004), we presented a scenario-based graphical language that is an extended notation of a selected subset of the UML 2.0 Interaction Sequence Diagrams. We called this language Property Sequence Chart (PSC). \uc3 \u8592\'e2\'86\'90 duh, for future work! criteria!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Within PSC a property is seen as a relation on a set of exchanged system messages, with zero or more constraints. More precisely, our language is used to describe both positive scenarios (i.e., the \uc3 \u8220\'e2\'80\'9cdesired\u8221\'e2\'80\'9d ones) and negative scenarios (i.e., the \u8220\'e2\'80\'9cunwanted\u8221\'e2\'80\'9d ones) for describing interactions among the components of a system. PSC can graphically express a useful set of both liveness and safety properties.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
USE: A UML-based specification environment for validating UML and OCL (2007)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Here, we concentrate on model validation, i.e., on checking that a model meets informal requirements a developer has in mind. Checking also involves that the model satisfies particular properties, for example, that certain consequences can be proved or at least certified by a model inspection process. USE basically is an interpreter for a sub-set of UML and OCL. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
An OCL constraint is either an invariant or a pre- or post-condition. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The USE system supports developers in analyzing the model structure (classes, associations, attributes, and invariants) and the model behavior (operations and pre- and post-conditions) by generating typical snapshots (system states) and by executing typical operation sequences (scenarios). Structural restrictions (invariants) which determine the allowed object diagrams and behavioral restrictions (pre- and post-conditions) which narrow the allowed operation calls and operation returns are present in the model browser, but are not shown in the class diagram.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Class extent: The extent of class Person after the last operation has been executed indicates the current object identities (ada, bob, etc.) and the values the attributes (name, civstat, etc.) currently take. In this situation, the class extent uniquely determines a UML object diagram (with no links) characterizing the current system state. The theoretical work in connection with USE proposing an OCL metamodel and defining the formal semantics of OCL found its way into the OCL 2.0 OMG standard. USE is the only system allowing snapshots to be generated automatically. \uc3 \u8592\'e2\'86\'90 probably that\u8217\'e2\'80\'99s why so many citations \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The syntax of UML and OCL is defined with a metamodel using UML (MOF). The semantics of OCL and the needed class diagram features of UML is expressed in terms of plain set theory in [11] which has been implemented in the USE system hand in hand with the formal semantics. This set-theoretic semantics of OCL is part of the OMG standard and additionally expressed in that standard in terms of a metamodel. We have described the tool USE which allows UML models with OCL constraints (invariants and pre- and post-conditions) to be validated against developer\uc3 \u8217\'e2\'80\'99s assumptions. \~\u8592\'e2\'86\'90 the problem is that temporal properties still cannot be validated\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
USE allows to a certain extent the checking of formal properties. USE permits us to review the consistency of UML models and the independence of constraints. USE makes it possible to certify properties. It can be shown that under particular assumptions certain constraints are logical consequences of a given UML model.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Thus, USE supports developers in analyzing the model structure and behavior and in exploring properties of models. USE (as all other OCL systems we are aware of) does not allow full automatic formal verification of arbitrary properties formulated in OCL.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Roles at the Basis of UML Validation (2007, Algeria?)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
we first present a technique for transforming UML statecharts into Petri nets. We develop afterwards, an approach based on the movement of the objects throughout the roles they play. This approach allows validation of the temporal logic properties translated from the OCL invariants, on the Petri nets derived from the UML models. The Petri nets resulting from the derivation process are analyzed by means of PROD [22], a model checker tool for predicate/transition nets. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To avoid the high learning cost of the model checker, we suggest that the designer specifies the system properties in OCL, the Object Constraint Language [20] which is part of UML. OCL permits the formulation of restrictions over UML models, in particular, invariants. We automate the translation of these invariants to temporal logic properties so that they can be verified by PROD during the Petri net analysis. \uc3 \u8592\'e2\'86\'90 translate OCL into temporal logic properties? but invariants are meant to hold \u8220\'e2\'80\'9ceverywhere, all the time\u8221\'e2\'80\'9d, so it\u8217\'e2\'80\'99s a really small subset of the possible patterns!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The invariants are specified on class diagrams which model the static structure of a system, in terms of classes and relationships between classes. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A class describes a set of objects encapsulating attributes and methods. An association abstracts the links between the class instances. It has at least two ends, named association ends, each one representing a set of objects playing a given role at a given time. However, a simple translation of OCL invariants}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
into Linear Temporal Logic (LTL) and Computation Tree Logic (CTL) properties is not sufficient for realizing a property checking. Indeed, OCL invariants refer to association ends to evaluate their expressions. So, in case the designer specifies OCL invariants for his models, we attract his attention on the necessity of modeling the actions treating the association ends so that the invariants can be adequately verified by PROD. In other words, he is called on to specify the association end update using the link actions.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We summarize in this section the work that we present in [6] to transform UML statecharts into coloured Petri nets. This work supports the approach that we develop in the present paper. \uc3 \u8592\'e2\'86\'90 for future work, this is how you say it, to glue previous work\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The derivation process is based on an object-oriented approach. Each statechart modeling an interactive class behaviour is transformed into an object subnet called Dynamic Model or DM (see Figure 2). To construct the DM, each state is converted to a place p \uc3 \u8712\'e2\'88\'88 P and each transition is converted to a transition t \u8712\'e2\'88\'88 T.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Figure 3 summarizes the translation of the statechart constructs into their counterparts in Petri nets. \~\uc3 \u8592\'e2\'86\'90 for future work, how I should summarize probably\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We formalize an interaction on a sequence diagram by the 5 tuple (ev, srce, targ, xobj/op, attrib). The component ev identifies the event (\uc3 \u8220\'e2\'80\'9csend\u8221\'e2\'80\'9d class(), \u8220\'e2\'80\'9ccall\u8221\'e2\'80\'9d operation()). Srce and targ are respectively the source and the target object\u8217\'e2\'80\'99s identity. The component xobj gives the exchanged object\u8217\'e2\'80\'99s identity (object:class) if a send event or the called operation op if a call event. As for attrib, it designates the set \{a1 , . . . , ak \} of the exchanged object attributes or the operation attributes.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The verification tackles the good construction of the model, using generic properties as deadlock, livelock, reject states, quasi-liveness, boundedness or reinitializability. All these properties are automatically verified by PROD. As for the validation, it checks whether the model is constructed in conformity with the customer initial requirements. For this purpose, specific properties of the system, written by the modeler, are used.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Since the main motivation of this work is that the UML designer may reach valid models without the need for knowledge of formal techniques, it is only reasonable that the system properties are expressed by the modeler in the OCL language and are automatically translated afterwards into LTL and CTL OCL is mainly based on the use of operations on collections for specifying object invariants. \uc3 \u8592\'e2\'86\'90 for meeting? futurework?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Since these collections correspond to association ends, the latter must appear on Petri net specification so that the translated LTL and CTL properties (whose expression is essentially made of these constructs) can be verified. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
UML action semantics was defined in [21] for model execution and transformation. \~!!}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
An OCL invariant is a stereotyped constraint that must be true for all instances at any time. \uc3 \u8592\'e2\'86\'90 see that\u8217\'e2\'80\'99s the problem! for future work/meeting \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
PROD supports both LTL and CTL logics. LTL and CTL are different regarding expressiveness: there are properties that can be specified in LTL, but not in CTL and vice versa. LTL formulas express properties of one possible system behavior. They are checked on the fly. CTL formulas express the set of all possible behaviors starting in a state. They are checked on all the state space. In LTL the future of a state in a run is inevitable, whereas in CTL a state usually has many different possible futures. Thus, generally speaking, CTL expresses possibility properties whereas LTL expresses properties that are inevitable.}{\scaps0\caps0\cf1\ul\ulc0\b0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
In other words, when mapping an OCL invariant to temporal logic, the only potential used operator is always. I}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
n order to better exploit PROD temporal logics and permit the expression of more properties, }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
we propose to introduce optionally in OCL invariant two new operators}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. The first is the keyword will which means that the condition will be verified in the future (LTL property). The second is the keyword can that means that the condition will be verified in one of the possible futures (CTL property). So, the new forms of the OCL invariant are:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Context object:class inv : ocl-expr [will ocl-expr]}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
and}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Context object:class inv : ocl-expr [can ocl-expr].}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
..It is written for each object of the context \uc3 \u8592\'e2\'86\'90 then how do you relate two objects?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A navigationExp is a reference to an association end defined in a UML model. It is used to determine for an object, the collection of its linked objects. The object is matched with the association end by using a \uc3 \u8216\'e2\'80\'98.\u8217\'e2\'80\'99 as follows: object.associationEnd. As seen in Section 4, an association end is translated into a place of role type, with the name of the association end.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To illustrate the OCL translation into PROD logics, we present three properties }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
covering a large}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
spectrum of OCL expressions: (yeah right)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
- The number of connected stations is limited to}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
maxStation.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
- Only connected stations can transmit messages.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
expression in OCL:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Context s:Server inv :}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
s.connectedStation\uc3 \u8594\'e2\'86\'92excludes(st1:Station)\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
implies st1.transmittedMessage\uc3 \u8594\'e2\'86\'92isEmpty()\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
- While a station st2 is connected, it receives all the messages that are transmitted from a station st1}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Oh come on these three are not so representative, it\uc3 \u8217\'e2\'80\'99s crap! Maybe the last one only\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Other works tackle OCL invariant extension with temporal operations [7], [9] \uc3 \u8592\'e2\'86\'90 check these!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Formal semantics of static and temporal state-oriented OCL constraints (2003) \uc3 \u8592\'e2\'86\'90 cited by 28, VERY PROMISING READ (at least for future work) \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The textual Object Constraint Language (OCL) is primarily intended to specify restrictions over}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
UML class diagrams, in particular class invariants, operation pre-, and postconditions. Based on several improvements in the definition of the language concepts in last years, a proposal for a new version of OCL has recently been published [43]. That document provides an extensive OCL semantic description that constitutes a tight integration into UML. However, OCL still lacks a semantic integration of UML Statecharts, although it can already be used to refer to states in OCL expressions. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This article presents an approach that closes this gap and introduces a formal semantics for such integration through a mathematical model. It also presents the definition of a temporal OCL extension by means of a UML Profile based on the metamodel of the latest OCL proposal. Our OCL extension enables modelers to specify behavioral state-oriented real-time constraints. It provides an intuitive understanding and readability at application level since common OCL syntax and concepts are preserved. A well-defined formal semantics is given through the mapping of temporal OCL expressions to temporal logics formulae.}{\scaps0\caps0\cf1\ul\ulc0\b0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
Moreover, UML and OCL are missing adequate means to specify constraints over the dynamic behavior of a UML model.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
However, it is essential to support the definition of temporal constraints already in early phases of development in order to specify correct system behavior over time. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
While other approaches focus on UML Collaboration and Sequence Diagrams and consider temporal OCL constraints for event communication (e.g., [6, 22, 44]), we investigate consecutiveness of states and state transitions in UML Statecharts and time-bounded constraints over sequences of states.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Since the current UML specification does not come with an OCL metamodel, we first took the OCL type metamodel presented by Baar and H \uc2 \u776\'cc\'88hnle [1] and performed a rather heavyweight extension by directly extending that metamodel [18]. More recently, we developed a UML Profile for our temporal OCL extension based on the OCL 2.0 proposal \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In order to be able to specify temporal OCL constraints, we introduce the notion of a trace over a given model. A trace is an (infinite) sequence of system states. Each element occurring in a trace indicates that a \uc3 \u8216\'e2\'80\'98noteworthy\u8217\'e2\'80\'99 change to the model has happened, e.g., that an operation is called or terminated. We present a mapping of (future-oriented) temporal OCL expressions to time-annotated formulae expressed in a discrete temporal logics called Clocked CTL.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
OCL is a declarative expression-based language, i.e., evaluation of OCL expressions does not have side effects on the corresponding UML model. To integrate constraints into the visual UML modeling approach, invariants, pre- and postconditions are modeled as annotations and attached to the respective model elements in class diagrams. \uc3 \u8592\'e2\'86\'90 for future work?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Due to the lack of an OCL metamodel in the UML standard, extensions of OCL have so far been defined purely on the concrete syntax level, in particular in the areas of business processes [8, 23], knowledge- and databases [5, 11], and real-time systems [41]. A semantics on the language definition level is not given so far.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
As soon as an OCL metamodel becomes part of the UML standard, we expect that extensions of OCL are developed by means of UML Profiles, just as it has already been done for other parts of UML, e.g., in the domain of modeling real-time systems.}
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
An Extension of OCL with Temporal Logic (2002, todo: read fully)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
UML class diagrams are widely used to model the static structure of object-oriented software systems. As a supplement, OCL becomes more and more popular for formulating constraints that can not be modeled by the diagrams. In this paper, we extend OCL with elements of temporal logic. With this extension, constraints on the temporal development of the system structure as well as on the system behavior can be stated in terms of temporal invariants and pre- and postconditions.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Temporal logic, as an extension of predicate logic, has been used successfully in the field of software development (see [13, 8, 7], among other approaches). The basic idea of (linear) temporal logic is to consider not only single states or state pairs, but to care about arbitrary finite state sequences. By doing so, it is possible to characterize system behavior and system development by specifying the allowed system state sequences as life cycles. \uc3 \u8592\'e2\'86\'90 for meeting\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this paper, we present an extension of OCL with important elements of a finite linear temporal logic. Past and future temporal operators are introduced. Our extended version of OCL, which we call TOCL (Temporal OCL), is capable of specifying constraints on the temporal development of a system\uc3 \u8217\'e2\'80\'99s structure. \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The @next}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
modifier applied to an operation has the effect of evaluating the operation in the next state. The past expressions \uc3 \u8216\'e2\'80\'98previous e\u8217\'e2\'80\'99, \uc1 }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
\uc3 \u8216\'e2\'80\'98\uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
existsPrevious}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
e\uc3 \u8217\'e2\'80\'99, \u8216\'e2\'80\'98alwaysPast e\u8217\'e2\'80\'99, \u8216\'e2\'80\'98some- timePast e\u8217\'e2\'80\'99, \u8216\'e2\'80\'98\uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
always e1 since e2}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 \uc3 \u8217\'e2\'80\'99\uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
, \uc3 \u8216\'e2\'80\'98sometime e1 since e2 , and the modifier \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
@pre}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
can be defined analogously. They behave like the future expressions flipped (with}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
respect to to the temporal ordering) across the reference state. \~Finally, a tool could be developed for validation of TOCL constraints with respect to state sequences. The USE tool [16] allows validation of OCL constraints by testing the validity of constraints with respect to example states. For TOCL, example state sequences would be necessary. These could be recorded by a tool like USE; however, long sequences can hardly be produced manually.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The automatic production of appropriate state sequences would be a welcome feature.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
example for your reference: obj@pre(a,b)\uc3 \u8594\'e2\'86\'92forAll( c | expr) \u8592\'e2\'86\'90 meeting\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Some approaches already include timing bounds for property specifications, but they either use completely different notations [22] or introduce time-bounded OCL operations for event-based specifications \uc3 \u8592\'e2\'86\'90 for meeting/future work!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Together with our previous work, we presented an OCL extension that allows for the specification of past-and future-oriented state-oriented time-bounded constraints based on the latest OCL 2.0 metamodel proposal. Our approach is still the only one that extends OCL by us-}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ing the UML extension mechanism of profiles, i.e., stereotypes, tagged values, and constraints.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Model Checking: Algorithmic Verification and Debugging (todo: read fully!)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Algorithmic verification involves three different tasks: (1) requirements specification, (2) building executable system models, and (3) developing scalable algorithms both for checking requirements and for providing diagnostics when requirements are not met. The status for each of these tasks is discussed below. \uc3 \u8592\'e2\'86\'90 for meeting\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Requirements Specification. Requirements characterize the expected behavior of a system. They can be expressed following two paradigms. State-based requirements specify a system\uc3 \u8217\'e2\'80\'99s observable behavior by using transition systems. Property-based requirements use a declarative style. These requirements are expressed as sets of formulas in a formalism such as a TL. A combination of the two paradigms is necessary for enhanced expressiveness, such as in the PSL language. The state-based paradigm is adequate for characterizing causal dependencies between events, e.g., sequences of actions. In contrast, the property-based paradigm is more appropriate for global properties, e.g., liveness and mutual exclusion. For concurrent systems, an important trend is toward semantic variations of state-based formalisms such as Live Sequence Charts. \u8592\'e2\'86\'90 for meeting\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Using TLs has certainly been a breakthrough in understanding and formalizing requirements for concurrent systems. Nonetheless, subtle differences in the formulation of common concepts such as liveness and fairness, which depend on the underlying time model (e.g., branching or linear time), show that writing rigorous logic specifications is not trivial. Furthermore, the declarative and dense style in the expression of property-based requirements is not always easy to master and understand. Requirements must be sound. That is, they must be satisfiable by some model. In addition, they must be complete. That is, no important information is omitted about the specified system. In contrast to soundness, which is a well-understood property and can be checked automatically by using decision procedures, there is no consensus as to what precisely constitutes completeness in requirements specifications, nor how to go about achieving it. Absolute completeness, which means that specifications describe the system exactly, has only a theoretical interest and is probably unattainable for non-trivial systems. Existing requirements specification formalisms are mainly appropriate for expressing functional requirements. We lack rigorous formalisms for extra-functional requirements for security properties (e.g., privacy), reconfigurability properties (e.g., noninterference of configurable features), and quality of service (e.g., degree of jitter). \uc3 \u8592\'e2\'86\'90 for meeting!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Successful application of verification methods requires techniques for building executable models that faithfully represent a system or an abstraction of it. Faithfulness means that the system to be verified and its model are related through a checkable semantics\uc3 \u8211\'e2\'80\'93preserving relation. This will ensure soundness of the model. In other words, any property that we can verify for the model will hold for the real system. Furthermore, to avoid errors in building models and to cope with their complexity, models should be generated automatically from system descriptions. Once the semantics is fixed, tractable models can be extracted from real software through abstraction.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Visualizing Requirements in UML Models}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This paper describes an alternative approach termed R E VU (Requirements Visualization of UML), a process for visualizing functional requirements in terms of behavioral interactions in a UML model. \~Two related approaches exist for analyzing behavioral relationships in UML models: visual inspection and guided simulation. In contrast, the R E VU process enables a developer with minimal knowledge of a model to learn about the system. Specifically, a critical aspect for understanding how a UML model realizes requirements are witness scenarios. A witness scenario is a particular sequence of steps executed by the system to fulfill a given functional requirement. The R E VU process uses three key steps to create and visualize witness scenarios. First, the developer declaratively specifies properties of a witness scenario in natural language. The declarative specification allows a developer to \uc3 \u8220\'e2\'80\'9cunderspecify\u8221\'e2\'80\'9d the witness scenarios, thereby uncovering scenarios when little system information is available. Second, a model checker generates one or more witness scenarios that adhere to the previously specified properties. For this step, we use a model checker\u8217\'e2\'80\'99s ability to search for counter examples in the state space and store these counter examples in the form of violation traces. Specifically, we exploit this trace creation capability to create witness traces, which our tool suite automatically converts to witness scenarios in terms of UML elements. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Therefore, our process has three main contributions:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
(1) support for declaratively specifying the scenarios to be visualized in natural language; (2) automated generation of witness scenarios; and (3) support for visualizing the witness scenarios.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The REVU process leverages a roundtrip-engineering approach to the construction of conceptual UML diagrams for modeling and analyzing system requirements. \uc3 \u8592\'e2\'86\'90 rountripping, nice buzzword\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this process, requirements are specified declaratively as natural language properties that are mapped to temporal logic representations. In contrast, the system model is specified in operational fashion using UML class and state diagrams. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Three existing approaches and their tool support jointly facilitate the round-trip engineering approach. First, the SPIDER tool suite [19, 21] facilitates the specification of formally analyzable properties using natural language. Properties specified using S PIDER can be automatically translated to formal specification languages, e.g., linear-time temporal logic (LTL) [25] to be used with the model checker Spin [14]. Second, Hydra [26] implements a metamodel-based approach to mapping UML diagrams to the specification languages of formal analysis tools, e.g., model checkers. Third, Theseus [8] visually animates the analysis results (i.e., witness scenarios) in terms of the original UML diagrams.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To validate our work, we applied the R E VU process to an industrial case study for an adaptive light control system. In this case study, we demonstrate how R E VU facilitates the understanding of complex system interactions. \uc3 \u8592\'e2\'86\'90 so this is how you \u8220\'e2\'80\'9cvalidate\u8221\'e2\'80\'9d :-/\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This section provides a brief introduction to our natural language specification tool suite (S PIDER), our UML formalization framework (Hydra), and our UML visualization tool (Theseus).}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
S PIDER [19, 21] (Specification Pattern Instantiation and Derivation EnviRonment) is a process with corresponding tool support that enables a developer to use a natural language-based grammar to specify properties of UML models. Specifically, these properties are specified in natural language using a previously developed process for deriving and instantiating formally analyzable natural language properties based on specification patterns [5, 20]. Briefly, the SPIDER process comprises three steps:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
1. Derivation: Derive a natural language sentence from a structured natural language grammar.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
2. Instantiation: Instantiate the natural language representation with model-specific elements.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
3. Mapping: Map the instantiated natural language sentence to the temporal logic required by the targeted formal validation and verification tool and analyze. An important component of this process is a structured natural language grammar. This grammar is used to derive natural language sentences that can be mapped to formal specifications, such as LTL formulae.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
It is well-known that UML lacks a precise, formally defined semantics. Therefore, numerous semantic interpretations are possible for a given diagram. In order to address this problem and to make UML diagrams amenable to rigorous analysis, McUmber and Cheng [26] developed a metamodel-based formalization framework that maps a given UML model into a formal specification language, such as Promela, the specification language for the model checker Spin [14]. Hydra automates this mapping process [26].}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The general UML-to-Promela formalization approach is to map objects to processes in Spin (proctypes) that exchange messages via channels. Nested and concurrent states are also formalized as processes. Additional details on the modeling and analysis process, and the underlying formalization framework can be found in [26]. \uc3 \u8592\'e2\'86\'90 for ppt! The first paragraph is how I do it. But mapping objects to processes in Spin, not good for known reasons.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Theseus [8] is a UML visualization tool that enables developers to visualize analysis results produced by formal analysis tools in terms of UML model elements. Theseus comprises an analysis-tool-specific Theseus trace processor sand the generic Theseus visualization engine. The Theseus trace processor converts a trace created by a formal analysis tool, e.g., a counter example generated by Spin [14], into a scenario in terms of the original UML model elements. The scenario information includes state transitions and detailed information about messages passed between classes. This scenario is stored in a well-defined intermediate XML representation. The Theseus visualization engine reads the scenario from the XML file and presents a step-by-step animation of the counter example through both sequence and state diagrams. The developer has the option of viewing the entire counter example or stepping through any section of interest. The Theseus visualization engine is general in that it can visualize a scenario generated by any formal analysis tool, provided the scenario is represented in the well-defined XML format. \uc3 \u8592\'e2\'86\'90 for ppt! Exactly how I do it! Find this tool! Also separate trace-processor from visualization (XMI representation)\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This grammar (}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
shown in Figure 2)}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
can be used by S PIDER to guide the developer in deriving a natural language property in a syntax-guided fashion [19]. While the grammar follows the structure of the specification pattern system by Dwyer et al. [5], LTL property templates that are not well-suited for the specification of witness scenarios have been modified. \uc3 \u8592\'e2\'86\'90 a very simple grammar! \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To make the LTL formulae useful for uncovering witness scenarios, we modified the specification patterns by Dwyer et al. that were poorly suited for the specification of witness scenarios. The grammar contains natural language representations of all stutter-invariant specification patterns by Dwyer et al. [5],2 tailored to the specification of witness scenario properties. According to the survey in [5], this selection of specification patterns is sufficient to specify more than 90% of properties encountered in practice. \uc3 \u8592\'e2\'86\'90 for future work!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Using this grammar, developers are able to derive natural language templates of properties that can be mapped to the temporal logic representations of the corresponding specification pattern.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Before instantiating a natural language property to be applicable for the system model at hand, the developer replaces the placeholders (i.e., P and S in Expression 3) with free-form text describing the system conditions to which the property applies.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Next, the LTL property created with S PIDER is used by a formal analysis tool, i.e., Spin [14], to create a witness trace. Model checkers, in general, search for violations of a property by traversing the complete state space of the system, thereby analyzing every possible execution sequence. If a sequence is uncovered that violates the specified property, then the model checker provides this sequence as a violation trace, which may be used by our visualization framework and Theseus for the visualization of a property violation (this process is described in [8]). In contrast to the previous technique, this work presents the generation and visualization of witness scenarios in terms of the original UML model. The witness scenarios are created from witness traces generated by the model checker.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A witness trace, as opposed to a violation trace, represents a sequence of steps executed by the system that adheres to the specified property, instead of violating it.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
They don\uc3 \u8217\'e2\'80\'99t mention how they create the \u8220\'e2\'80\'9ccomplementary property\u8221\'e2\'80\'9d! \u8594\'e2\'86\'92 Specifically, we specify the complement of the LTL property. This complementary property is passed to the model \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
checker. If the model checker finds a violation trace of the complementary property, then the uncovered trace is a witness trace of the original property}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. Since model checkers are most effective in finding and generating violation traces [7], the model checker commonly finds such traces traversing only a small portion of the model\uc3 \u8217\'e2\'80\'99s state space. \u8592\'e2\'86\'90 for ppt in bold!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Spin offers an algorithm for iteratively finding the shortest trace [14]. The shortest witness trace}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for a property is the minimal behavior the system performs for a requirement. It excludes irrelevant steps that may be performed by concurrent components. Therefore, shorter traces are commonly easier to understand. It is important to note that Spin only guarantees this trace to be the shortest for safety properties.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Theseus [8] offers two different animation modes for a scenario: state diagram animation (shown in Figure 3) and sequence diagram generation. \uc3 \u8592\'e2\'86\'90 can\u8217\'e2\'80\'99t really find the tool?! Not in the references \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
As a result, the following natural language property is obtained:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Globally, it is eventually the case that the user entering the room while the system is in automatic mode and the brightness level is not sufficient is eventually followed by the system regulating the dimmer to match the desired brightness level.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
By examining the UML model using the UML CASE tool and previous requirements visualizations, the developer has determined that when the system detects that the user enters the room and is in automatic mode, then the variables ComputingComponent.motionDetected and ComputingComponent.automaticMode are both set to true. \uc3 \u8592\'e2\'86\'90 for future work, this is how I would do it (selecting potential values for placeholders, that is!)\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The visual depiction of this scenario expands the developer\uc3 \u8217\'e2\'80\'99s understanding of the requirement by highlighting the objects and interactions that can occur to fulfill it. Numerous CASE tools [2, 13, 16, 28, 31] provide visual simulation support for systems specified in terms of UML models. Simulation, in contrast to R E VU, requires the developer to have extensive knowledge about a system model in order to guide the simulation to achieve the visualization of a specific requirement. Other tools exist that visualize analysis results from model checkers in terms of UML models, such as vUML [24], MOCES [27], and Hugo/RT [18]. \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
However, to the best of our knowledge, none of these tools is concerned with the generation and visualization of witness traces for the original UML diagrams.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 \~}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
(What, only countertraces?) \uc3 \u8592\'e2\'86\'90 see papers!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In contrast to our approach, the Play-In/Play-Out methodology is tailored to the specification of scenario-based system requirements, while our approach focuses on the automatic visualization of scenarios in UML class and state models.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In conclusion, none of the aforementioned approaches combines natural language specification of witness scenario properties, the automated generation of such witness scenarios, and the visualization of the witness scenarios in terms of the original UML model. Numerous directions for future work are possible. First, the tool support could be extended to accommodate traces}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
generated by formal analysis tools other than Spin.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Transforming Process Algebra Models into UML State Machines: Bridging a Semantic Gap?}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Process algebras are used for algebraic and axiomatic reasoning about the behavior of distributed systems. UML state machines are suitable for automatic software generation. We have developed a transformation from the process algebra ACP into UML state machines to enable automatic software generation from process algebra models. This transformation needs to preserve both behavioral and structural properties. The combination of these preservation requirements gives rise to a semantic gap. It implies that we cannot transform ACP models into UML state machines on a syntactic level only. We address this semantic gap and propose a way of bridging it. To validate our proposal, we have implemented a tool for automatic transformation of ACP process algebra models into UML state machines. However, in many applications one also needs to preserve semantic properties. This is not trivial since the semantic domains of the source and target formalism may differ, or a formal semantics may be lacking. These systems are being modeled using a process algebra [2]. Process algebra is a formalism used for algebraic and axiomatic reasoning about the behavior of systems, in particular those involving concurrency [3]. However, little is known about automatic code generation from process algebra models. We use UML state machines as an intermediate step because multiple techniques are available for automatic code generation from them.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Therefore we propose a transformation from process algebra models to UML state machines [4]. We start with plain process algebra in order to understand the basics of software generation from, and model transformations based on process algebras. In this paper we use the well-known process algebra ACP (Algebra of Communicating Processes) [5,6] without encapsulation. In the transformation of this small process algebra we already encounter a semantic gap. The obtained results will be used when translating process algebra based formalisms like timed \uc2 \u967\'cf\'87 [7] or mCRL2 [8]. This requires that the ACP models and the obtained state machines are structurally equivalent with respect to parallel behavior. The ACP models and the state machines obtained from this transformation obviously need to exhibit the same behavior. It is this combination of requirements, i.e., preserving structural and behavioral properties, that confronted us with the problems of bridging a semantic gap. In ACP, constructs are available for modeling synchronous communication between parallel processes. UML state machines are inherently asynchronous, hence no primitives exist for modeling synchronous communication. This means that the transformation from ACP to UML state machines encompasses more than translating syntax. Special care is needed to ensure that the semantic gap is bridged in order to preserve both behavioral and structural properties.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In a recent technical report [12], a transformation from timed \uc2 \u967\'cf\'87 into UPPAAL timed automata is presented. The main purpose of that mapping is to enable model checking and verification of process algebra models. \uc3 \u8592\'e2\'86\'90 dafuk the first one does not support model checking?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In our work we use the tool Telelogic Rhapsody to generate simulation code from state machines. The semantics of Rhapsody state machines differs slightly from UML state machines [15], but this does not affect our approach. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We use the formal semantics of ACP described in [17] and the semantics description of UML presented in [4] to explain informally the behavioral equivalence of ACP constructs and the resulting UML state machines. With behavioral equivalence we mean that the the state machines need to define exactly the same traces as the original ACP models. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The state machine constructs for the sequential, alternative, and parallel composition are straightforward, i.e., the semantics is clear from the syntax. \~}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The left merge operator cannot be expressed in a natural way in a state machine. It is impossible to express that a specific action in one branch of a parallel composition should be performed first. Therefore, the left merge operator is eliminated by rewriting according to the axioms of ACP. Also the communication merge operator cannot be expressed in a natural way in a state machine. Therefore, when communication of two actions is encountered the communication function (\uc2 \u947\'ce\'b3) is consulted whether this communication should be rewritten into an action or the deadlock constant. These are the only two cases in which structure is not preserved,\uc1 }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
but since these two constructs are seldomly used in modeling this is acceptable. \uc3 \u8592\'e2\'86\'90 quee?? communication IS used!!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In ACP the parallel composition of two or more process terms represents not just the interleaving of these terms. It also involves communication of the actions inside them. Consider for example the ACP process term a || b. This will rewrite using the ACP axioms to a \uc2 \u183\'c2\'b7 b + b \u183\'c2\'b7 a + a|b. Suppose now the communication function \u947\'ce\'b3(a, b) = c exists for some action c. In this case actions a and b can be executed simultaneously (a|b) and communicate. The result of this communication is action c. So the traces allowed by this parallel composition are a \u183\'c2\'b7 b, b \u183\'c2\'b7 a, and c. In UML state machines the parallel composition, created by transitions that fork into orthogonal regions, represents interleaving or concurrent execution of the traces in the orthogonal regions. There is no communication between the actions in these traces like in ACP. This gap between the semantics of ACP and UML state machines needs to be bridged.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
One possibility to bridge this gap is to use the ACP axioms to rewrite an ACP model such that all parallel composition operators are removed. In this way all communication is made explicit. The state machine acquired after rewriting is sketched in Figure 3(a). This is not a valid solution since one of the requirements is that the UML state machines need to preserve the structure of the ACP models, at least with respect to the parallel composition. In fact, the combination of the requirements of preserving both behavioral and structural properties gives rise to the semantic gap.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Another possible solution is to exploit the semantic openness of UML state machines. Therefore we propose an action dispatcher that takes care of executing all actions. Actions are not executed in the state machine itself. Instead, an action is announced to the action dispatcher and the branch of the state machine that contains the action is blocked. After the action dispatcher executes the action, it enables the appropriate branch again such that the state machine can continue. If multiple actions that can communicate have been announced, the action dispatcher ensures that communication can occur in accordance with the communication function. Suppose for example that actions a and b are announced and that \uc2 \u947\'ce\'b3(a, b) = c, i.e., actions a and b can communicate resulting in action c. The action dispatcher now also allows action c to be executed. Using the action dispatcher, we succeed in preserving most of the structure of the ACP model. Figure 3(b) sketches the resulting state machine.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
It can be argued whether having a global action dispatcher that exploits the semantic openness of UML state machines is a proper solution. The disadvantage of having this global action dispatcher is that communication behavior is invisible in the state machine. In the case of ACP this is not a problem.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Communication in ACP models is also invisible because it is expressed by a global communication function (\uc2 \u947\'ce\'b3) and not in a process term itself. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Transformation of Atoms. The transformation of all constructs except for the atoms has already been explained in Section 3.2. The atom a maps to the state \~machine depicted in Figure 5. The entry activity on the simple state creates an action object from atom a and invokes the AddToPool method of the action dispatcher. This puts the newly created action object in the action pool. In order to ensure that the state machine does not continue until the action has been executed, a guard is present on the outgoing transition. This guard is true when the action object is not in the action pool. This is the case when the action has been executed or has communicated.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Correctness Considerations. Interference between methods of the action dispatcher can be avoided by executing them under mutual exclusion.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The transformation from ACP models into UML state machines expressed in the XMI format is too complex to implement in a single step. Therefore we split the transformation into four independent steps. This modular approach makes the transformation more transparent, which benefits extensibility, maintainability, and testability. Moreover, every step is (re)usable in isolation. \uc3 \u8592\'e2\'86\'90 for future work, maybe I should do it like this!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In the first step of the transformation the ACP model is rewritten using the ACP axioms to remove all instances of the left merge and communication merge operator. After this step the ACP model will only consist of constructs that have a state machine equivalent. In the second step the implicit tree structure of an ACP model is made explicit. For the representation of this tree structure we use an intermediate language for which we defined a metamodel. This language uses a prefix format. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In the third step the tree representation of an ACP model is transformed into a state machine. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This state machine is defined in a state machine language for which we have also defined a metamodel. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This language closely resembles UML state machines. The only difference is that it does not support the history mechanism. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We chose to use this intermediate format to avoid having to transform into complex XMI constructs directly.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In the last step a state machine is transformed into its XMI [19] representation. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This back-end part is isolated, because the XMI standard is actually not so standard. Most UML tools use a different dialect of XMI requiring different backends. Currently our implementation is able to generate XMI files for the UML tools ArgoUML [20] and Telelogic Rhapsody [21]. \~\uc3 \u8592\'e2\'86\'90 THIS!! FOR KEES! FOR THESIS!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Our state machine language closely resembles UML state machines and there is a one-to-one mapping from UML state machine constructs to XMI. Therefore, this final transformation step is straightforward. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The Telelogic Rhapsody tool allows for execution of state machines. \~\uc3 \u8592\'e2\'86\'90 does RSA SUPPORT THIS?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We use the term rewriting system ASF+SDF [22,23] for the development of our metamodels and for the implementation of our transformation. Transformations between languages is one of the main applications of ASF+SDF. These transformations are performed between languages specified in the Syntax Definition Formalism (SDF) using conditional equations specified in the Algebraic Specification Formalism (ASF). Because the concrete syntax of the source and target language of a transformation are formally defined in SDF, syntax-safety of the input and output of a transformation is guaranteed. This implies that every syntactically correct ACP model is transformed into a syntactically correct XMI document representing a state machine that preserves structural and behavioral properties. Syntax-safety also implies that every ACP model that is syntactically incorrect is not transformed at all. \uc3 \u8592\'e2\'86\'90 for future work, do this in spare time!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Note that trace equivalence is in general only one aspect of semantic equivalence. Without providing a formal semantics for the UML we cannot guarantee that we have bridged the semantic gap completely. Since there are many formalisms with different (or without) formal semantics, there are probably many model transformations that are not proven to be semantics preserving. Proving that a model transformation preserves semantics requires different expertise. \uc3 \u8592\'e2\'86\'90 for ppt!!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We have used the term rewriting system ASF+SDF to implement a transformation from ACP without encapsulation to UML state machines. This required us to define metamodels for both ACP and UML state machines. We have created a metamodel for ACP and for UML state machines without history mechanism. The modular implementation of our transformation has proven to be useful for decreasing the complexity.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We have used the term rewriting system ASF+SDF to implement a transformation from ACP without encapsulation to UML state machines. This required us to define metamodels for both ACP and UML state machines. We have created a metamodel for ACP and for UML state machines without history mechanism. The modular implementation of our transformation has proven to be useful for decreasing the complexity. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Since our transformation preserves most structure of ACP models, UML tools can be used for visualizing this structure. \uc3 \u8592\'e2\'86\'90 for future work/paper; we preserve the structure\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We have considered ACP without the encapsulation operator (\uc3 \u8706\'e2\'88\'82). The next thing to consider is the transformation of the encapsulation operator. This makes the semantic gap even larger. The encapsulation operator prevents certain actions from being executed, which cannot be expressed in a state machine. This requires an extension of the action dispatcher such that it forbids the execution of encapsulated actions. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Software Model Checking Takes Off}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Although formal mehtods have been used in the development of safety- and security-critical systems for years, they have not achieved widespread industrial use in software or systems engineering. However, two important trends are making the industrial use of formal methods practical. The first is the growing acceptance of model-based development for the design of embedded systems. Tools such as MATLAB Simulink6 and Esterel Technologies SCADE Suite2 are achieving widespread use in the design of avionics and automotive systems. The graphical models produced by these tools provide a formal, or nearly formal, specification that is often amenable to formal analysis. The second is the growing power of formal verification tools, particularly model checkers. For many classes of models they provide a \uc3 \u8220\'e2\'80\'9cpush-button\u8221\'e2\'80\'9d means of determining if a model meets its requirements. Since these tools examine all possible combinations of inputs and state, they are much more likely to find design errors than testing. \u8592\'e2\'86\'90 for ppt!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Here, we describe a translator framework developed by Rockwell Collins and the University of Minnesota that allows us to automatically translate from some of the most popular commercial modeling languages to a variety of model checkers and theorem provers. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Model-based development (MBD) refers to the use of domain-specific, graphical modeling languages that can be executed and analyzed before the actual system is built. The use of such modeling languages allows the developers to create a model of the system, execute it on their desktops, analyze it with automated tools, and use it to automatically generate code and test cases.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
There are many types of model checkers, each with their own strengths and weaknesses. Explicit state model checkers such as SPIN construct and store a representation of each state visited. Implicit state (symbolic) model checkers use logical representations of sets of states (such as Binary Decision Diagrams) to describe regions of the model state space that satisfy the properties being evaluated. Such compact representations generally allow symbolic model checkers to handle a much larger state space than explicit state model checkers.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
These translators work primarily with the Lustre formal specification language, but this is hidden from the users. The starting point for translation is a design model in MATLAB Simulink/Stateflow or Esterel Technologies SCADE Suite/Safe State Machines. SCADE Suite produces Lustre models directly. Simulink or Stateflow models can be imported using SCADE Suite or the Reactis tool and a translator developed by Rockwell Collins. To ensure each Simulink or Stateflow construct has a well-defined semantics, the translator restricts the models that it will accept to those that can be translated unambiguously into Lustre.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The translators produce highly optimized specifications appropriate for the target language. For example, when translating to NuSMV, the translator eliminates as much redundant internal state as possible, making it very efficient for BDD-based model checking. When translating to the PVS theorem prover, the specification is optimized for readability and to support the development of proofs in PVS. When generating executable C or Ada code, the code is optimized for execution speed on the target processor.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
..}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
While very complex, the WM is specified in Simulink using only Booleans and enumerated types, making it ideal for verification using a BDD-based model checker such as NuSMV. Ultimately, 563 properties about the WM were developed and checked, and 98 errors were found and corrected in early versions of the WM model. This verification was done early in the design process while the design was still changing. By the end of the project, the WM developers were checking the properties after every design change.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In similar fashion, the testing team developed a series of tests from the same OFP requirements. Even though the testing team invested almost half as much time in testing as the formal verification team spent in model checking, testing failed to find any errors. The main reason for this was that the demonstration was not a comprehensive test program. While some of these errors could be found through testing, the cost would be much higher, both to find and fix the errors. In addition, the errors found through model checking tended to be intermittent, near simultaneous, or combinatory sequences of failures that would be very difficult to detect through testing. The conclusion of both teams was that model checking was shown to be more cost effective than testing in finding design errors. Because of its extensive use of floating point numbers and large state space, the EB cannot be verified using a BDD-based model checker such as NuSMV. Instead, the EB was analyzed using the Prover SMT-solver from Prover Technologies. Even with the additional capabilities of Prover, several new issues had to be addressed, the hardest being dealing with floating point numbers.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
While this allowed the EB to be verified using Prover\uc3 \u8217\'e2\'80\'99s bit-level integer decision procedures, the results were unsound due to the loss of precision. However, if errors were found in the verified model, their presence could easily be confirmed in the original model. This allowed the verification to be used as a highly effective debugging step, even though it did not guarantee correctness. In particular, even very complex models can be verified with BDD-based model checkers if they consist primarily of Boolean and enumerated types. Every industrial system we have studied contains large sections that either meet this constraint or can be made to meet it with some alteration.\uc1 }
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A Survey of Automated Techniques for Formal Software Verification}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This paper surveys algorithms that perform automatic static analysis of software to detect programming errors or prove their absence. The three techniques considered are static analysis with abstract domains, model checking, and bounded model checking. A short tutorial on these techniques is provided, highlighting their differences when applied to practical problems.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The method should be highly automated and scalable to cope with the enormous complexity of software systems. <-- \~for ppt: well we achieve (1), but struggling with (2); }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
also for ppt: highly automated vs fully automated}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
As the state space of software programs is typically too large to be analyzed directly, model checking is often combined with abstraction techniques. We survey predicate abstraction, a popular abstraction technique for software model checking. BMC explores program behavior exhaustively but only up to a given depth. Bugs that require longer paths are missed. Thus, the essence of static analysis is to efficiently compute approximate but sound guarantees: guarantees that are not misleading. Due to the undecidability of static analysis problems, devising a procedure that does not produce spurious warnings and does not miss bugs is not possible. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Static analysis techniques typically propagate a set of values through a program until the set saturates, i.e., does not change with further propagation. Mathematically, such analyses are modeled as iterative application of a monotone function. Saturation occurs when a fixed point of the function is reached. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
An abstract domain is an approximate representation of sets of concrete values. An abstraction function is used to map concrete values to abstract ones. An abstract interpretation involves evaluating the behavior of a program on an abstract domain to obtain an approximate solution. An early popular static analysis tool for finding simple errors in C programs is LINT, released in 1979 by Bell Labs. Several modern tools emulate and extend LINT in terms of the kind of errors detected, warnings provided, and user experience. FINDBUGS for Java is a notable modern tool with similar features. We mention LINT and FINDBUGS because of their significance and influence on static analysis tools. However, these tools are unsound and provide no rigorous guarantees, so we do not discuss them further. Several tools require annotations such as types, pre- and postconditions, and loop invariants to be provided. Annotations may reduce the information that the static analyzer has to compute and improve its precision, but increase the burden on the programmer. This approach is used to varying degrees in the (ESC/Java) tool family [61] and Microsoft\uc3 \u8217\'e2\'80\'99s PREFIX and PREFAST [89]. The annotation and verification mechanism has been integrated in programming languages and development environments such as SPARK [16] and SPEC# [17] to make writing annotations a natural part of programming. We only mention these techniques for completeness. Unlike in model checking, generating counterexamples is difficult or even impossible, due to the precision loss in join and widening operations, and is a current research topic \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Model checking is an algorithmic method for determining if a model of a system satisfies a correctness specification [36], [97]. A model of a program consists of states and transitions. A specification or property is a logical formula. A state is an evaluation of the program counter, the values of all program variables, and the configurations of the stack and the heap. Transitions describe how a program evolves from one state to another. Model checking algorithms exhaustively examine the reachable states of a program. This procedure is guaranteed to terminate if the state space is finite. If a state violating a correctness property is found, a counterexample\uc3 \u8212\'e2\'80\'94an execution trace demonstrating the error\u8212\'e2\'80\'94is produced. Due to their diagnostic value, counterexamples, to quote Clarke and Veith [35], \u8220\'e2\'80\'9c. . . are the single most effective feature to convince system engineers about the value of formal verification.\u8221\'e2\'80\'9d \u8592\'e2\'86\'90 great for ppt!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
However, theoretical results have shown that static analysis methods can be cast as model checking algorithms and vice versa [102], [104]. In practice, static analyzers and model checkers still differ in their applicability and capabilities. Nonetheless, modern static analyzers support specification mechanisms, and software model checkers use abstraction and operate on a program code, so the practical distinction may cease to be meaningful as well.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Explicit-state model checking algorithms directly index states and use graph algorithms to explore the state space, starting from the initial states. Symbolic model checking algorithms use implicit representations of sets of states and may start from the initial states, error states, or the}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
property. We briefly describe both techniques. Explicit-state methods construct a state transition graph by recursively generating successors of initial states. The graph may be constructed in a depth-first, breadth-first, or heuristic manner. New states are checked for a property violation on-the-fly, so that errors can be detected without building the entire graph. Explored states are compressed and stored in a hash table to avoid recomputing their successors. If the available memory is insufficient, lossy compression methods can be used. Bit-state hashing or hash compaction uses a fixed number of bits from the compressed image of a state [74]. This may cause hash collisions, which lead to error states being missed. In practice, with state spaces containing close to a billion states, and hash tables of several hundred megabytes, the probability of missing a state can be less than 0.1%.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Partial order reduction is a method to prune the state-space exploration of concurrent programs [62]. The order in which instructions in different threads are executed may not matter for proving some properties. Transitions whose interleavings do not affect the property can be grouped into classes. A model checker only needs to generate one representative of each class while constructing the state graph. In the best case, partial order reduction can reduce the state space to be explored by a factor that grows exponentially in the number of threads. \uc3 \u8592\'e2\'86\'90 for ppt?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Symbolic model checking methods represent sets of states rather than enumerating individual states. Common symbolic representations are Binary Decision Diagrams (BDDs) [27] and propositional logic for finite sets [24] and finite automata for infinite sets [82]. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A BDD is obtained from a Boolean decision tree by maximally sharing nodes and eliminating redundant nodes. For a fixed variable ordering, BDDs are canonical, permitting Boolean function equivalence, essential in model checking, to be checked efficiently. However, BDDs grow very large. The issues in using finite automata for infinite sets are analogous. Symbolic representations such as propositional logic formulas are more memory efficient, at the cost of computation time. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Symbolic techniques work well for proving correctness and handling state-space explosion due to program variables and data types. Explicit-state techniques are well suited to error detection and handling concurrency. An orthogonal approach to counter state-space explosion is abstraction. It suffices to analyze a sound abstraction of the program, with a smaller state space. Abstractions were manually constructed but are constructed automatically in recent tools. Automated abstraction is based on abstract interpretation. Since model checking examines every possible combination of input and state, it is also far more effective at finding design errors than testing, which can only check a small fraction of the possible inputs and states. \uc3 \u8592\'e2\'86\'90 ppt?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
As discussed in the CerTA FCS Phase II case study, the verification of very large models may be achieved by using model checking on subsystems and more traditional reasoning to compose the subsystems. Combining model checking and theorem proving in this way could be a very effective approach to the compositional verification of large systems.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Promoted by the success of the SLAM toolkit [10], predicate abstraction is currently the \~predominant abstraction technique in software model checking. PROMELA supports simple data types, nondeterministic assignments and conditionals, simple loops, thread creation, and message passing. SPIN operates on-the-fly and extensively uses bit-state hashing and partial order reduction. Recent versions of JPF analyze the byte code of Java programs directly and handle a much larger class of Java programs than the original implementation. JPF also supports symbolic techniques but only for software-testing purposes. The Bandera tool supports}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
state abstraction but does not fully automate it [57]. The VERISOFT software verification tool attempts to eschew state explosion by discarding the states it visits [63]. Since visited states are not stored, they may be repeatedly visited and explored. This method is state-less and has to limit the depth of its search to avoid nontermination. This approach is incomplete for transition systems that contain cycles. One of the first implementations of BMC for C programs is CBMC [38], [83] developed at CMU; it emulates a wide range of architectures as environment for the design under test. It supports both little- and big-Endian memory models, and the header files needed for Linux, Windows, and Mac-OS X. It implements loop unrolling as described in Section IV-C, thus avoiding the exponential blowup that is inherent in path enumeration. SATURN is a specialized implementation of BMC, which is tailored to the properties it checks [108]. It implements loop unwinding as described in Section IV-C. The authors have applied it to check two different properties of Linux kernel code: NULL-pointer dereferences and locking API conventions. They demonstrate that the technique is scalable enough to analyze the entire Linux kernel. Soundness is relinquished for performance; SATURN performs at most two unwindings of each loop. Bugs that require more than two unwindings are missed.}
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
GENERATING PROPERTIES FOR RUNTIME MONITORING FROM SOFTWARE SPECIFICATION PATTERNS}
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Relating computer systems to sequence diagrams: the impact of underspecification and inherent nondeterminism. }
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Having a sequence diagram specification and a computer system, we need to answer the question: Is the system compliant with the sequence diagram specification in the desired way? We present a procedure for answering this question for sequence diagrams with underspecification and inherent nondeterminism. The procedure is independent of any concrete technology, and relies only on the execution traces that may be produced by the system. If all traces are known, the procedure results in either \uc3 \u8220\'e2\'80\'9ccompliant\u8221\'e2\'80\'9d or \u8220\'e2\'80\'9cnot compliant\u8221\'e2\'80\'9d. If only a subset of the traces is known, the conclusion may also be \u8220\'e2\'80\'9clikely compliant\u8221\'e2\'80\'9d or \u8220\'e2\'80\'9clikely not compliant\u8221\'e2\'80\'9d.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Intuitively, a system is compliant with a specification if the behaviours of the system are as described by the specification. The system should potentially be able to perform every behaviour that the specification requires it to offer, and it should do nothing that the specification disallows.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The question of compliance is essential every time a computer system is built from a specification. Even so, the relationship between sequence diagrams and computer systems is surprisingly unclear. An important reason for this, is that sequence diagrams (in contrast to most other techniques for specifying dynamic behaviour) give only a partial view of the behaviour. Also, sequence diagrams are used for specifying computer systems within a broad range of application domains, and they are used for different methodological purposes including requirements capture, illustrating example runs, test scenario specification and risk scenario documentation.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this paper we investigate compliance with respect to two classes of sequence diagrams: Sequence diagrams with underspecification and sequence diagrams with both inherent nondeterminism and underspecification. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The first class may be used to capture trace properties, i.e., }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
properties that can be falsified by a single trace. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Examples of trace properties include safety and liveness properties. The second class is also able to capture trace-set properties, which are properties that can only be falsified by sets of traces. Inherent nondeterminism, on the other hand, means that the system must be able to produce all of the described alternatives.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This section provides a general introduction to sequence diagrams with underspecification (but not inherent nondeterminism, which is treated in Sect. 5), and their semantic model as defined in STAIRS [HHRS05]. For further details of the STAIRS semantics of sequence diagrams, we refer to}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
[HHRS05, RHS05b] }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
and the summary in Appendix A. This formal semantics is compliant with the semi-formal descriptions given in the UML 2.x standard [OMG10]. \uc3 \u8592\'e2\'86\'90 found and printed those two papers!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This example demonstrates that for alternatives specified as underspecification (e.g. using the alt operator), the computer system is not required to 604produce more than one of these. To require the system to produce all alternatives, we need the xalt operator that will be described in Sect. 5. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
As can be seen from the definition, a refinement step may add more positive and/or negative behaviours to the specification, hence reducing the set of inconclusive traces. Also, a refinement step may reduce underspecification, i.e., redefine positive traces as negative. Negative traces always remain negative. A computer system that complies with a sequence diagram resulting from a series of refinement steps, will also comply with the original sequence diagram. In the case of underspecification (and no inherent nondeterminism) investigated above, a system may comply with a given sequence diagram even if the system is able to produce only one of the positive traces in the diagram, and nothing else. In most cases this is of course not satisfactory, as one would like to specify a set of behaviours that should all be reflected in the implementation in one way or another. One example is the gambling machine from Sect. 4.3, where the sequence diagram allowed a system where the only possible outcome was the user losing his money. A realistic specification would be to require that both winning and losing should be possible outcomes. Also, the choice between the two should be performed nondeterministically (or at least appear so to the user of the gambling machine).}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The ref-construct may be understood as a syntactical shorthand for the contents of the referenced sequence diagram. <-- for ppt?}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
[ blabla theorems etc....]}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In the work by Kruger [Kru00], a variant of Message Sequence Charts (MSC) is given a formal semantics and provided a formal notion of refinement. Four different interpretations of MSC are proposed, referred to as the existential, universal, exact, and negative interpretation. The existential interpretation requires the fulfilment of the MSC in question by at least one system execution, while the universal interpretation requires the fulfilment of the MSC in all executions.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Uchitel et al. [UBC07] present a technique for generating Modal Transition Systems (MTSs) from a specification given as a combination of system properties and scenario specifications. System properties, such as safety or liveness properties, are universal as they impose requirements on all of the execution traces, and are in [UBC07] specified in Fluent Linear Temporal Logic. Scenario specifications are existential as they provide examples of intended system behaviour, and are specified in the form of MSC. Live sequence charts (LSC) [DH01, HM03] is an extension of MSC that particularly address the issue of expressing liveness properties. LSC support the specification of two types of diagrams, referred to as existential and universal diagrams. An existential diagram describes an example scenario that must be satisfied by at least one execution trace, whereas the scenario described by a universal diagram must be satisfied by all execution traces. Modal sequence diagrams (MSD) [HM08] is defined as a UML 2.x profile. The notation is an extension of the UML sequence diagram notation based on the universal/existential distinction of LSC. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The main motivation for the development of the MSD language is the problematic definitions of the assert and negate constructs of UML sequence diagrams.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The authors observe that the UML 2.x specification is contradictory in the definition of these constructs, and also claim that the UML trace semantics of valid and invalid traces is inadequate for properly supporting an effective use of the constructs}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Grosu and Smolka [GS05] interpret positive and negative sequence diagrams as specifying liveness and safety properties, respectively. This is a much stronger interpretation than the traditional use of sequence diagrams for illustrating example runs. Based on several transformation steps, the semantics of sequence diagrams is defined as two Buchi automata, one for the positive and one for the negative behaviour. The approach is based on composing simple sequence diagrams without composition operators into high-level sequence diagrams, i.e., interaction overview diagrams. A valid trace is allowed to have any suffix, and events not explicitly mentioned in the diagram may be interleaved with the specified events. Refinement is defined as language inclusion, and the most common composition operators are shown to be monotonic with respect to this refinement notion. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
(found the paper!) }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
There exists also other works on the semantics of sequence diagrams. However, to the best of our knowledge none of these include a distinction between underspecification and inherent nondeterminism or work on refinement and the relationship between computer systems and sequence diagrams. In general, the semantics is also far from the informal description given in the UML 2.x semantics.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In CSP [Hoa85, Ros98], there are two different operators for nondeterminism, referred to as internal and external nondeterminism, respectively. With internal nondeterminism, the system is free to choose whether it should offer all alternatives or only one (or some) of them. The choice may be performed at run-time, making the system nondeterministic, but the choice may also be made by the implementer, resulting in a deterministic system. For external nondeterminism (also called environmental choice), the behaviour is determined by the environment and the system must be able to perform all alternatives. If sequence diagrams are to be used as formal specifications, it is important to know how to evaluate whether a given computer system is compliant with the sequence diagram or not. To the best of our knowledge, our work is the first to address this in detail. Sequence diagrams are different from most other techniques for specifying dynamic behaviour in that they usually give only a partial view. The approach is faithful to the UML 2.x standard, both with respect to the underlying semantic model using sets of positive and negative traces, and with respect to the semantics given for each concrete operator. In particular, all of our definitions take into account the partial nature of sequence diagrams. The compliance checking procedure is independent of any particular programming language or paradigm. All we require, is that there exists some means to obtain (a subset of) the execution traces of the system. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this paper we have only considered sequence diagrams without external input and output. Our results may be generalized to handle also sequence diagrams with such external communication by in each case defining an adversary representing the environment of the system, and then checking compliance under the assumption of this adversary. \uc3 \u8592\'e2\'86\'90 for ppt: adversary representing the environment of the system, and then checking compliance under the assumption of this adversary \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To make practical use of the theoretical work presented in this paper, tool support is obviously needed. We have plans to extend the Escalator tool developed by Lund [Lun08, Lun09] to facilitate testing according to our procedure and guidelines. This will furthermore allow us to investigate the feasibility and usefulness of the proposed procedure in empirical studies. \uc3 \u8592\'e2\'86\'90 !! no tool support yet!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Formal Verification and Validation of UML 2.0 Sequence Diagrams using Source and Destination of Messages}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For presentation VERY RELEVANT}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
SD->SPIN via Eclipse}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
it\uc3 \u8217\'e2\'80\'99s like a copy of our paper; Section 3 most important for properties, how to express them; \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
could use it to shorten intro on SD in my paper; PAR fragments as sub-processes with token synchronization}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
trace semantics of combined fragments [most popular ones] \uc3 \u8592\'e2\'86\'90 maybe I have referenced it already! \u8594\'e2\'86\'92 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
lifeline is a process; combined fragments interesting ideas;}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
good examples of LTL properties over SDs!}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
performance metrics for the property checks useful for NASA paper\uc3 \u8217\'e2\'80\'99\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
BREAK operator with goto statements in PROMELA}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
guards are defined globally, not very nice}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
flag-based technique as a trick to find out who is sending/receiving what and to/from whom. This is useful for writing properties to be verified }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
synchronization mechanism must be implemented to ensure that no event after the combined PAR fragment will overtake an event in it \uc3 \u8592\'e2\'86\'90 for my eventual implementation\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This paper presents a formal V&V technique for one of the most popular UML diagrams: sequence diagrams. The proposed approach creates a PROMELA-based model from UML interactions expressed in sequence diagrams, and uses SPIN model checker to simulate the execution and to verify properties written in Linear Temporal Logic (LTL). }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The whole technique is implemented as an Eclipse plugin, which hides the model-checking formalism from the user. (for ppt. also the following)}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The main contribution of this work is to provide an efficient mechanism to be able to track the execution state of an interaction, which allows designers to write relevant properties involving send/receive events and source/destination of messages using LTL. Another important contribution is the definition of the PROMELA structure that provides a precise semantics of most of the newly UML 2.0 introduced combined fragments, allowing the execution of complex interactions.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this study, we focus on formal V&V of one type of UML diagrams: sequence diagrams. UML sequence diagrams are behavioral diagrams used to specify interactions among system entities in many different situations. They are used to get a better grip of an interaction situation for an individual designer or for a group that needs to achieve a common understanding of the situation [10]. Along with class diagrams and use case diagrams, sequence diagrams are the most popular diagrams of UML [23].}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Though, most of the proposed approaches target only activity and state machine diagrams [4, 8, 9, 12, 14, 16, 19, 20]. There are some approaches targeting sequence diagram [2, 23]. However, when it comes to interactions, it is important to analyze the type of messages being exchanged, as well as their source and destination, and their send and receive events. The proposed approaches targeting sequence diagram mainly focus on getting a formal representation of interactions, and they miss a well-defined methodology to analyze all these important elements. Moreover, those works either do not take into account UML combined fragments (components newly introduced to UML 2.0 that allow designers to describe a number of traces in a compact and concise manner [17]) or their semantics models are not in accordance with the semantics defined in the UML 2.0 specification.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Consequently, it gives them flexibility to write very expressive properties. Another important contribution is the definition of the PROMELA structure that provides a precise semantics of most of the newly UML 2.0 introduced combined fragments, allowing the execution of complex}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
interactions. It allows the developer to simulate much more complex sequence diagrams, with non-straightforward execution trace. The result of these contributions is an efficient approach which is capable of detecting more flaws on more complete and complex interactions.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The proposed approach creates a PROMELA-based model from UML interactions expressed in sequence diagrams, and uses SPIN model checker to simulate the execution and to verify properties written in Linear Temporal Logic (LTL). (for ppt and future work maybe, because mCRL2 has not so intuitive, or not even existent, sending/receiving primitives) }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
PROMELA/SPIN was chosen because it provides important concepts (sending and receiving primitives, parallel and asynchronous composition of concurrent processes, and communication channels) that are necessary to implement sequence diagrams [15]. This makes the implementation easier since the communication primitives and channels are already available in PROMELA and it does not need any extra effort to implement them. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The whole technique is implemented as an Eclipse 3 plugin, which hides the model-checking formalism from the user and allows the V&V engine to be embedded into the development environment.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this section, we briefly present the PROMELA representation of the basic elements of sequence diagrams as defined in [15, 22]. for ppt: }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Then we present the trace semantics of the most popular combined fragments and their respective PROMELA code that correctly simulates the execution traces. The composition of the presented translation rules allows the simulation of complex interactions with interesting and non-straightforward execution trace.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The PROMELA elements used for representing basic components of interactions are: (1) proctype: it is used for declaring new process behaviour, (2) mtype: it defines symbolic names of numeric constants that are used as messages in the communicating process. (3) cham: it declares and initializes communication channels. Finally, (4) !/? operators: Theses symbols are used for sending/receiving messages to/from channels, respectively.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The communication primitives available in PROMELA naturally implements the seq operator following the translation map shown in table 1. This is one of the main reasons for choosing PROMELA/SPIN for model checking of sequence diagrams. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: Alternative and Option combined fragments represent a choice of behaviour in sequence diagrams. The opt operator designates that the combined fragment represents a behaviour choice where either the sole operand happens or nothing happens. An option is semantically equivalent to an alternative combined fragment where there is one non-empty operand and the second operand is empty [17]. The set of traces that defines a choice is the union of the traces of the operands [10, 17].}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: Alternative and Option operator are represented as if condition in PROMELA. The guard variable is declared globally to enforce all lifelines to get the same decision at the choice point. \uc3 \u8592\'e2\'86\'90 globally, not convenient\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A Parallel Combined Fragment, denoted by par operator, represents a parallel merge between the behaviours of the operands.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Parallel behaviour can be implemented using sub-instances of the lifelines covered by the parallel fragment (Fig. 4(b), lines 9 and 11). The new element is instantiated right before the main process starts the parallel activities. A synchronism mechanism should be implemented to ensure that no event after a combined fragment will overtake an event in it. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The main process must wait for all tokens before continuing the execution (Fig. 4(b), lines 4 and 8). Fig. 4(b) shows the PROMELA code of the model in Fig. 4(a).}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The operator loop indicates that the combined fragment represents a repetition structure. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Our PROMELA implementation of loop works with a fixed number of repetition. PROMELA defines do operator as a repetition construct. Loop fragments are implemented by declaring a global variable with the total number of repetition,}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
and a do structure in each lifeline covered by the fragment. <-- for ppt: when you implement iteration, you don\uc3 \u8217\'e2\'80\'99t write a for cycle in each of the objects, do you?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The interaction operator }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
break}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
shows a combined fragment representing a breaking scenario. If the guard condition is true, the operand scenario is performed instead of the remainder of the enclosing interaction fragment. The break operator can be simulated with goto statements in PROMELA. If}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
the guard condition is true, the action inside the break combined fragment is performed, then the execution jumps to the end }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
(}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
from my notes on fig 6: process b has to know there is a guard, not very natural)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Indeed, the system}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
state does not change when messages are sent over channels [23]. To overcome this obstacle, [23] proposed a flag-based technique to mark an occurrence of a send/receive event. This section presents an extension of this approach that is able to determine who is sending/receiving what to/from whom at any time of the execution. This information is very useful when one wants to write properties to be verified. We also show how to write LTL properties using this approach. \uc3 \u8592\'e2\'86\'90 \u8220\'e2\'80\'9ca trick\u8221\'e2\'80\'9d to actually get what we can naturally do with event based temporal logic.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for properties! Excellent brainstorm:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In spite of the fact that they improved the set of properties thatcan be verified, many other properties are still not covered since they require the information of the entities the are interacting (e.g., the following constraint could be specified to a particular system: \uc3 \u8220\'e2\'80\'9cAlice is not supposed to receive a request from Bob\u8221\'e2\'80\'9d). In [2], the authors define the concatenation of sender,\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
message and receiver as one action, but they do not include send and receive events. Even though it provides the entities information, it does not give the flexibility to write properties looking only at a particular element in the model. (e.g., Server does not send anything to anyone without signing). This flexibility is important because systems usually have many entities, but only some of them are really critical. To address these weaknesses, we define a state transition system such that the transitions are triggered by the send and receive events of the interaction and each state is characterized by a 4-tuple consisting of the following fields:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
(i) Lifeline that performed the last action.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
(ii) Last performed action (send or receive).}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
(iii) Message used in the last action.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
(iv) Lifeline to/from which the message was sent/received.}
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The update is done using a d step statement to make the assignment of all new values as one step at the execution time. After defining a methodology to track the execution state, LTL formulas can be written in terms of boolean expressions over the flags. }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
\~}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A very useful property of the flag-based state is the ease of expressing sentence over all lifelines, or all messages, or all actions only by omitting the respective element in the expression}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. For example, if one wants to verify if \uc3 \u8220\'e2\'80\'9cno lifeline receives messages from a\u8221\'e2\'80\'9d, the respective expression is: \uc2 \u172\'c2\'ac(receive\uc3 \u8743\'e2\'88\'a7proc2 a). \u8592\'e2\'86\'90 your translation should also support, with wildcards. but this is state-based, that\u8217\'e2\'80\'99s why the hack \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In order to illustrate the performance of our approach regarding this case study, Table 2 shows a summary of the results along with the number of states, number of transitions, memory and time used by SPIN to perform the verification. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The tool is implemented as an Eclipse plugin composed of three main parts:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
(i) A property editor to allow the developer to assign properties to UML diagrams.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
(ii) A UML translator to generate the PROMELA code from UML interaction.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
(iii) A result interpreter to read the output of the SPIN model checker and translate it into an easy-to-understand graph to be analysed by the developer.}
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: Second, many security aspects are not usually encapsulated in only one type of diagram. Normally they are scattered in various diagrams of different kinds. An inter-diagram analysis might provide results that are much more consistent in the assessment of UML models.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------\line }{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\chcbpat4\rtlch \ltrch\loch\fs22\loch\f5
A True-Concurrent Interpretation of Behavioural Scenario}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The (informal) semantics of a SD is given in terms of partial order on the events appearing in that interaction SD. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
You cannot rely on a graphical notation for formal specificaiton; formal notation with well defined semantics is needed; }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
too theoretical, formulas all over;}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
NOT OK, invalid SDs considered [fig 4]; they use some expressive \uc3 \u8220\'e2\'80\'9ccomponent vectors\u8221\'e2\'80\'9d to model a component that offers/requires services concurrently; good simple explanation of SDs, could be useful for ppt or paper; \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
component language: describes the intended behavior, indicates possible constraints on the order in which operations can/should be called;}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
focus is on a single lifeline as a component, to obtain the vector-language part; events on a lifeline: starting and ending points of a combined fragment \uc3 \u8592\'e2\'86\'90 unique\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Current approaches based on interleaving semantics and do not consider component as having multiple access points;}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
translation UML 2.0 SDs into }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
component vectors }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
\uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
map all locations along a lifeline into (a set of) component vectors; }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
\uc3 \u8220\'e2\'80\'9c\uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
interleaving semantics\uc3 \u8221\'e2\'80\'9d - two events may not occur at exactly the same time; for PPT: locations with different visual time along the vertical axis may still ahve the same occurrence time [par fragments, different SDs] <-- for ppt?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We describe a translation of scenarios given in UML 2.0 sequence diagrams into a tuples-based behavioural model that considers multiple access points for a participating instance and exhibits true-concurrency. Interactions specified in a scenario are modelled using tuples of sequences, one sequence for each access point. In previous work, we have described how (sets of) vectors generate concurrent automata. The extension to our model with sequence diagrams in this paper provides a way to verify the diagram against the state-based model.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The overall system functionality is the result of, often complex and highly concurrent, interactions between components of the system. A thorough understanding of the behaviour exhibited at the interfaces of a component can increase expectations of a successful outcome prior to deployment. A component in pragmatic approaches to software design such as UML [12] or the Koala component model [15] is understood as having multiple access points (i/o ports) through which it provides and requires services, by interacting with other components. UML2.0 sequence diagrams, Message Sequence Charts (MSc) [5] and}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Live Sequence Charts (LSCs) [2] are the mainstay of industrial software specifications describing interactions within the context of a given scenario. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: The (informal) semantics of a sequence diagram defined in any of the above notations is given in terms of a partial order on the events appearing in the interaction described in the diagram. Although useful, the graphical notation alone cannot be relied upon for rigorous analysis and formal verification. Scenarios need to be translated into some other, more formal, notation with a well-defined behavioural semantics. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: Current approaches seem to be geared towards an interleaving semantics and also do not consider participating instances (components) as having multiple access points (ports). }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In a component setting, different ports of a component are connected to different components, which have no knowledge of each other, and thus the case that services are requested/offered at the same time cannot be reasonably excluded. A non-interleaving interpretation of concurrency [16] considers such cases and can faithfully describe concurrent interactions.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Component interactions are modelled}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
using tuples of sequences, one for each access point. These so-called component vectors are expressive enough to model the component offering or requiring services concurrently through its multiple ports. Such vectors, formed over a given component signature \uc2 \u931\'ce\'a3 (cf Definition 3.1), give rise to a certain class of automata [11] in which concurrency is expressed as an explicit structural property. Of course, we are interested in that subset of all possible component vectors over \u931\'ce\'a3 that describes intended behaviour only. \uc3 \u8592\'e2\'86\'90 concurrent automata\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this paper we describe a formal translation of scenarios given in UML2.0 sequence diagrams into component vectors. We give a mathematical construction for the unfolding of scenarios into vector languages, based on a non-interleaving semantics for sequence diagrams.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The formalisation of the information conveyed by a UML sequence diagram, including the constructs for expressing parallel and alternative scenarios, is based on that found in [8], which includes notation for moving down the diagram and identifying any particular constructs. In the context of components, we are interested in the intended }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
behaviour of a component }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
and thus we adopt the formal definition of a sequence diagram given in [8] }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
to a single lifeline}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
rather than the diagram as a whole. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In our formal model of components, the system behaviour exhibited during the execution of the scenario as a whole is then given in terms of composition of the components involved, as described in [10]. <-- for ppt? somewhat same as my approach}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
SDs describe a behavioural view of a system showing the interactions between objects or components in the system. In a nutshell, a sequence diagram displays participating instances as lifelines running down the page (dashed vertical lines in Fig. 1) and their interactions over time are represented as messages drawn as horizontal arrows between lifelines. Each sending/receiving of a message is associated to an event of the sender/receiver. Sequence diagrams in UML 2.0 [12] have been considerably revised in relation to those in previous versions of UML. They have been extended to include features from MSCs [5] and, to a lesser extent, from LSCs [2] and as a result they are more expressive and fundamentally better structured.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
One of the major changes has to do with the introduction of sub-interactions called interaction fragments which can be combined using interaction operators. Interaction fragments may comprise one or more operands (compartments) depending on the corresponding interaction operator. For example, the alt operator designates that the corresponding interaction fragment represents a choice between alternative scenarios. The seq interaction operator (default for sequence diagrams) designates that the interaction fragment specifies a sequencing between the corresponding event occurrences. The PAR interaction operator is used to represent parallel execution of the behaviours from different operands and the resulting par interaction fragment models concurrent interactions. \~\uc3 \u8592\'e2\'86\'90\uc1 }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
how about animation that merges (overlaps) two SDs to express that they could be happening in parallel? for ppt}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In any behaviour of the system, each port will experience }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
sequences of events (<-- they can be also at the same time??)}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
(calls to interface operations) formed over the corresponding set \uc2 \u946\'ce\'b2(p). We simply describe the behaviour of the component as a whole by assigning such sequences to each of its ports.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Thus, a component consists of the static structure described by a signature \uc2 \u931\'ce\'a3 together with a \uc3 \u8217\'e2\'80\'99language\u8217\'e2\'80\'99 V of component vectors, formed over \uc2 \u931\'ce\'a3. Intuitively, the idea is that the component language describes the intended behaviour in that it indicates possible constraints on the order in which the operations of the component can or should be called.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for PPT:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Effectively, the independence relation implies that behaviours which may happen concurrently engage distinct ports of the component. In component-based development, different ports of the component will be connected to different components which have no knowledge of each other and thus cannot be expected to respect any particular ordering in issuing requests over their allocated port. It is important to note that independence alone does not guarantee concurrency - there is the additional requirement that the events concerned are both offered after some behaviour and occur consecutively. \uc3 \u8592\'e2\'86\'90\uc1 }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
weird though, why only distinct ports of the component?}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In describing component interactions, we are interested in event occurrences over ports of the component. These are captured in our formalism using a specific kind of component vectors, termed column vectors, which have at most one event per coordinate.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We describe the unfolding of scenario-based specifications into component vectors. Our primary objective is to capture the intended behavior of the component, in terms of its interactions over ports as specififed in sequence diagrams, and use that to restrict to an appropriate subset V of all possible component vectors V\uc2 \u931\'ce\'a3 formed over a given component signature \u931\'ce\'a3.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The approach we advocate uses UML2.0 sequence diagrams - with a non-interleaving semantics, together with a flavour of LSCs - for specifying the allowed sequences of events over the multiple ports of a component. The idea is to capture the observed behaviours at each point (graphical position) in a sequence diagram by mapping them onto component vectors.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In practice a component will appear in several sequence diagrams. UML 2.0 [12] includes Interaction Overview Diagrams (IODs) which generate a single sequence diagram. We therefore assume a single sequence diagram for a component c. \~\uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
whaa}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
?}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
An alt interaction fragment in a sequence diagram represents choice of behaviour, the choice being between the behaviours described by each of its operands. Recall that at most one of the operands executes. At the end of an alt fragment we need to capture the fact that there are n alternative scenarios the component may have engaged in. We do this by associating the end location of an alt with the component vectors of the last location of each operand.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt: }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Another way of expressing this is by saying that locations from different operands are reached in no particular order. This perception of parallelism is rooted in the formal treatment of concurrency, via an independence relation [13], within our the oretical framework. Independent events that are enabled, and occur consecutively, are concurrent.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This is to reflect the fact that event occurrences appearing in different operands of par are effectively unordered (in parallel).}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Fundamentally, not all properties for concurrent systems can be expressed and}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
verified without considering true-concurrency. Following an interleaving interpreta-}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
tion, it is not possible (to the best of our knowledge) to differentiate between the}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
behaviours described in the sequence diagrams of Fig. 6. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
a || b = a.b + b.a + a|b \uc3 \u8592\'e2\'86\'90 multiation, true concurrency, \uc1 }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
not}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
interleaving semantics}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Tool Support for fUML Models}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
m\uc3 \u8217\'e2\'80\'99eh; action language based on fUML is proposed by this group, with a syntax similar to modern OO languages; here they discuss the GUI editor more; the editor can take a textual representation of the functionality of an operation, and convert it to UML activity diagram with all actions necessary; The \uc1 }{\scaps0\caps0\cf1\i0\ul\ulc0\b0\rtlch \ltrch\loch\fs22\loch\f5
activity}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
is added as the }{\scaps0\caps0\cf1\i0\ul\ulc0\b0\rtlch \ltrch\loch\fs22\loch\f5
behavior}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
of that class }{\scaps0\caps0\cf1\i0\ul\ulc0\b0\rtlch \ltrch\loch\fs22\loch\f5
operation.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Only elements from fUML are used; fUML still in beta; action lanugage is based on }{\scaps0\caps0\cf1\i0\ul\ulc0\b0\rtlch \ltrch\loch\fs22\loch\f5
Action Semantics package from UML}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 \uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
find?}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The fUML standard is currently built and promoted by OMG for building executable UML models. The compatibility of the executable models with the fUML standard means that only the UML elements allowed by fUML should be used for the abstract syntax and the extra constraints imposed by the fUML standard should be considered. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The executable models are models that can be executed and tested without having to generate}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
code from them and test them in a specific platform. The Foundational UML (fUML) [1] is a computationally complete and compact subset of UML [2], designed to simplify the creation of executable UML models. The generated code is meant to be complete, with no code placeholders for the developer to fill out. The fUML standard provides a simplified subset of UML Action Semantics package (abstract syntax) for creating executable UML models. However, creating executable fUML models is difficult, because the UML primitives intended for execution are too low level, making the process of creating reasonable sized executable UML models close to impossible. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To generate code from MOF compliant models, OMG created MOF Model to Text Transformation Language [8], which is suitable to generate code from fUML models.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Model creation. To create the structure of the model, the usual UML Class Diagrams should be used. These Class Diagrams, however, must restrict the elements that can be used to those included in the fUML standard. To create the part of the model corresponding to the behavior of the operations, an Action Language based on fUML needs to be used. This is because it is close to impossible to use UML Activity Diagrams for this task, as the user will need to create, configure and relate too many elements. The Class Diagram editor needs to be integrated with the Action Language textual editor, which is used to create the behavior for each operation. An action language that follows the principles of the structured programming is to use by many programmers familiar with structured programming languages.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt: The action language will need to create the abstract representation for the statements and control structures as provided by the programming languages mentioned above, it must support complex expressions and easy access to parameters and variables.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This can be achieved with a virtual machine that knows how to execute fUML models. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt: The UML meta-model is provided by the Eclipse UML2 project [9], which is part of the larger Model Development Tools (MDT) project. UML2 is built on top of EMF(Core) [10] (which is part of the bigger Eclipse Modeling Framework project - EMF) with some adaptations, as UML has a structure that is not compatible with EMF.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We introduced in a previous paper [3] an action language based on fUML, with a concrete syntax similar to the concrete syntax of the modern programming languages like Java or C++. This action language follows the principles of the structured programming.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The fUML standard specifies how a virtual machine for fUML models should work, and there is a reference implementation in progress from ModelDriven.org [13].}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To generate code, we used the Acceleo project [14], which is part of the bigger Model To Text (M2T) project from Eclipse. This project implements the MOFM2T standard from OMG. It allows the user to create templates, which can later be used to generate code from the models. \uc3 \u8592\'e2\'86\'90 check this out!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
An attempt to combine UML and formal methods to model airport security}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
B and Z are used as target languages for formal analysis, since they are adequate to express }{\scaps0\caps0\cf1\i0\ul\ulc0\b0\rtlch \ltrch\loch\fs22\loch\f5
invariant}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
properties; apparently there are tools to translate from UML+Z annotations to full Z specifications. Annotations on several levels: class, attribute, association, diagram level.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt? : Multiplicities in a class diagram put dynamic constraints on the execution of the model;}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\i0\ul\ulc0\b0\rtlch \ltrch\loch\fs22\loch\f5
not so important, only the underlined }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Strong link has always existed between graphical and formal models, to make sure that \uc3 \u8220\'e2\'80\'9cWhat you validate is what you verify\u8221\'e2\'80\'9d.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Security is regulated by international standards: These are natural language documents with their usual problems: risk of ambiguity or incompleteness, and poor tool support for consistency checking and validation.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The links between the formal specifications and the UML diagrams should be automated since the validation of the formal models is only made indirectly by the certification authority, based on this link. This paper will focus on this link.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
invariant properties: properties that should always hold;}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The translation was recently adapted to produce a specification that can be animated by the Jaza tool [8]. Snapshots of the animation are represented graphically as object diagrams. These animations and representations help understand and validate the specification. \uc3 \u8592\'e2\'86\'90 validate the specification via animations/simulations? ppt?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Difficulties in translating UML into Z The class diagram of Fig. 2 had to be adapted in order to translate it with RoZ \uc3 \u8592\'e2\'86\'90 for ppt: do I need to adapt SDs?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Formalising and analysing the control software of the Compact Muon Solenoid Experiment at the Large Hadron Collider}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Modal mu-calculus explained in Section 3.3 details! \uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
need it!}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
data language mCRL2 great explanation; }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
great for mCRL2 ppt!}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
[34] on mu-calculus; state space explosion - techniques help to a limited extent, more important is to exploit the structural properties of the system; lambda operator in mCRL2 explained; }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
VERY good for ppt}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
livelocks can be tested:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
overapproximation -> could end up with false positives}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
underapproximation -> we miss some reachability}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Under the SMI++ framework, the real world is viewed as a collection of objects behaving as finite state machines (FSMs); \~new language features are only being added at a slow rate. However, its semantics is only defined }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
informally}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The average depth of the control tree is approximately 9 nodes, with a minimal depth of 3 nodes and a maximal depth of 11 nodes. Considering the scientific importance of these experiments, this justifies the use of rigorous methods for understanding and analysing the system.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Using the ASF+SDF meta-environment [5], we have developed a prototype translation implementing our mapping of SML to mCRL2. This allows us to quickly assess the adequacy of the translation through simulation and visualisation of FSMs in isolation, and by means of formal verification of small subsystems of the control software, using the mCRL2 toolset. The feedback obtained by the verification and simulation enables us to further improve the transformation. \uc3 \u8230\'e2\'80\'a6 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
As a result, our translation can easily be converted to another formalism if needed. <-- for ppt?}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Explicit state model checking suffers from the infamous state space explosion problem; in parallel systems, the number of states in the complete system grows exponentially in the number of parallel components. Several techniques have been developed to tackle this explosion, e.g., symbolic model checking [11], symmetry reduction [12,13] and compositional verification. However, from 1020 states there still is a long way to go before we can verify the 1027,500 estimated states in our system. We therefore think it is reasonable to assume that these techniques will only help to a limited extent, and that to verify the control software, we need to exploit the structural properties of the system.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The finite state machines used in the CMS experiment are described in the State Manager Language (SML) [2,3]. In ibid. only an informal semantics is given, and a formal semantics of SML is unavailable. We present the syntax and the suggested meaning of the core of the language using snapshots of a running example; we revisit this example in our formalisation in Section 4, where also the abbreviations that are used in the formalisation are explained in more detail. Note that SML is larger than presented here, also offering language constructs for the hardware device drivers, but the FSMs making up the control system employ these core constructs only.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The mCRL2 language [4] consists of three distinct parts: a data language for describing the data types and transformations, a process language for specifying system behaviours and }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
a modal language for reasoning about the system behaviours. \uc3 \u8592\'e2\'86\'90 for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
New data sorts can be defined either by directly specifying the constructors of a data sort, or using structured sorts, or through aliasing. Relations and mappings on data sorts, and their rules of logic are formalised through equational rewrite rules. Defining data sorts through structured sorts introduces a few built-in mappings and relations, such as projection functions, equality and inequality. Expressions in the data language can be built by combining sort constructors, functions, relations and data variables. <-- for ppt: if you use structured sorts, you get some things for free }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Of particular interest for the formalisation of SML programs is lambda abstraction, which is well-known from \uc2 \u955\'ce\'bb-calculus and type theory. In our specification, we use them, e.g., to model association lists. Functions, specified through lambda abstraction or otherwise, can be updated concisely and intuitively, as illustrated by the following example. f=lambda n:Nat. n+n. Note that this is equivalent to defining f(n) = n + n, but allows inline definition of this function. The support for universal and existential quantifiers further facilitates conventional mathematical reasoning.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The process specification language of mCRL2 consists of only a small number of basic operators and primitives. We forego a formal exposition of its semantics, for which we refer to [4,29]; instead, we restrict ourselves to introducing its syntax, sketch its meaning informally and illustrate its use through small examples. \uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt entire section}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\ulnone\ulc0\animtext0\rtlch \ltrch
\uc3 \u8220\'e2\'80\'9c\uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
now when you add data to your process, you probably need to use or test the value of that data\uc3 \u8221\'e2\'80\'9d\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Animate the following:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A parallel composition of processes p and q, which is denoted by process p||q, behaves as the interleaving of both processes involved: the first action may come from process p, which after execution of this action behaves as process p\uc3 \u8217\'e2\'80\'99; the resulting process then is p\u8217\'e2\'80\'99||q. Symmetrically, the first action may come from process q. In addition, both processes may execute their first actions simultaneously, producing a multi-action, after which the processes that remain are again composed in parallel.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Example 5. Consider the process p defined as sum n:Nat. read(n).send(n) and q, defined as sum m:Nat. send (m).read(m+m). The parallel composition of p and q, may first execute a read(n) action, after which it will behave as the parallel composition send(n)||q, it may first execute a send(m) action, after which it will behave as the parallel composition p||read(m+m), or both processes may execute their first actions simultaneously, denoted by the multi-action read(n)|send(m), after which the remaining process behaves as send(n)||read(m+m)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Finally, recursive equations \uc3 \u8230\'e2\'80\'a6 \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Whereas the process language is typically used to specify how a system achieves its behaviour, the modal language is typically used to reason about high level requirements of such systems. The modal language of mCRL2 is based on the theory of the modal \uc2 \u956\'ce\'bc-calculus [30], extended with facilities to reason about data, see [31,32]. The resulting language is quite expressive; for instance, it admits a linear encoding of the temporal logic LTL, see [33]. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Apart from standard Boolean connectives such as conjunction and disjunction, the mCRL2 modal language permits the use of existential and universal quantification over data sorts (specified by the data language), and the use of Boolean expressions. In addition the language permits the use of modalities. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The must modality [A]f expresses that any first action a(v) executed by a process will result in a process that satisfies property f if action a(v) is among the actions in the set of actions described by A. Dually, the may modality <A>f asserts that among the set of first actions that can be executed by the process, there is one action that is contained in the set of actions described by A, and which, if executed, will result in a process satisfying property f. The modal language permits describing infinite sets of actions, which is needed because of the possibly infinite branching processes that can be described by the process language. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The set of actions characterised by true is the entire set of actions; the set of actions characterised by exists n:Nat. read(n) is the set of read actions with a parameter taken from the set of all natural numbers. Thus, <true>true asserts that a process can execute an action, and [!exists n:Nat. read(n+n)]false asserts that a process can at most execute read actions with even valued natural numbers. Lastly, forall n:Nat. <read(n)>true asserts that a process can execute read actions with every natural number parameter. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Finally, least and greatest fixpoints, denoted by mu X. f(X) and nu X. f(X), respectively, permit reasoning about finite and infinite runs of a system. Typically, least fixpoints are used to specify eventualities, whereas greatest fixpoints are used for invariants. By mixing least and greatest fixpoints, increasingly complex properties, such as fairness properties, can be stated. We refer the reader to [34] for an excellent in-depth discussion of the \uc2 \u956\'ce\'bc-calculus.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Verification of the behaviour described by processes is supported by computing whether a given functional requirement, expressed as a modal \uc2 \u956\'ce\'bc-calculus formula holds for the process or not; this is known as model checking. For specific types of requirements, counterexamples that are easy to interpret can be reported in the case the requirement fails on the given process. This facilitates debugging the cause of the failure.\uc1 }
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\ulnone\ulc0\animtext0\rtlch \ltrch
\uc3 \u8220\'e2\'80\'9c\uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
So far we have only discussed the translation of individual SDs...How do we fit this in the big picture, which process starts orchestrating them..This is done at another level of the specification\uc3 \u8221\'e2\'80\'9d \~<-- for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For each FSM, the process describing its class is instantiated with its id, the id of the parent, the ids, states and types of its children, and the parameters for the initialisation phase. The processes obtained in this way, are then put in parallel. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\ulnone\ulc0\animtext0\rtlch \ltrch
\uc3 \u8220\'e2\'80\'9c\uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
You\uc3 \u8217\'e2\'80\'99ll probably ask the question \u8220\'e2\'80\'9chow do you know it\u8217\'e2\'80\'99s right, how do we know it\u8217\'e2\'80\'99s correct, this translation of yours?\u8221\'e2\'80\'9d\u8221\'e2\'80\'9d : (for ppt)\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
he challenge in formalising SML is in correctly interpreting its language constructs. We combined two strategies for assessing and improving the correctness of our semantics: informal discussions with the development team of the language (well, it helps if you know UML, and I\uc3 \u8217\'e2\'80\'99ve studied the metamodel because I had to), supported by simulations run using the PVSS-II environment used for developing FSMs, and applying formal analysis techniques on sample FSMs taken from the control software. The discussions with the SML development team were used to solidify our initial understanding of SML and its main constructs. Based on these discussions, we manually translated several FSMs into mCRL2, and validated the resulting processes manually using the available simulation and visualisation tools of mCRL2. This revealed a few minor issues with our understanding of the semantics of SML, alongside many issues that could be traced back to sloppiness in applying the translation from SML to mCRL2 manually. In response to the latter problem, we eliminated the need for manually translating FSMs to mCRL2. To this end, we utilised the ASF+SDF meta-environment (see [5,36]) to rapidly prototype an automatic translator that, ultimately, came to implement the translation scheme we described in the previous subsection. The Syntax Definition Formalism (SDF) was used to describe the syntax of both SML and mCRL2, whereas the Algebraic Specification Formalism (ASF) was used to express the term rewrite rules that are needed to do the actual translation. Apart from the gains in speed and the consistency in applying the transformations that were brought about by the automation, the automation also served the purpose of formalising the informal semantics of SML, since the language is mapped to a language that does have a formal semantics. The final details of our semantics were tested by analysing relatively well-understood subsystems of the control software in mCRL2. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
However, the verification using the modal \uc2 \u956\'ce\'bc-calculus currently requires too much overhead to serve as a basis for lightweight tooling that can be integrated in the SML development environment, since their verification in mCRL2 requires their complete state space. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The first problem we consider is detecting livelocks that manifest themselves through loops in the when phase (i.e., generalising the stability property expressed by requirement 2 in the previous section). We use an overapproximation for detecting such loops. This means that we are guaranteed to find all loops a system may exhibit, and the absence of loops proves the absence of a particular type of livelock in the system. However, we may detect loops that cannot occur in practice because the circumstances under which these happen may not be feasible. The second problem we consider is the mutual reachability problem (i.e., generalising requirement 3 of the preceding section). Basically, we use an underapproximation to detect whether there are states in an FSM that can never reach all other states in the FSM. If our analysis reveals there are indeed such states, it indicates that the FSM may become stuck in such states. While this may constitute desired behaviour, it can also indicate a design flaw. Note that, since we use an underapproximation, we may miss reachability issues that occur in practice.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A second desirable behavioural property of an FSM is that all states should remain potentially reachable during the execution of an FSM. That is, the FSM should not become trapped in a subset of its states}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. While we can again easily encode this property into the modal \uc2 \u956\'ce\'bc-calculus, we use a more direct approach to detect violations of this property by constructing a graph that captures all potential state changes. Computing the strongly connected components (SCCs) of the thus obtained graph gives sufficient information to pinpoint violations to the reachability property: the presence of more than a single SCC means that one cannot move back and forth these SCCs (by definition of an SCC), and, therefore, their states.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A Graphical Property Specification Language}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for real-time systems}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
LTL=>state-based;they consider a formula as an acyclic graph; but their notation is still very close to formula and not a real scenario; okayish just the underlined}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
works on two levels: first \uc3 \u8220\'e2\'80\'9cexperts\u8221\'e2\'80\'9d specify the patterns or constructs that the users can combine later; users just use existing templates\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
formulas representing properties of even moderate complexity tend to be hard to understand. Usually, an expert in formal methods is required to create such formulas. The patterns can be organized into libraries and reused in later projects. This two-level approach provides for a natural division of responsibilities, when the users, who are not }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
necessarily well versed in formal methods}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
, are able to express properties in terms, familiar to them. We use LR to express properties of speci cations expressed in the real-time process algebra ACSR. ACSR employs the notion of discrete time. Operational semantics for ACSR gives rise to a labeled transition system LTS with two types of transitions. Transitions of the rst kind are labeled with communication events and represent instantaneous interaction between processes in the speci cation. Transitions of the second kind represent passage of time and are labeled with sets of resources that are used by the system during the time interval. When choosing a logic for expressing behavioral properties, one has to balance expressive power of the logic with efficiency of verification algorithms. In general, a formula is an acyclic graph. Nodes of the graph are operators of the logic - state predicates, propositional connectives, modal and temporal operators. The novel part is in the representation of temporal operators. Each temporal operator illustrated by operator eventually in the example above is represented as a node with an arbitrary number of outgoing edges, each of which may be labeled with a set of conditions, to which we refer as modifiers, to be applied to the corresponding subformulas. Nodes of the graph represent predicates, logical connectives, modal operators and quanti ed temporal operators. Predicates are non-recursive properties that can be decided locally for each state. \uc3 \u8592\'e2\'86\'90 still not very intuitive\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Modal operators are "next state" properties and represent single occurrences of a communication event from a speci ed set. Temporal operators express properties of a path. The two path quantifiers are along some path" and along every path"}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Modifiers place restrictions on traces to which the temporal operator is applied. \~}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To provide semantics to LR expressions, we had to place severe restrictions on the structure of the expression graphs. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Scenario-Based Techniques for Supporting the Elaboration and the Validation of Formal Requirements}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
m\uc3 \u8217\'e2\'80\'99eh, old paper (1998), only underlined\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: \uc3 \u8592\'e2\'86\'90 \u8220\'e2\'80\'9canimator\u8221\'e2\'80\'9d is important to understand interaction at the level similar to controlled code execution \u8592\'e2\'86\'90 lpsxsim of mCRL2\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This paper focuses on the language Albert II, a formal language designed for the purpose of expressing requirements for distributed }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
real-time systems. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The first contribution aims at improving the elaboration process by providing a method for constructing an Albert II description from scenarios expressing the stakeholders\uc3 \u8217\'e2\'80\'99 requirements. These are represented through message sequence charts extended to deal with composite systems. \~In particular, at the RE level, it is clear that we cannot expect our various stakeholders to read mathematical formulae. This is why we are developing a so-called animator tool which allows stakeholders to cooperatively explore different possible behaviours of the future system (as allowed by the formal Albert II description). The purpose of the tool comes down to testing if a given scenario proposed by one or several stakeholders is compatible with the requirements specification. Albert II [13,14] is a formal requirements specification language based on a real-time temporal logic.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The life of an agent instance is an infinite alternate sequence of states and state transitions. A state of an agent instance represents the value of all its state components in a time interval during which they remain unchanged.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. MSC-like notations are intuitive and therefore facilitate communication and understanding between the analysts and the stakeholders;}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. MSC-like notations are particularly well suited for expressing interactions (as opposed to internal actions) which is precisely what one should focus on at the RE activity level (adopting a black-box view of the system).}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The many meanings of UML 2 sequence diagrams: a survey (2011)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Awesome! Survey of the proposed formal semantics; categorizes the semantic choices \uc3 \u8592\'e2\'86\'90 just what I need; most extensive survey\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
complexity of the language yields several possible choices in its semantics \uc3 \u8592\'e2\'86\'90 ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
how many of the proposed semantics are actually formalised? \~}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Very relevant, but long :( }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
13 proposed formal semantics for UML2 SDs. Underlined for presentation; <-- for ppt, make it dramatic! :)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
two main challenges when dealing with semantics: }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
1. scattered through the text of the superstructure}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
2. specification uses semantic variation points -> part of the semantics is left underspecified, to allow UML to be used in many domains; }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
even these variation points are not always marked clearly}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
check [3] -> liveness properties expressed with OCL}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
There is one \uc3 \u8220\'e2\'80\'9ctrue concurrency semantics\u8221\'e2\'80\'9d in 3.5 Considers a limited set of operators and constructs, but gives them well-defined semantics.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Weak sequencing: events that don\uc3 \u8217\'e2\'80\'99t belong to the same lifeline can occur independently + ...they are not related by a path of messages. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Most surveyed approaches formulate the semantics by mapping it to known formalisms (FSM, LQN, Petri-Nets, process algebras etc)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
they differ quite heavily in the symbols and definitions they use}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt? \uc3 \u8594\'e2\'86\'92 problem: the UML spec gives the semantics of UML as a set of \uc1 }{\scaps0\caps0\cf1\i0\ul\ulc0\b0\rtlch \ltrch\loch\fs22\loch\f5
valid}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
and }{\scaps0\caps0\cf1\i0\ul\ulc0\b0\rtlch \ltrch\loch\fs22\loch\f5
invalid}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
traces, but also states that there can be other traces for which we don\uc3 \u8217\'e2\'80\'99t know whether they are valid/invalid.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The 2.0 version of UML changed Sequence Diagrams significantly and the expressiveness of}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
the language was highly increased. However, the complexity of the language (and the diversity of the goals Sequence Diagrams are used for) yields several possible choices in its semantics. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This paper collects and categorizes the semantic choices in the language}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
, surveys the formal semantics proposed for Sequence Diagrams, and presents how these approaches handle the various semantic choices. Message Sequence Chart (MSC) [23] was one of the first of such scenario languages. The 2.0 version of UML changed Sequence Diagrams significantly. Several elements were borrowed from MSC, many new complex elements were added to the language, and the semantics and the underlying metamodel were rewritten. Due to the increased expressiveness of the language, interpreting a complex diagram that uses the new constructs is a difficult task; thus, having a precise formal semantics becomes even more critical. But the many different purposes Sequence Diagrams are used for, e.g., showing the}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
flows of method calls inside a program, or giving a partial specification of interactions in a distributed system, require quite different interpretations of the language. Indeed, many different semantics have been proposed for Sequence Diagrams. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
When we tried to define the semantics of TERMOS, we encountered the problem that the various formal semantics for Sequence Diagrams handle even the most basic diagrams quite differently. It turned out that there are several subtle choices in the interpretation of language constructs. Moreover, these choices and all their consequences are often not obvious. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We thus felt the need for a thorough review of the existing approaches.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: The syntax defined in the specification consists of (i) a concrete syntax defining the graphical notation and (ii) an abstract syntax given with a metamodel defining the relationships between the elements. GeneralOrdering can constrain the ordering of otherwise unrelated occurrences. Messages on their own cannot cross the boundaries of CombinedFragments: they need a Gate which links the two parts of the message. An InteractionUse refers to another Interaction. It can be passed parameters and can have a return value.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The abstract syntax of Interactions is defined with metamodeling; the model is presented in Section 14.2 Abstract Syntax of [33]. The abstract syntax is depicted in several separate diagrams From the abstract syntax we can see, for example, that a StateInvariant belongs to one Lifeline; thus it is a local constraint, or that there are three kinds of Gates, each for different purposes.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The right side of Fig. 5 contains the metamodel elements of sd1. The Interaction is a container for all other elements. The OccurrenceSpecifications are linked to the appropriate Lifelines and Messages. The Lifelines are connected to the CombinedFragments that cover them. The InteractionOperand contains the InteractionFragments (OccurrenceSpecifications, StateInvariants, other CombinedFragments, etc.) which are enclosed by this operand. An InteractionFragment}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
can be enclosed only by one operand; thus when an InteractionFragment is nested in several operands, only the bottommost containment is illustrated in the model explicitly.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: The central concept of the semantics is a trace.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 \uc3 \u8220\'e2\'80\'9c\uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A trace is a sequence of event occurrences, each of which is described by an OccurrenceSpecification in a model.\uc3 \u8221\'e2\'80\'9d (p. 484). A central question is what part of the behavior is modeled by the Interactions. \u8220\'e2\'80\'9cThere are normally other legal and possible traces that are not contained within the described interactions\u8221\'e2\'80\'9d (p. 459). <-- for ppt: well, I say, no. My claim is, ifthe code can represent all legal and possible traces, so can the model, the model can be closed. This is where we deviate a bit from the standard UML proposed semantics.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The Interactions can model also invalid traces, and there could be traces that are not described by the Interaction: \uc3 \u8220\'e2\'80\'9cThe semantics of an Interaction is given as a pair of sets of traces. The two trace sets represent valid traces and invalid traces. The union of these two sets need not necessarily cover the whole universe of traces. \uc1 }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
\~\uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
we go with the assumption that the total behavior is described}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt all: \uc3 \u8220\'e2\'80\'9cThe semantics of \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Interactions is explained with an interleaving semantics, i.e., two events may not occur at exactly the same time.\uc3 \u8221\'e2\'80\'9d \uc1 }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
\uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
is this official?}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The rules for }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
weak sequencing }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
are the following:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\ulnone\ulc0\animtext0\rtlch \ltrch
\uc3 \u8220\'e2\'80\'9c\uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The ordering of OccurrenceSpecifications within each of the operands is maintained.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\ulnone\ulc0\animtext0\rtlch \ltrch
\uc3 \u8220\'e2\'80\'9c\uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
OccurrenceSpecifications on different lifelines from different operands may come in any order.\uc3 \u8221\'e2\'80\'9d\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
OccurrenceSpecifications on the same lifeline from different operands are ordered such that an OccurrenceSpecification of the first operand comes before that of the second operand.\uc3 \u8221\'e2\'80\'9d\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The first category contains operators that introduce choice and iteration. The operators in the second category are for parallelization and sequencing. Operators in the last category are related to the conformance relation, i.e., the way a trace is categorized as valid, invalid, or inconclusive according to a diagram. For example, an assert describes a mandatory behavior, while a negate one that should not happen. Consider and ignore change the set of message names from which valid and invalid traces can be built. \uc3 \u8592\'e2\'86\'90 for property specification\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We selected 13 approaches, listed in Table 2. As the UML 2.0 specification completely changed}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
how Interactions are defined (different semantics, introduction of invalid traces and CombinedFragments, etc.), the table does not contain approaches for UML 1.x Sequence Diagrams}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Conformance-related operators (consider/ignore/neg/assert) \~were not considered in one-third of the approaches. Even if it is one of the most important aspects of the language, it is hard to formalize it and solve its issues. Moreover, consider and ignore were not mentioned in four of the eight, that dealt with conformance.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Gates were handled explicitly in only a small number of papers. \uc3 \u8592\'e2\'86\'90 on the other hand, we handle gates (not detailed in the paper) \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
STAIRS approach is trace-based semantics for SDs. In [3] the authors proposed a technique using Object Constraint Language (OCL) templates to express liveness properties in UML Sequence Diagrams, based on results of LSC [10]. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Using concepts from LSC, several problematic parts of the OMG specification were addressed. May and must behavior, universal, and existential diagrams can be differentiated. In Fig. 2 in [3] the authors give a nice example that certain liveness properties cannot be expressed with assert or negate. Therefore, they propose an after/eventually OCL template, which says that after a condition becomes true there is a guarantee that eventually another condition will become true. Moreover, they introduce global constraints and methods for synchronization at the beginning or end of CombinedFragments.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The authors point out that with the basic interpretation of negative fragments it is easy to construct overspecified Interactions, i.e., an Interaction that can be positively and negatively satisfied from the same trace. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
K\uc2 \u252\'c3\'bcster-Filipe defined a true-concurrent semantics based on event structures in [14]. In [1] the semantics is extended to handle the InteractionUse construct. It considers only a smaller number of operators and constructs (alt, par, seq, and StateInvariant), but gives them a well-defined semantics. The approach constructs for every Lifeline a labeled prime event structure. The model takes into account the possible nesting of CombinedFragments and gives a very clear definition for the predecessors of every event. \uc3 \u8592\'e2\'86\'90 for ppt: I also take into account nested fragments\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In [12] a semantics is given for Sequence Diagrams based on M-nets (multivalued nets), which is an algebra based on high-level Petri nets. The method handles basic data types (Boolean and integers); thus, it can include the local attributes of Interactions, the arguments of Messages, and the evaluation of conditions in the semantics }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The semantics defined in the paper assumes that all behavior is explicitly specified in the diagrams and no conformance-related operator is used \uc3 \u8592\'e2\'86\'90 ppt: same here!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In [15] the authors propose to interpret valid and invalid \~parts of an Interaction as liveness and safety properties, respectively. The Sequence Diagrams are first transformed to hierarchic, non-deterministic automata, then the high-level automata are flattened, and finally liveness B\uc2 \u252\'c3\'bcchi automata are constructed from the positive automata, and safety B\u252\'c3\'bcchi automata from the negative ones. \~\uc3 \u8592\'e2\'86\'90 see how Buchi automata are constructed\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Modal Sequence Diagrams (MSD) [19] are an extension to UML Sequence Diagrams by Harel and Maoz, which adapts LSCs to the notation of UML. LSC is a language inspired from MSC that allows the specification of possible and mandatory scenarios. The authors point out that the root of all the challenges regarding negate and assert are that these were introduced as simple operators, while they are rather modalities. ( have read it: assert and negate revisited)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt: The authors also treat the question how multiple diagrams should be handled, one point that is often missing from others. In the Appendix, a formal semantics based on weak alternating automata is sketched. First, the diagram is transformed into an intermediate format, an unwinding structure, from which the states (the cuts of the diagrams) and the transitions (message sending) of the automaton are derived. The current semantics considers only synchronous messages; the sending and receiving is treated as one event. \uc3 \u8592\'e2\'86\'90 only synchronous messages\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The paper [26] proposes an operational semantics, where an interaction automaton is produced by unwinding the Interaction. One single interaction automaton is created for the entire Interaction. \~(have read it \uc3 \u8220\'e2\'80\'9cModel checking UML 2.0 interactions\u8221\'e2\'80\'9d)\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Later, this interaction automaton is used as an observer process in the SPIN model checker to check the communication produced by UML State Machines. <-- for future work: can I use this automaton created from SDs for properties specification? See what kind of SPIN observer process comes out of it and if you can create an mCRL2 one!}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In [13], the authors propose a translation that produces a Colored Petri Net from UML use cases and Sequence Diagrams. For the basic operators (opt, alt, par, loop, and ref <-- for ppt, I handle those, plus break), templates are assigned to show what kind of CPN fragment should be created. The translation does not consider conformance-related operators. It seems, although it is not stated explicitly in the paper, that each diagram contains initially only one active instance (it can later fork into several executions with a par). Only synchronous messages are handled, because the sending and receiving are represented by the same transition. In [41] a formalization using template semantics is proposed for UML 2 Sequence Diagrams. The formalization is described in more detail in the technical report [42]. The approach gives an operational semantics for which the basic computation model is hierarchical transition systems (HTS). First, the maximal sequence fragments of the diagram are computed, i.e., the maximal sequences of consecutive Messages that do not contain CombinedFragments. }
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Categorizing semantic choices:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
1. Interpretation of a basic \~Interaction: What is a trace? Categorizing traces; Complete or partial traces;}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
2. Introducing Combined-Fragments: combining fragments}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
3. Computing partial orders: Processing the diagram; Underlying formalisms; Choices and predicates}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
4. Introducing Gates: formal and actual gates}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
5. Interpretation of conformance-related operators: assert/negate/ignore/consider; traces being both valid and invalid}
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Because the semantics of an Interaction is defined as the valid and invalid traces produced by the diagram, first the content of a trace has to be specified. However, in a formal semantics, one has to be more explicit, e.g., because there can be several Lifelines in the Interaction sending messages with the same name, it should be specified who sent or received the message. Thus some of the semantics (STAIRS, Cengarle & Knapp, Grosu & Smolka, Template semantics) represents elements of the trace with tuples, e.g., (action, sender, receiver, message name).}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
each OccurrenceSpecification is assigned a unique location name; thus the two receptions of Signal m can be differentiated. The location names are symbolic labels that usually conform to the visual position of the location.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Traces, the receiving events should be matched with the sending event that caused it, which is only possible if each message in the trace can be uniquely identified.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: The UML specification gives the semantics of an Interaction as a set of valid and a set of invalid traces. However, it states that there can be other traces, for which we cannot know whether they are valid or invalid. According to the OMG specification, basic Sequence Diagrams specify complete, potential behaviors, meaning that the traces represented by the Interaction are examples for valid traces, and all the other traces are inconclusive with respect to the given diagram. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Sometimes this interpretation is not convenient, e.g., when one would like to specify requirements [19], safety properties [15] or test purposes [36]. For this reason, two of the semantics use an interpretation with partial traces, i.e., the diagram depicts only parts of the valid traces; other messages can interleave with them to form the complete, valid traces.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Intuitively, interpretations with partial traces amount to filter out the behavior that is irrelevant to the categorization of traces: trace prefix, suffix, or extra interleaving events are ignored and categorization is based on the remaining part of the trace. It turns out that two operators of the UML 2.0 Sequence Diagrams, ignore and its dual operator consider, allow us to further manipulate the set of events appearing in the traces. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The OMG specification defines weak sequencing as the default composition operator for fragments. Accordingly, most semantics retain this operator to compose a CombinedFragment with the rest of the diagram. Due to the weak sequencing, events that do not belong to the same lifeline can occur independently if they are not related by a path of messages. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Figure 9 important for ppt! }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Figure 9 exemplifies this. Message m1 is located above the opt fragment, but there is actually no precedence relation: m1 can occur independently of messages m2 and m3. Similarly, placing something below a CombinedFragment does not necessarily mean that it comes after the messages inside the CombinedFragment. In Fig. 9, there is an ordering constraint between m2 and m3 only because they share lifeline c. If the optional message m2 does not occur, then there is no constraint on m3. For example, trace !m3.!m1.?m1.?m3 is valid. Technically, entering or exiting an operator is not an OccurrenceSpecification.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
As far as we understand the OMG specification, the only OccurrenceSpecifications are (1) sending and receiving of Messages and (2) start and end of an ExecutionSpecification.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
While weak sequencing is the default according to the OMG specification, five semantics we reviewed introduce synchronization on entering and exiting fragments (Cavarra & Filipe, P-UMLaut, Hammal, MSD, CPN). This nonstandard interpretation is usually adopted for work using Sequence Diagrams for verification purposes.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The loop construct has an interpretation that is similar to the one of loops in programming languages.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The UML 2 specification defines the rules for computing the orderings between the OccurrenceSpecification on a simple diagram (see Sect. 2.2.1). This is usually a partial order because there can be independents events in the Interaction. When a diagram contains several CombinedFragments their effects combine. It may result in complex orderings, which are not trivial to calculate. Thus, a significant question about a semantics is how it computes the orderings for an Interaction.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The semantics in the first category parse the diagram and decompose it. The CombinedFragments and the basic fragments in the diagram are identified (St\uc2 \u246\'c3\'b6rrle, P-UMLaut, Hammal, Thread-tag, CPN, Template semantics); some approaches even build a syntax tree from the elements of the diagram based on an abstract syntax (STAIRS, Cengarle & Knapp, Knapp & Wuttke). Usually, the parsing from a diagram\uc3 \u8217\'e2\'80\'99s concrete syntax to this intermediate representation is not given in detail (some rules can be found in [12] or in [41] based on maximal independent sets). After the parsing, the semantics is computed by recursively unfolding the fragments and gluing them together based on rules defined for each of the operators. \u8592\'e2\'86\'90 for ppt: how I do it\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt maybe also: }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The diversity of formalisms in the approaches is the consequence of the diversity of interests for using Sequence Diagrams. Some authors define the semantics to check traces (e.g., Knapp & Wuttke), some to compute all possible traces of a diagram (e.g., St\uc2 \u246\'c3\'b6rrle), some use the semantics to support refinement-based development (e.g., STAIRS), or translate the diagrams into behavior models in order to connect to existing simulation or verification tools (e.g., P-UMLaut). The different purposes can be supported in either one or the other formalism more easily. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The definition of choices and predicates in the OMG specification is very permissive. As will be seen in this section, there are numerous options what and when to choose and who chooses.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
What: An alt offers much more flexibility than an if construct in traditional programming languages would: several of its operands can have implicit true guards, from which one is non-deterministically chosen. Some approaches try to reduce this non-determinism. Cavarra & Filipe prescribe that the operands of the alt are evaluated from top to bottom, and the first one evaluated as true be chosen.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Who: The UML 2 specification does not define who should make the choice between the operands of an alt. This can lead to non-local choices, a problem well studied in MSC [30]. An example for non-local choice can be seen on Fig. 12, where either instance a sends m1 or instance b sends m2, but not both. For semantics working with complete traces, non-local choices raise implementation problems: it may be impossible to implement a system, which shows the valid traces of the diagram. Most of the semantics accept non-local choice as a consequence of having a high-level, powerful specification language. \uc3 \u8592\'e2\'86\'90 LE CRUCIAL THING! ppt: We do not support non-local choices, we think this restriction is reasonable for OO implementation languages! \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
When: With the introduction of synchronization at the beginning and end of CombinedFragments (Sect. 4.2) some approaches specify a common point in time when all Lifelines have to make the choice Thus handling choices is a complex issue. The main approaches used in the different semantics are:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\ulnone\ulc0\animtext0\rtlch \ltrch
\uc3 \u8226\'e2\'80\'a2 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
No explicit time point for the choice: The sets of traces from each operand are computed independently and are combined with the rest of the diagram using the default weak sequencing to obtain all the possible traces of a diagram (St\uc2 \u246\'c3\'b6rrle, STAIRS, Cengarle & Knapp, Thread-tag).\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\ulnone\ulc0\animtext0\rtlch \ltrch
\uc3 \u8226\'e2\'80\'a2 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Explicit time points for the choice on each Lifeline: Lifelines process the diagram separately and choose between operands independently (Cavarra & Filipe, K\uc2 \u252\'c3\'bcster-Filipe, Template semantics). Therefore, each Lifeline could make its choice at different times, but the semantics guarantees that all Lifelines choose the same operand (e.g., by fixing the evaluation order of operands). \uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
we are here ! for ppt}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\ulnone\ulc0\animtext0\rtlch \ltrch
\uc3 \u8226\'e2\'80\'a2 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Explicit global time point for the choice: All involved lifelines synchronize before entering a choice, and only one global choice is made (P-UMLaut, Hammal, Grosu & Smolka, MSD, Knapp & Wuttke, CPN). These approaches typically use an automaton-based formalism, where one transition represents the taken choice for all Lifelines.}
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: There are several options regarding who should evaluate the guard. The evaluation could be local to one Lifeline (STAIRS, K\uc2 \u252\'c3\'bcster-Filipe), all Lifelines could interpret the guard separately (Cavarra & Filipe), or the guard could be evaluated globally (P-UMLaut, Hammal, MSD, Knapp\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
& Wuttke). The latter option is consistent with an explicit global time point for the choice. Lifelines can evaluate the guards at different times, the value of the guard can change in the meantime. The UML 2 specification prescribes that }{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
the guard should be placed on the lifeline where the first}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
event occurrence will occur, positioned above that event, in the containing Interaction or InteractionOperand.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
However, as we mentioned before, \uc3 \u8220\'e2\'80\'9cthe\u8221\'e2\'80\'9d first event in an operand is not well defined With the cfragmentGate type of Gate, messages can cross the boundaries of CombinedFragments (see Figure 14.10 of [33]). Since cfragmentGate is allowed for any operator, it can yield problems.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
As reported by Pickin in [36], this will cause issues with loops.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt: Most of the semantics do not consider cfragmentGates, or disallow it by their redefined abstract syntax (STAIRS, Cengarle & Knapp, Knapp & Wuttke). Our recommendation is also to remove it from the specification or heavily restrict its use, e.g., only to critical regions and co-regions. The other two types of Gates (formal and actual) introduce a convenient facility for expressing complex scenarios: when a diagram includes a reference to another diagram (see Fig. 16), Gates make it possible to model the passing of messages. The referenced diagram has formalGates placed on its boundaries, allowing the representation of messages that come from, or go to, its environment. The environment is determined by the including diagram, where actualGates are placed at the borders of the ref box. Gates are MessageEnds that connect the Messages inside and outside the referenced diagram. \uc3 \u8592\'e2\'86\'90 just highlight those boxes in the metamodel. for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In P-UMLaut the referenced fragments are inlined before processing the Interaction. \uc3 \u8592\'e2\'86\'90 for ppt we do the same\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt also: The interpretation of conformance-related operators (see our classification in Table 1) is a central issue in the definition of the semantics. Many papers about UML 2 Sequence Diagrams deal with this issue (or at least mention it). Indeed, quoting from [35], \uc3 \u8220\'e2\'80\'9c[assert/negate/ignore/consider] constructs open up a veritable pandora\u8217\'e2\'80\'99s box of expressions whose meaning is obscure.\u8221\'e2\'80\'9d We provide here an overview of how the various semantics handle these constructs. Assert and negate allow the specification of mandatory and forbidden behavior. Ignore and consider affect the notion of conformance to a diagram, by changing the alphabet from which the valid and invalid traces are built. They make it possible to account for the sending and receiving of messages not explicitly represented in the diagram. The description of these operators is unclear in the OMG specification, and few semantics address them. For the ones that do, the proposed interpretation depends on whether the semantics works with complete or partial traces.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Up to now, we discussed the interpretation of each conformance-related operator taken in isolation. But in complex diagrams, conformance-related operators can include, or be nested into, other constructs. Let us consider the nesting of conformance-related operators into each other. This raises issues such as the interpretation of multiple assertions, multiple negations, assertions of negations, negation of fragments with considered and ignored messages, and messages that are both ignored and considered. Of course, the semantics dealing with these constructs will assign a precise meaning to such cases. However, the assigned meaning may defeat intuition, with the risk of producing diagrams that users do not properly understand. \uc3 \u8592\'e2\'86\'90 sometimes adding syntactic restrictions helps. Example: NEG should not be used as an ordinary operator, only on complete scenarios to depict a forbidden scenario -> for model-checking!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Ambiguous diagram can be constructed, where a given trace is both valid and invalid. In the example of Fig. 22, this is due to non-determinism. A given event in the trace can be}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
considered as occurring either inside or outside the scope of the conformance-related operator, depending on some nondeterministic choice. Parallel constructs come with similar ambiguities. \uc3 \u8592\'e2\'86\'90 ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
These various examples show that it is extremely difficult to get rid of ambiguous cases. We may put syntactic restrictions to avoid some of the cases (e.g., use only a deterministic if-then-else form of alt constructs, or use neg only at the top level of the diagram), but avoiding all of them by construction would probably require us to sacrifice too much in terms of language expressiveness. Indeed, from our analysis of work dealing with conformance-related operators, all surveyed approaches face cases where a trace can be both valid and invalid. In general, checking whether a diagram is ambiguous is an undecidable problem.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt: Existing scenario languages do not offer concepts to account for the dynamically changing structure and context, nor do they offer constructs to represent broadcast communication in local vicinity. \uc3 \u8592\'e2\'86\'90 SDs are not suitable for, say, mobile networks domain: There are no constructs for broadcast, or dynamically changing context and structure\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
>> checking whether a diagram is ambiguous is an }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
undecidable}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
problem. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The main goal of the language is to check whether an execution trace satisfies a given scenario. In order to fulfil this purpose, the choices were handled according to the following design decisions (Table 8 summarizes them). \uc3 \u8592\'e2\'86\'90 !!!!!!!! I NEED STUFF LIKE THIS IN MY PAPER; Also for PPT: These choices, make them explicit!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt: Due to the variety of usage for scenarios, there is nothing such as \uc3 \u8220\'e2\'80\'9cthe\u8221\'e2\'80\'9d semantics of UML Sequence Diagrams. The OMG group has always insisted on the fact that the standard enables specialization of parts of UML for a particular situation or domain. As regards Sequence Diagrams, it would probably be an impossible task to exhibit an \u8220\'e2\'80\'9call-in-one\u8221\'e2\'80\'9d semantics fitting purposes as diverse as the description of example interactions, of test cases, or of checkable properties. Flexibility to assign different interpretations to diagrams leaves UML practitioners with a difficult problem: the one of\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
selecting a semantics well suited for their purpose. }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
There is a lack of a clear picture of available options.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 \~}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
<-- \~for ppt: ...but if we try to fit our semantic choices, it would probably be a bit of this and a bit of that}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li40\ri0\lin40\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Property specification patterns for finite-state verification}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li40\ri0\lin40\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Awesome! Taxonomy of property specification patterns;}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li40\ri0\lin40\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
obstacle: accurately express requirements that you wish to verify using the specification formalism of the tool}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li40\ri0\lin40\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
patterns tend to generalize experience across multiple specific problem domains; they express \uc3 \u8220\'e2\'80\'9cbest practises\u8221\'e2\'80\'9d in the sw domain\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li40\ri0\lin40\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We propose a pattern-based approach to the presentation, codification and reuse of property specifications for finite-state verification. Finite-state verification refers to a set of techniques for proving properties of finite-state models of computer systems. Properties are typically specified with temporal logics or regular expressions, while systems are specified as finite-state transition systems of some kind. Despite the automation, users of finite-state verification tools still must be able to specify the system requirements in the specification language of the tool. For example...Although the property and the formula are relatively simple, writing the LTL formula requires knowledge of several standard LTL idioms. For example, the property is (implicitly) a safety property, thus the formula begins with the [] operator. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\i0\ul\ulc0\b0\rtlch \ltrch\loch\fs22\loch\f5
A property specification pattern}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
is a generalized description of a commonly-occurring requirement on the permissible state/event sequences in a finite-state model of the system. Describes the essential structure of some aspect of behavior.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
users of those techniques do need to be expert enough to accurately express the requirements they wish to verify in the appropriate specification formalisms. We contend that acquiring this level of expertise represents a substantial obstacle to the adoption of automated finite-state verification techniques and that providing an effective way for practitioners to draw on a large experience base can greatly reduce this obstacle.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Patterns were originally developed to capture recurring solutions to design and coding problems. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Patterns are successful because practitioners want to solve naturally occurring domain problems. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
While there are a number of very expressive formalisms, such as CTL* and the modal mu-calculus, the specifications that are documented in the literature, for example in [l, 6,12,14,24,27], appear relatively simple.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Thus, we believe a collection of simple patterns can be defined to assist practitioners in mapping descriptions of system behavior into their formalism of choice, and that this may improve the}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
transition of these formal methods to practice. A well-defined design pattern has the following characteristics }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
It Solves a Specific Problem, or class of problems, rather than being an abstract principle or strategy.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
It is a Proven Concept that has been demonstrated to be effective in practice.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The Solution isn\uc3 \u8217\'e2\'80\'99t Obvious application of basic principles. and is not a direct application of basic principles\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
It Describes Relationships between solution components rather than isolated components of a solution.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
It is Generative in that it demonstrates how to construct a solution. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Some specification formalisms (e.g., quantified regular expressions (QRE) [25]) are event-based, while others (e.g., various temporal logics, such as LTL and computation tree logic (CTL) [7]) are state-based.}
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Each pattern has a scope, which is the extent of the program execution over which the pattern must hold. There are five basic kinds of scopes: global (the entire program execution), before (the execution up to a given state/event), after (the execution after a given state/event), between (any part of the execution from one given state/event to another given state/event) and after-until (like between but the designated part of the execution continues even if the second state/event does not occur). The scope is determined by specifying a starting and an ending state/event for the pattern. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For state-delimited scopes, the interval in which the property is evaluated is closed at the left and open at the right end. Thus, the scope consists of all states beginning with the starting state and up to but not including the ending state. We chose closed-left open-right scopes because they are relatively easy to encode in specifications and they work for the real property specifications we studied. It is possible, however, to define scopes that are open-left and closed-right as well; we discuss this in Section 7. In event-based formalisms the underlying model does not allow two events to coincide, thus event-delimited scopes are open at both }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ends. Nevertheless, our experience strongly indicates that most informal requirements are specified as properties of program executions or segments of program executions. Thus a pattern system for properties should mirror this view to enhance usability. In event-based formalisms, although it is easy to require that only certain events occur within a scope, the property that a proposition holds throughout the scope would probably be expressed in terms of the appropriate occurrence of an event indicating that the proposition has become true and the absence of an event indicating that it has become false, which does not bear a simple relation to the Absence pattern. Similarly, we note that some formalisms can express conditions involving infinite executions, while others are limited to finite sequences of states or events.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This hierarchy distinguishes properties that deal with the }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
occurrence and ordering}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
of states/events during system execution. It also provides separate patterns for compound properties that are built up from combinations of more basic patterns. While the systems he studies and the meanings of the properties are very different there is significant structural similarity among the specifications in terms of patterns of temporal and logical operators, for example.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Occurrence Patterns include:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Absence: }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A given state/event does not occur within a scope. This pattern is also known as }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Never. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Existence: }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A given state/event must occur within a scope. Known also as }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Future/Eventuality}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Bounded Existence: }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A given state/event must occur k time within a scope. Variants specify at least k occurrences and at most k occurrences of a state/event.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Universality: }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A given state/event occurs throughout a scope. This pattern is also known as }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Globally, Always.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Ordering Patterns include:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Precedence: }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A state/event P must always be preceded by a state/event Q within a scope.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Response: }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A state/event P must always be followed by a state/event Q within a scope. This pattern is also known as }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Follows }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
or }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Leads-to. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
It\uc3 \u8217\'e2\'80\'99s a mixture of \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Existence and Precedence}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
, and expresses a causal relationship between two subject patterns.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Compound Patterns include:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Chain Precedence: }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A sequence of states/events P1,...,Pn must always be preceded bya sequence of states/events Q1,...,Qm. Generalization of the }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Precendence}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
pattern.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Chain Response: }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A sequence of states/events P1,...,Pn must always be followed by a sequence of states/events Q1,...,Qm. -||-}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Boolean Combinations:}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
most patterns delimit scopes and describe inter-scope properties in terms of individual events/states. There are cases where we want to generalize the patterns to allow for sets of states/events to describe scopes and properties. In some cases it\uc3 \u8217\'e2\'80\'99s straightforward and disjunctions or conjunctions of state/event descriptions can be substituted into patterns; These patterns outline how boolean combinations can be applied in different cases.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Related work: }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
There have been some attempts at describing taxonomies for property specifications. The most popular and long-lived of these distinguishes safety and liveness properties [20]. While this provides a very high-level intuitive understanding of classes of specifications, i.e., \uc3 \u8220\'e2\'80\'9cnothing bad will ever happen\u8221\'e2\'80\'9d vs. \u8220\'e2\'80\'9csomething good will eventually happen\u8221\'e2\'80\'9d it is much too coarse to be of practical use in constructing particular specifications. These specifications were derived from informal English language statements of system requirements, which had been refined into a stylized structured English. The specifications were subsequently verified using model-checking. \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Validation is also an important issue. How can the analyst be sure that the specification correctly captures the intended property? }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
There are two aspects to this problem. One is ensuring that the analyst has identified the correct specification pattern. Although we hope that providing very precise prose descriptions and examples of the patterns will minimize the risk of error, this is a difficult problem and one that is really outside the scope of the pattern system per se. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
An Overview of the mCRL2 Toolset and its Recent Advances}
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The mCRL2 language consists of three different sublanguages: a data language, \~a process language, and a property language. \~}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In mCRL2 data and transformations on data are described using abstract data types. This allows users to create their own data types by defining the appropriate constructors and by providing functions operating on the data types. The mCRL2 data language has built-in support for commonly used data types, like the booleans, natural numbers, integers and reals. The usual operations on these data structures are predefined. Complex types can be constructed using type constructors such as sets, lists, and functions over any data type. This permits the modelling of systems whose behaviour crucially depends on the data that is exchanged: actions can be parameterised by data and if-then-else constructs allow for specifying conditional process behaviour. The semantics of processes is defined using a structural operational semantics, which associates with every expression in the language a labelled transition system (LTS). Such a labelled transition system is viewed as a graph consisting of vertices and edges, where each edge is labelled with an action, which in turn can have data parameters. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: Least and greatest fixpoint operators, which may be nested arbitrarily, can be used in combination with modal operators to describe requirements of increasing complexity.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Semantically, expressions in the property language identify a set of states in a given labelled transition system (namely, those states that satisfy the property). }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Although unrestrictive, the \uc2 \u956\'ce\'bc-calculus is an intricate formalism. Its usability is improved by providing a set of powerful, intuitive macros, inspired by the \uc1 }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
regular expressions}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
found in PDL. In many practical situations, }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
this eliminates the need for fixpoint operators}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. <-- maybe ppt?}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The ability to use parameterised actions in the process specification language requires similar capabilities in the property language. Like processes, properties are therefore interpreted in the context of a data specification. \~}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Fixpoint variables and actions can be parameterised with data, boolean expressions may contain data variables, and universal and existential quantification over (possibly infinite) data types are allowed. For example, one may write true to denote the set of all actions, or exists n:Nat.val( n > 5 )&& s(n) to denote the set of s(n) actions, where n>5. The property [ true*. exists n: Nat.val( n > 5 ) && s(n) ]false then expresses that such an action never occurs.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Any analysis on mCRL2 specifications is preceded by an automated transformation of the specification to the linear process format. A linear process is again an mCRL2 process specification adhering to a restricted grammar, which essentially is a syntactic format for the single-step transition relation that a process induces. That is, a linear process is a recursive equation, in the untimed setting. The state space is represented by variable d of sort D. In practice, this is a vector of variables of complex sorts. \~Explicit state spaces can be reduced using behavioural equivalences like strong and branching bisimulation. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Parameterised Boolean Equation Systems (PBESs) or just equation systems, for short, are essentially systems of least and greatest fixpoint equations over predicates involving parameterised predicate variables. \~\uc3 \u8592\'e2\'86\'90 ?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The problem of deciding whether a given property expressed in the \uc2 \u956\'ce\'bc-calculus holds for a given process specification is automatically encoded in an equation system such that the property holds for the specification if and only if the solution to the equation system is true. \~We are primarily interested in the solution of a PBES, as it is also the answer to the encoded problem. \uc3 \u8592\'e2\'86\'90 yes also these PBS counterexample traces are horrible! Solving a PBES typically proceeds by transforming it into an equation system in which all data parameters and data expressions have been eliminated [36]. Such \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
equation systems, which are systems of fixpoint equations over propositions}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
, are called boolean equation systems or }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
BESs}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. In close collaboration with its developers a coupling has been established with LTSmin [6], that enables symbolic and pa}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
rallel state space generation of LPSs.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Recently, an interface has also been added that enables instantiation of equation systems into parity games using LTSmin. As a result, the parallel and symbolic exploration techniques from LTSmin can now also be used to solve PBESs.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
DIRAC: The technology enabling the verification was the symbolic exploration (usingg the equation system interface with LTSmin, see [28]) and solving of the equation systems encodin the model checking problems. This allowed for a full verification of the system in under 60 seconds on a 64 bit Intel Core Duo (1.6GHz) machine with 2 GB RAM. \~For comparison, the model checking problem for a single property required more than 50 hours when conducted using explicit state space generation approaches, exploring well over 1.5 x 10^8 states. Attempts to employ compositional verification, relying on equivalence reductions to minimise state spaces, failed due to the fact that the individual processes that make up the subsystems have infinite state spaces.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For instance, the property that eventually all nodes in the network will keep sending messages according to their schedule was expressed as a \uc2 \u956\'ce\'bc-calculus formula that uses fixpoints parameterised with data variables representing sets, and user-defined functions to specify the schedule. The properties were verified by creating a PBES, expanding it and solving the resulting BES. Solving time for these (large) equation systems was reduced by interpreting the BES as a parity game, reducing that game using a notion of stuttering equivalence tailored to parity games, and then solving the\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
reduced game.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
By formalising the language, that is, by creating an SOS (Structural Operational Semantics) for its syntactic constructs and subsequent application of the semantic transformation, we were able to discover\uc3 \u8212\'e2\'80\'94and improve upon\u8212\'e2\'80\'94sub-optimal design decisions using the mCRL2 toolset. The SOS consisted of 43 deduction rules and resulted in an mCRL2 specification of slightly over 1000 lines of code. The toolset that\u8212\'e2\'80\'94in terms of functionality\u8212\'e2\'80\'94most resembles the mCRL2 toolset is CADP, developed in Grenoble [19]. It uses the specification language Lotos NT, which, like the process language of mCRL2, has its roots in process algebra; it has a property language that is, like the mCRL2 property language, based on a variant of the propositional \uc2 \u956\'ce\'bc-calculus, and, like in the mCRL2 toolkit, verification is conducted using equation systems. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Unlike CADP, mCRL2 can be used to specify and analyse real-time systems. On the other hand, CADP provides features to support performance evaluation, which are lacking in mCRL2. Prominent tools focussing on model checking include SPIN [25] and nuSMV [10]. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The languages supported by these tools have more restricted data types <-- for ppt}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt if you overview other languages/toolsets: (generally booleans or bits, limited range integers and finite arrays). SPIN uses a C-like process specification language Promela for the analysis of parallel programs. It primarily focusses on LTL model checking. Properties can be established by augmenting the specification with assertions and so-called \uc3 \u8216\'e2\'80\'98never claims\u8217\'e2\'80\'99, which are either obtained from LTL formulae or constructed manually. The tool is most famous for its use of partial order reduction and bit hashing technology.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Several toolsets are optimised for verifying specifications with predominantly quantitative aspects. These include real-time and probabilistic model checking, with tools such as Uppaal [4] and Prism [30] The tool Uppaal is based on the notion of timed automata and uses graphs to draw behaviour which can be used to describe timed behaviour. Model checking of a restricted temporal logic is solved elegantly relying on efficient representations and manipulations of time regions. The tool Prism targets discrete and continuous-time Markov chains and decision processes. It supports simulation and model checking of PCTL and CSL. Contrary to the toolsets listed above, LTSmin has no dedicated language. Instead, it provides highly optimised state space generation tools employing multi-core, parallel and symbolic reachability analysers and model checkers, and it is used as back-ends for, e.g., DiVinE, SPIN and mCRL2.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Patterns in Property Specifications for Finite-State Verification}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Perfect for presentation also! [General one!]. 1999 the only study of this kind. Nevertheless, the transition of this technology from research to practice has been slow. While there are a number of potential causes for reluctance to adopt such formal methods, we believe that a primary cause is that practitioners are unfamiliar with specification processes, notations, and strategies. In a recent paper, we proposed a pattern-based approach to the presentation, codification and reuse of property specifications for finite-state verification. Since then, we have carried out a survey of available specifications, collecting over 500 examples of property specifications. We found that most are instances of our proposed patterns. Furthermore, we have updated our pattern system to accommodate new patterns and variations of existing patterns encountered in this survey. Finite-state verification refers to a set of techniques for proving properties of finite-state models of computer systems. Properties are typically specified with temporal logics or regular expressions, while systems are specified as finite-state transition systems of some kind. Finite-state verification techniques are especially critical in the development of concurrent systems, where non-deterministic behavior makes testing especially problematic.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Despite the automation, users of finite-state verification tools still must be able to specify the system requirements in the specification language of the tool. Not only is this formula difficult to read and understand, it is even more difficult to write correctly without some expertise in the idioms of the specification language. We contend that acquiring this level of expertise represents a substantial obstacle to the adoption of automated finite-state verification techniques and that providing an effective way for practitioners to draw on a large experience base can greatly reduce this obstacle.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This system is, essentially, a collection of parameterizable, high-level, formalism-independent specification abstractions. To evaluate our hypothesis, we surveyed all the sources of property specifications we could locate and collected over 500 examples of property specifications for finite-state verification tools. As expected, we found that the vast majority (92%) are instances of patterns in our system. We subsequently updated the pattern system to accommodate new patterns and variations of existing patterns encountered in the survey. For finite-state verification, the system is modeled as a transition system with a finite number of states and a set of transitions, possibly labeled with events, between these states.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A property specification pattern is a generalized description of a commonly occurring requirement on the permissible state/event sequences in such a finite-state model of a system.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A property specification pattern describes the essential structure of some aspect of a system\uc3 \u8217\'e2\'80\'99s behavior and provides expressions of this behavior in a range of common formalisms.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Scope operators are not present in most specification formalisms (interval logics are an exception). Nevertheless, our experience indicates that many informal requirements are specified as properties of segments of program executions. Thus a pattern system for properties should mirror this view to enhance usability.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We note that the various specification formalisms have different semantics and expressive power, and that a property that can be expressed easily in one formalism may be unnatural, or even impossible to capture precisely, in a different formalism. For instance, in state-based formalisms such as LTL or CTL, it is reasonable to specify that a certain proposition hold throughout a scope (the Universality pattern), and to regard this as being in some sense dual to the Absence property stating that a proposition holds at no state in the scope. In event-based formalisms, although it is easy to require that only certain events occur within a scope, the property that a proposition holds throughout the scope }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
would probably be expressed in terms of the appropriate occurrence of an event indicating that the proposition has become true and the absence of an event indicating that it has become false}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
, which does not bear a simple relation to the Absence pattern. Similarly, we note that some formalisms can express conditions involving infinite executions, while others are limited to finite sequences of states or events. Although we expect that, in practice, almost all of the properties to be specified can be expressed in almost all of the commonly used formalisms, the pattern system should point out these differences to the user.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We believe the most useful way to organize the patterns is in a hierarchy based on their semantics. In addition to the patterns themselves, we provide a set of pattern notes, which explain how to combine and/or vary the patterns. For example, pattern templates are typically parameterized by individual events or state formulae. In some cases, however, we can allow patterns of states/events to be substituted into the templates.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For most we had an expression of the requirement in a specific specification formalism (e.g., LTL). For many we also had an informal prose description of the requirement. The specifications came from a wide variety of application domains, including: hardware protocols, communication protocols, GUIs, control systems, abstract data types, avionics, operating systems, distributed object systems, and databases. The specification was a new variant of one of our patterns. We discovered two interesting variants of the Response pattern. The first describes an execution in which S must respond to P and there must be no ZS between the (stimulus) P and the (response) S . The second requires that the response be in the next state/event.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Of the 555 example specifications we collected, 511 (92%) matched one of our patterns.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
As shown in Figure 4, the most common pattern in the sample is Response, with the next most common being Universality and its dual Absence. Together, these three patterns accounted for 80% of the sample. Also, note that almost all examples that used a non-global scope were instances of Absence, Universality, or Existence. These three patterns are conceptually the simplest; for global scopes, they map to single operators of temporal logics.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Traditionally, specification formalisms are presented in terms of a minimal set of operators in order to simplify their semantics definition. Additional operators are then defined in terms of those operators. Our specification pattern system provides a set of commonly occurring high-level specification abstractions for formalisms that do not support the definition of such abstractions directly.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We are currently exploring several directions for further work on specification patterns. We are working to define patterns to simplify writing a class of assume-guarantee properties in CTL. Writing such specifications in LTL is straightforward; in CTL, however, such properties can be quite tricky to express.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Modeling concurrent interactions}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
3.5 True concurrency semantics from Kuster-Filip}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
SD semantics is given using Labelled Event Structures (LES ?) to allow to express distributed computations as event occurrences. Event structures, they claim, are a natural way to capture behavior specified in SDs }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
VERY good for PPT - underlined stuff;}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\i0\ul\ulc0\b0\rtlch \ltrch\loch\fs22\loch\f5
causality}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
and }{\scaps0\caps0\cf1\i0\ul\ulc0\b0\rtlch \ltrch\loch\fs22\loch\f5
conflict}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
are relations over events; from them, }{\scaps0\caps0\cf1\i0\ul\ulc0\b0\rtlch \ltrch\loch\fs22\loch\f5
concurrency}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
is derived as a relation too. SDs model }{\scaps0\caps0\cf1\i0\ul\ulc0\b0\rtlch \ltrch\loch\fs22\loch\f5
possible }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
interactions; liveness properties mean }{\scaps0\caps0\cf1\i0\ul\ulc0\b0\rtlch \ltrch\loch\fs22\loch\f5
necessary }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
interractions. Is assert meant to specify mandatory behavior? Not clear!}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Not all properties can be expressed/verified without considering true concurrency.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In other work we have shown how sequence diagrams combined with an OCL liveness template gives us a much richer language for inter-object behaviour specification. In this paper, we give a semantics of these enriched diagrams using labelled event structures. Further, we show how sequence diagrams can be embedded into a true-concurrent two-level logic interpreted over labelled event structures. The top level logic, called communication logic, is used to describe inter-object specification, whereas the lower level logic, called home logic, describes intra-object behaviour.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
One of the major changes made to UML 2.0 with respect to its previous versions concerns sequence diagrams which have been extended to include a number of features borrowed from message sequence charts (MSCs)}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
[6] and, to a limited extent, live sequence charts (LSCs) [5]. As a consequence, UML\uc3 \u8217\'e2\'80\'99s sequence diagrams are now more expressive and fundamentally better structured. However, there are still several problems with their informal description in the UML 2.0 specification [11]. A major change in sequence diagrams is that interactions can be structured using so-called interaction fragments. There are several possible fragments, for example, alt (alternative behaviour), par (parallel behaviour), neg (forbidden behaviour), assert (mandatory behaviour\u8212\'e2\'80\'94though we will mention some ambiguities in the specification concerning this fragment), and so on. Compared to LSCs, sequence diagrams in UML 2.0 can still not adequately distinguish between mandatory and possible behaviour. For instance, it is still not possible to distinguish between a message that if sent may or must be received, or to enforce progress of an instance along its lifeline. To address this limitation we have proposed in [2] to enrich a sequence diagram with liveness constraints expressed in UML\u8217\'e2\'80\'99s object constraint language (OCL) using an OCL template \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We provide a semantics to UML 2.0 sequence diagrams (as well as liveness enriched sequence diagrams) and on the other hand provide a means for reasoning about the \~specified inter-object behaviour.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We give a semantics to sequence diagrams using labelled event structures [15]. We show how to obtain such a model from a sequence diagram. Event structures allow us to describe distributed computations as event occurrences together with relations for expressing causal dependency (causality) and nondeterminism (conflict). From these relations a further one denoting concurrency can be derived, that is, events not related by causality or conflict are necessarily concurrent. The causality relation implies a partial order among event occurrences, while the conflict relation expresses how the occurrence of certain events excludes the occurrence of others. Essentially, event structures constitute a simple and very natural model to capture the behaviour specified in a sequence diagram.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The interaction captured by a sequence diagram can be specified as a collection of formulae in a true-concurrent two-level logic interpreted over labelled event structures. The top level logic, called communication logic, is used to describe inter-object specification. It can be understood as modelling an observer of the interaction who notices, for example, that whenever a message is sent it is always eventually received, or that certain interactions are happening concurrently. By contrast, the lower level logic, called home logic, describes intra-object behaviour. It can be used to capture local state invariants, interaction constraints, and the interaction from a local perspective. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Graphically, a sequence diagram has two dimensions: an horizontal dimension representing the instances participating in the scenario; and a vertical dimension representing time. Objects have a vertical dashed line called lifeline. The lifeline represents the existence of the instance at a particular time; the order of events along a lifeline is significant denoting, in general, the order in which these events will occur. A message is a communication between two instances which can cause an operation to be invoked, a signal to be raised, an instance to be created or destroyed. Messages are shown as horizontal arrows from the lifeline of one instance to the lifeline of another instance. A message specifies not only the kind of communication between instances, but also the sender and receiver event occurrences associated to it. For an example of a sequence diagram using UML 2.0 constructs see Fig. 1 given in Section 3. UML 2.0 sequence diagrams may contain sub-interactions called interaction fragments which can be structured and combined using interaction operators. There are several possible operators, for example, alt (alternative behaviour), par (parallel behaviour), neg (forbidden behaviour), assert (mandatory behaviour), loop (repeated behaviour), and so}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
on. Depending on the operator used, an interaction fragment consists of one or more operands. In the case of neg, assert and loop the fragment has exactly one operand, whilst for most other operators it has several. The semantics of an interaction fragment with a given operator is described informally in the UML 2.0 superstructure specification [11]. Below we give the meaning of some operators used in this paper according to [11]:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
alt: At most one of the operands will execute (so it could be that }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
none}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
executes)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
par: parallel merge between the behaviors of the operands. The event occurrences of the different operands can be interleaved in any way as long as the ordering imposed by each operand as such is preserved.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
seq: event occurrences on the same lifeline}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
from different operands are ordered such that an event occurrence of the first operand comes before that of the second operand}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
neg: represents traces that are defined to be invalid}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We borrow two concepts introduced in LSCs which are missing in sequence diagrams, but are useful semantically, namely location and temperature. Locations are the points in the lifeline of an instance which correspond to the occurrence of events. Every element in an LSC has a temperature which can be either hot or cold. This is used to distinguish between possible (cold) and mandatory (hot) elements and behaviour. \~Sequence diagrams can only express the possibility that a certain scenario occurs. That is, sequence diagrams model behaviour in the form of possible interactions, i.e. communication patterns that may occur between a set of instances. Furthermore, sequence diagrams, in their current setting, seem to be able to express necessity only to a very limited extent. In particular, it is not clear whether the intention of the new assert operator is to specify mandatory behaviour. The superstructure specification is ambiguous in the definition of this operator, and it is not obvious from the text whether this operator enforces the whole sub-interaction to happen or it is simply \uc3 \u8220\'e2\'80\'9cexpected\u8221\'e2\'80\'9d to happen. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Note, however, that notationally sequence diagrams in UML 2.0 cannot address the dichotomy between must and may behaviour as the notion of temperature as described above does not exist. A lightweight extension of sequence diagrams addressing this has been suggested in [2] using constraints given in an extension of OCL with liveness proposed in [1]. The idea is that by default a sequence diagram only reflects possible behaviour (except for the assert operator) or forbidden behaviour (given by the neg operator). \~It suffices to understand that the OCL liveness constraints change the temperature of associated locations/messages/fragments from cold to hot.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
UML 2.0 provides two kinds of conditions in sequence diagrams, namely interaction constraints and state invariants. An interaction constraint is a boolean expression shown in square brackets covering the lifeline where the first event will occur, positioned above that event inside an interaction operand. A state invariant is a constraint on the state of an instance, for example, on the values of its attributes. The invariant is assumed to be evaluated during run time immediately prior to the execution of the next event occurrence: If it is true the trace is a valid trace; otherwise, the trace is invalid. Notationally, state invariants are shown as a constraint inside a state symbol or in curly brackets, and are placed on a lifeline.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Our semantics is only defined for sequence diagrams which do not contain neg or assert interaction fragments. The reason for this is that there is no real need to use either interaction fragments to indicate forbidden or mandatory behaviour. \uc3 \u8592\'e2\'86\'90 for ppt: same with our work! These are properties that can be expressed outside the model. How do you implement them in an OO language anyways? The system can exhibit or not exhibit a certain behavior. But barely counterparts in implementation languages (other than \u8220\'e2\'80\'9cassert\u8221\'e2\'80\'9d). \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Further, all locations of a particular instance have necessarily different time values (condition (5)), but locations of different instances can still have the same time value. Notice that time here does not necessarily mean occurrence time but visual time according to the diagram. Visual time, or time as given in the diagram, progresses from top to bottom. \uc3 \u8592\'e2\'86\'90 they can still have the same actual time. for ppt: even though visual time says they do not happen at the same instance, occurrence time can in fact be equal. As we have mentioned, in a sequence diagram we may find simple constraints associated to locations, namely interaction constraints or state invariants.\uc1 }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Further, we assume here that these constraints are always local to a particular instance}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. \uc3 \u8592\'e2\'86\'90 for ppt \u8220\'e2\'80\'9csemantics adopted\u8221\'e2\'80\'9d Messages in a sequence diagram cannot cross borders of operands or interaction fragments. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We have given a semantics to sequence diagrams in UML 2.0 based on labelled event structures. The presented semantics given is not complete as we have not considered all interaction fragments permitted in UML (for example strict and loop). Extending the presented model with such fragments is straightforward. \uc3 \u8592\'e2\'86\'90 for ppt!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Firstly, to capture some interaction properties (e.g. forbidden behaviour, liveness properties, state invariants, etc). In this case we can check whether the inter-object behavioural model (a labelled event structure) satisfies the properties. Secondly, to capture the entire interaction of a sequence diagram as a set of formulae. An interesting consequence of this case is that we can verify the sequence diagram against the state-based behavioural model directly through model checking.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In order to achieve the latter, we need to incorporate the concurrent logic into the workbench as it currently only allows verification of modal mu-calculus. Moreover, in order not to lose the true-concurrency aspect of the semantics defined here we need to consider a non-interleaved interpretation of CCS.}
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
...but the semantics given to these approaches differs from ours as they do not, in general, consider concurrent executions or a true-concurrent semantic model. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: A different graphical approach to model sequences of interactions formally is given through specification diagrams [14]. Interestingly, specification diagrams offer most of the new constructs available in UML 2.0 and further provide a formal operational semantics. Liveness and safety properties can also be asserted diagrammatically which makes specification diagrams closer to our combined use of sequence diagrams and OCL constraints. The essential difference in our approach is the true-concurrent semantics. We believe that the semantics given here as well as the embedding onto a true-concurrent logic as ours is novel and offers interesting perspectives concerning synthesis and verification which we will explore in the future. Fundamentally, not all properties for concurrent systems can be expressed and verified without considering true-concurrency.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Formal analysis of sequence diagram with combined fragments (2012)}
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
They claim}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
to preserve the structure of SDs[example: lifelines and combined fragments!] which makes it easier to demonstrate that the semantics of the original notation is maintained.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
They formally describe SDs intu nuSMV -> they also visualize the counterexample}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
somehow similar to our work: there are terms like \uc3 \u8220\'e2\'80\'9cenabled occurrence specification\u8221\'e2\'80\'9d, which are described similar to our busy/ready mCRL2 processes\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for Case Study they refer to a TEchnical Report. maybe read it?}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: Related work section useful! ; }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
alt}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
: they use a global variable to make sure that all lifelines execute the same operand.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We introduce an approach to formally describe Sequence Diagrams with Combined Fragments in terms of the input language of the model checker NuSMV. Scenario-based models have been widely employed for the description of interactions among environmental actors (e.g., human beings) and the components (aka Lifeline) of the software systems through the exchange of messages. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The semantics of Sequence Diagram with Combined Fragments is not formally defined compared to their precise syntax descriptions (Object Management Group, 2011), making it is hard to derive the traces from Sequence Diagrams. Thus, subtle errors from concurrency can easily be introduced to Sequence Diagrams to evade discovery via manual inspection. for ppt: Our approach supports all the features of Combined Fragments, including all 12 Interaction Operators, nested Combined Fragments, both asynchronous and synchronous Messages, and Interaction Constraints.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt: }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We devise an approach to codify the semantics of Sequence Diagrams and Combined Fragments in the input language of NuSMV by deconstructing Sequence Diagrams and Combined Fragments to obtain fine-grained syntactic constructs (see section 2 and 3). We formally describe each Combined Fragment in terms of NuSMV (Cimatti et al., 2000) modules \uc3 \u8592\'e2\'86\'90 for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: We have also created an Occurrence Specification Trace Diagram generator that automatically produces Sequence Diagram visualizations from NuSMV-produced counterexamples. This automation will increase the accessibility of our approach by allowing software engineers to remain focused in the realm of Sequence Diagrams.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Messages are of two types: asynchronous and synchronous. The source Lifeline can continue to send or receive other Messages after an asynchronous Message is sent. If a synchronous Message is sent, the source Lifeline blocks until it receives the target Lifeline\uc3 \u8217\'e2\'80\'99s response. The semantics of the seq Sequence Diagram is defined by two sets of traces, one containing a set of valid traces, denoted as Val(seq), and the other containing a set of invalid traces, denoted as Inval(seq). The intersection of these two sets is empty.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt: In this section, we develop techniques to translate Sequence Diagrams into the input language of NuSMV. The NuSMV model preserves the structure of the Sequence Diagrams (e.g., Lifelines and CFs), which makes it easier to demonstrate that the semantics of the original notation is maintained. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We base the mapping of a Sequence Diagram to the input language of NuSMV on syntactic deconstruction. A Sequence Diagram is represented as the main module. We map the Lifelines into respective NuSMV modules, which are instantiated and declared in the main module. Recall that a CF is projected onto each of its covered Lifelines to obtain a CEU. Accord-}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ingly, its Operand on each of the covered Lifelines forms an EU. Both CEUs and EUs are represented as NuSMV modules. \uc3 \u8592\'e2\'86\'90 DAFUQ\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In the case that a Sequence Diagram contains nested CFs (i.e., a CEU consisting of an EU that encloses other CEUs), we map each enclosed CEU as a submodule of the containing EU\uc3 \u8217\'e2\'80\'99s module. This procedure is recursively applied until all CEUs and EUs are mapped accordingly.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt: use this to explain the algorithm of ready vs busy processes: To express the interleaving semantics among Lifelines, we introduce an INVAR statement in the main module to assert that at most one OS on one of the Lifelines can take place in each step (the semantic rule 4). A boolean variable chosen is used for each Lifeline to restrict that: (1) a Lifeline is chosen only if it is enabled, i.e., there is an OS that is ready to take place on the Lifeline, represented by the derived variable enabled; (2) either only one Lifeline can be chosen to execute an OS in each step if Lifelines are enabled (i.e., before all OSs on the Lifelines have occurred); or no Lifeline can be chosen when all Lifelines are not enabled and all chosen variables remain False thereafter. A sending OS is enabled to execute if and only if the OSs prior to it on the same Lifeline have already occurred. A receiving OS is enabled to execute if and only if the OSs prior to it on the same Lifeline and the sending OS of the same Message have already occurred (the semantic rules 2 and 3). To execute the OSs enclosed in CFs, the variable chosen for each Lifeline is passed to the CEU and EU modules on that Lifeline as a parameter.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Collectively, we call Alternatives, Option, and Break branching constructs. \~\uc3 \u8592\'e2\'86\'90 opt and BREAK are syntactic sugar; In an Alternatives CF, each Operand must have an explicit or an implicit or an \u8220\'e2\'80\'9celse\u8221\'e2\'80\'9d Constraint. An implicit Constraint always evaluates to True. The \u8220\'e2\'80\'9celse\u8221\'e2\'80\'9d Constraint is the negation of the disjunction of all other Constraints in the enclosing Alternatives. The chosen Operand\u8217\'e2\'80\'99s Constraint must evaluate to True. If none of the Operands whose Constraints evaluate to True, the Alternatives is excluded The use of exe guarantees that all the enclosed Lifelines choose the same Operand\u8217\'e2\'80\'99s EU module to execute to avoid inconsistent choices (e.g., Lifeline L1 chooses Operand 1\u8217\'e2\'80\'99s EU whereas Lifeline L2 chooses Operand 2\u8217\'e2\'80\'99s EU). \u8592\'e2\'86\'90 global variable, not nice!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
: We need to evaluate the Interaction Constraint of its sole Operand after minimum number of iterations. If n \uc3 \u8804\'e2\'89\'a4 minint, the Loop executes. If minint < n \u8804\'e2\'89\'a4 maxint, the Loop executes only if cond[n] evaluates to True. \~\u8592\'e2\'86\'90 we haven\u8217\'e2\'80\'99t implemented this An Assertion represents that, on each Lifeline, a set of traces of its Operand are the only valid traces following the Assertion\u8217\'e2\'80\'99s preceding OSs. The semantics of a Weak Sequencing enforces the total order among EUs of Operands on the same Lifeline. In any EU module of an Operand (except the first one), the first OS takes the variable flag_final of the EU of the preceding Operand on the same Lifeline as an enabling condition, i.e., the EU cannot execute before the preceding one completes.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt: The Sequence Diagram Translation tool takes the XML representation as input, parses it into a syntax tree, and transforms it into a NuSMV model. NuSMV model checker takes as input the generated NuSMV model and a temporal logic formula that is specified by the software engineer. \uc3 \u8592\'e2\'86\'90 temporal logic formula specified by the software designer? LOL!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt: The output from the OSTDG is an easy-to-read Sequence Diagram visualization of the counterexample to help the software engineer locate the property violation faster. Thus, the software engineer may transparently verify a Sequence Diagrams using NuSMV, staying solely within the notation realm of Sequence Diagrams. We check the example on a Linux machine with a 3.00GHz, 8 cores CPU and 32GB of RAM. One ex-}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ample executed in 19 minutes 49 seconds with 3,825 reachable states out of total 3.71e+012 states, while the other example executed in 18 minutes 14 seconds with 192 reachable states out of total 4.95e+012 states. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt: Related work, excellent overview: To the best of our knowledge, our technique is the first to support all CFs and the nested CFs. Lima et al. provide a tool to translate UML 2 Sequence Diagrams into PROMELA-based models and verify using SPIN, with counterexample visualizations (Lima et al., 2009). Their translation does not support Critical Region, Strict Sequencing, Negative, Assertion, Consider, Ignore, synchronous Messages and Interaction Constraint. Van Amstel et al. present four complementary approaches for analyzing UML 1.5 Sequence Diagrams, which do not support CFs (van Amstel et al., 2007). They model check Sequence Diagrams using SPIN. Alawneh et al. introduce a unified paradigm to verify and validate prominent UML 2 diagrams, including Sequence Diagrams, using NuSMV (Alawneh et al., 2006). Their approach supports Alternatives and Parallel.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To model check MSCs, Alur et al. (Alur and Yannakakis, 1999; Alur et al., 2005) formalize MSC using automata. They examine different cases of MSC verification of temporal properties and present techniques for iteratively specifying requirements (Alur et al., 2003). They focus on MSC Graph, which is an aggregation of MSCs. We extend their work to encompass more complicated aggregations using CFs. Peled et al. perform intensive research on the verification of MSCs (Muscholl et al., 1998; Gunter et al., 2001), in particular, they present an extension of the High-Level MSC (Peled, 2000). They specify MSC properties in temporal logic and check for safety and liveness properties. Leue et al. translate the MSC specification, especially branching and iteration of High-Level MSC, into PROMELA to verify MSCs using the XSPIN tool (Leue and Ladkin, 1996). As Sequence Diagrams have similar expressive features, our technique can be extended to work with their approach. Kugler et al. improve the technique of smart play-out, which is used to model check LSCs to avoid violations over computations (Kugler et al., 2009). Walkinshaw and Bogdanov (Walkinshaw and Bogdanov, 2008) detail an inference technique to constrain a finite-state model with LTL. These constraints reduce the number of traces required as input to a model checker for discovery of safety counter examples. Our work can automatically model check each Sequence Diagram of a system against LTL properties separately, which helps to alleviate the state explosion problem.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Temporal logic for Scenario-based specifications}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Semantics of LSC [ Live Sequence Charts] provided, by translating it to temporal logic (well, subsets of it)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Paper addresses the relationship between scenario-based requirements and temporal logic They claim the approach is good enough to be applied to other scenario-based languages. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Conditions on messages are very unintuitive, almost nonsense; example: conditions can be globally shared among instances; }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
LSC is lacking many UML features, paper old! (2005)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Quite understandable first steps towards formalisation of LSC [use them for mCRL2]}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Unbounded loops: performed an apriori unknown number of times [recursion ? howto?]}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
One of the most widely used languages for specifying scenario-based requirements is that of message sequence charts (MSCs), adopted long ago by the ITU [26], or its UML variant, sequence diagrams [25]. This paper addresses the relationship between scenario-based requirements and temporal logic [23]. As a scenario based language we focus on the language of live sequence charts (LSCs) [7] which is a powerful extension of classical message sequence charts.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
LSCs distinguish between behaviors that may happen in the system (existential) from those that must happen (universal). We show how the semantics of live sequence charts can be captured using temporal logics.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We assume the LSC specification relates to an object system composed of a set of objects O = \{O1 . . . On \}. An object system corresponds to an implementation, and our goal while providing semantics for LSCs is to define if a given object system satisfies an LSC specification. The instance identifiers in the LSC charts are objects from O, and possibly also the environment denoted env. The LSC specifies the behavior of the system in terms of the message communication between the objects in the system. We want to define the notion of satisfiability of an LSC specification. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
What follows are good ideas for formalisation, but formulas cannot be copy/pasted here }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: we assume SDs are well formed.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The activation message of a chart designates when a scenario described by the chart should start \uc3 \u8592\'e2\'86\'90 for ppt: activation object.message in AD? \~The formula requires that the activation message is sent once (wi0 = f (amsg(m))), and then the trace satisfies the chart;\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We assume also that a message does not appear more than once in the same chart.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\ulnone\ulc0\animtext0\rtlch \ltrch
\uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
well, actually a bad assumption}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The logic CTL is a restricted subset of CTL\uc3 \u8727\'e2\'88\'97 . In CTL the temporal operators G, F, X and U must be immediately preceded by a path quantifier. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The LSC language allows using conditions, which are assertions on the variables of the system. Variables may be local to an instance or globally known. Conditions can come in two flavors: mandatory (hot) and provisional (cold). If a system run encounters a false mandatory condition the run aborts abnormally, while a false provisional condition induces a normal exit from the enclosing charts. Conditions can also be shared by several instances, forming a synchronization barrier.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt: inspiration future work:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The verification is based on translating an LSC chart into a timed Buchi automaton, as described in [19], and it also handles timing issues. Standard translations from B \uc2 \u776\'cc\'88chi automata to temporal logic can then be applied. \uc3 \u8592\'e2\'86\'90 Buchi automata based interpretation of Sequence Diagrams, this is my \u8220\'e2\'80\'9cmonitoring\u8221\'e2\'80\'9d process.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A Scenario Based Notation for Specifying Temporal Properties}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
! A chain is different from as sequence of messages because repetitions of the same message before the next element of the chain are not allowed}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Survey of the strengths of MSC [Message Sequence Charts] and UML2 SDs, proposes something better, which they both lack}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
They propose an extension of a subset of UML2 Sequence Diagrams}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
property is a relation on a set of exchanged system messages \uc3 \u8592\'e2\'86\'90 ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
VERY IMPORTANT AS INSPIRATION}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
it is known that LTL formula can be converted to Buchi automaton which is then used by model-checkers \uc3 \u8592\'e2\'86\'90 ppt? \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
they only deal with CTL in the paper; they measure their approach agianst the 1999 paper on patterns in property specification }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
UML no formal semantics \uc3 \u8594\'e2\'86\'92 not clear what happens when nesting NEG and ASSERT. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: we are not concerned with realtime systems so we abstract from absolute time;}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
chain constraints on message labels: what can happen before, after, and during a message exchange \uc3 \u8592\'e2\'86\'90 cause & effect\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
partial ordering in SDs is by default; strict ordering with operator STRICT}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
only the act of sending and receiving are considered to be atomic \uc3 \u8592\'e2\'86\'90 in synchronous communication they happen simultaneously;\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
message label prefixed with sender, postfixed with receiver}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
upper and lower number of repetitions in a loop \uc3 \u8592\'e2\'86\'90 useful for \u8220\'e2\'80\'9cat most/least k times\u8221\'e2\'80\'9d\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
So why not use these as attributes of messages? They do here!}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Temporal logics are commonly used for reasoning about concurrent systems. Model checkers and other finite-state verification techniques allow for automated checking of system model compliance to given temporal properties. These properties are typically specified as linear-time formulae in temporal logics. Unfortunately, the level of inherent sophistication required by these formalisms too often represents an impediment to move these techniques from \uc3 \u8220\'e2\'80\'9cresearch theory\u8221\'e2\'80\'9d to \u8220\'e2\'80\'9cindustry practice\u8221\'e2\'80\'9d. The objective of this work is to facilitate the non trivial and error prone task of specifying, correctly and without expertise, temporal properties.\uc1 }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Properties that are simply captured within the context of interest and that are easily described by natural language may result very hard to specify in LTL. In other words, there is a substantial gap between natural language and the LTL syntax.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Although in this paper we focus on formulae expressed in LTL notation, other similar formalisms (such as CT L, ACTL) suffer the same problems.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The main problems of the latter approaches is in balancing the expressive power and the simplicity of the graphical property description language}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. GIL [7] is sufficiently expressive but lacks in user friendliness. For example, GIL achieves expressive power by allowing nesting but its formulae become potentially difficult to understand. This difficulty comes from the fact that its graphical notation is too close to temporal logic. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Based on these considerations, we believe that an accurate analysis is necessary in order to understand what is required in a formalism to express a \uc3 \u8220\'e2\'80\'9cuseful set\u8221\'e2\'80\'9d of temporal properties (e.g., the set of the property specification patterns [8]) while keeping in mind that easy use and simplicity are mandatory requirements to make a formalism adopted\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
by industries. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We focus on the graphical formalisms for scenario-based specification that are commonly and extensively used within industrial software development practice: Message Sequence Charts (MSCs) [12], and UML 2.0 Interaction Sequence Diagrams. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Within our PSC language, a property is seen as a relation on a set of exchanged system messages, with zero or more constraints. Our language may be used to describe both positive scenarios (i.e., the \uc3 \u8220\'e2\'80\'9cdesired\u8221\'e2\'80\'9d ones) and negative scenarios (i.e., the \u8220\'e2\'80\'9cunwanted\u8221\'e2\'80\'9d ones) for specifying interactions among the components of a system. For positive scenarios, we can specify both mandatory and provisional behaviors. In other words, it is possible to specify that the run of the system must or may continue to complete the\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
described interaction.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The main goal of this work is to propose a scenario-based visual language for specifying temporal properties which balances expressive power and simplicity of use.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In other words it is not possible to clearly distinguish between mandatory messages and provisional ones. Furthermore, since MSCs can only represent desired exchanging of messages (i.e., positive scenarios), it can only be possible to define a set of liveness property to stipulate that \uc3 \u8220\'e2\'80\'9cgood things\u8221\'e2\'80\'9d do (eventually) happen during the execution of a system. On the contrary, often, it is necessary to express forbidden scenarios (i.e., negative ones) to specify safety properties which stipulate that \u8220\'e2\'80\'9cbad things\u8221\'e2\'80\'9d do not happen during execution of a system;\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
PSC: Property Sequence Chart.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Table1 important! \uc3 \u8592\'e2\'86\'90 comparison between PSC, UML2.0 SDs and MSC\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In order to identify the sender and the receiver components, the labels for intraMSGs are prefixed by the name of the sender component and postfixed by the name of the receiver component. For example, the label Ci .l.Cj denotes the message labeled by l sent from the component Ci to the component Cj . }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Regular messages: the labels of such messages are prefixed by \uc3 \u8220\'e2\'80\'9ce:\u8221\'e2\'80\'9d. They denote messages that constitute the precondition for a desired (or an undesired) behavior. It is not mandatory for the system to exchange a Regular message, however, if it happens the precondition for the continuations has been verified. This kind of messages can be mapped into UML 2.0 and MSC provisional messages (i.e., non mandatory messages graphically represented by simple arrows). Required messages: are identified by \u8220\'e2\'80\'9cr:\u8221\'e2\'80\'9d prefixed to the labels. It is mandatory for the system to exchange this type of messages. By means of these messages we can specify liveness properties. Required messages have the same meaning of UML 2.0 assert messages that are used to identify the only valid continuations. All the other continuations result in an invalid trace. No similar kinds of messages exist in the MSC specification.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Fail messages: the labels are prefixed by \uc3 \u8220\'e2\'80\'9cf:\u8221\'e2\'80\'9d. They identify messages that should never be exchanged. Fail messages are used to express undesired behaviors and hence safety properties. UML 2.0 neg operator expresses the same notion. In fact, the operator neg is used to represent invalid traces.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For both boolean formulae and chains, past constraints are placed near to the message arrow source. On the contrary future constraints are placed near to the arrow target. \uc3 \u8592\'e2\'86\'90 nonsense, cluttered?!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
There is no direct mapping for the complement of a message in MSC and UML 2.0. It is}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
possible to indirectly express this concept by encapsulating each message in the complement set of a given message into the alt operator of both MSC and UML 2.0. For systems with a high number of exchanged messages, this can be tedious or unfeasible.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt and paper: In Figure 1 we can see that, parallel, loop, and simultaneous operators are introduced with a UML 2.0 like graphical notation. As previously mentioned, the UML 2.0 standard has not a well defined semantics. Thus, it is not clear whether having the power of recursion is a good thing in the first place, since it introduces an extra level of complexity into any semantics by implying fixed points. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Informally, the parallel operator allows a parallel merge between the behaviors of the two operands. The messages arguments of the operands can be interleaved in any way as long as the ordering imposed by each operand as such is preserved. The loop operator allows the operand to be repeated a given number of times. As it is shown in Figure 1, it is also possible to specify a lower and an upper number of repetitions.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The PSC operational semantics is given in terms of Buchi Automata [3] that are an operational representation for LTL formulae. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt: We recall that the automata-based model checking uses automata for both representing the system and the property. More precisely the model checker requires having the complement of the languages recognized by the automaton of the property. Since it is an expensive task to negate a Buchi automaton, we directly express in the Buchi automaton the negation of the desired temporal property.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
More precisely, Psc2Ba can graphically express a useful set of both liveness and safety properties (from evaluation section) }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
FOR FUTURE WORK INSPIRATION!!: Below, how to evaluate!}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In order to better validate the expressivity of the PSC language we refer to the specification patterns system introduced by the Kansas State University [8]. Dwyer et al. define a repository with the intent of collecting patterns that commonly occur in the specification of concurrent and reactive systems. The patterns are defined for various logics and specification formalisms and we refer to the mappings for property patterns in LTL. A specification pattern has a scope that defines the range in which the pattern must hold; for example while global means that the pattern must hold everywhere, between q and r means that the pattern must hold from the first occurrence of q to the first occurrence of r only and only if r happens.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We are able to represent in PSC all the defined patterns [20]. Similarly to what done in the specification patterns system, in PSC a scope can be represented once and instantiated for each pattern. See the PSC web page [20] for a description of all patterns.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The translation algorithm proposed by Ghezzi et al. [25] gets in input a LSC and produces an automaton and a LTL formula, both necessary to express the correct temporal properties. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The automaton and the LTL formula are translated into Promela code that, introduced into the proposed process, allow for the verification of systems. The paper [14] proposes a translation into CTL* while the work [13] offers a solution for timed Buchi automata generation. Other approaches [4, 15, 1] define graphical languages that appeared to be not easily comprehensible and not easily integrable into industrial software development processes.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Pattern Based Property Specification and Verification for Service Composition}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
It builds on the 1999 property-pattern system by alowing nesting and composition into more complex requirements; it refines and extends the original pattern system they propose pattern-specification language, and represent its semantics as FSMs. Great summary of the 1999 paper. The semantics of pattern properties may be given in LTL, CTL, QRE or FSA.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
FSA semantics of example property pattern;}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
composite pattern: by connecting pattern properties using boolean operators (connectors?) given: every }{\scaps0\caps0\cf1\i0\ul\ulc0\b0\rtlch \ltrch\loch\fs22\loch\f5
elementary}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
pattern property has a FSM semantics. The verification example they give is really a toy.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A rigorous compliance checking approach usually needs the requirements being specified in property specification formalisms such as temporal logics, which are difficult}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ordinary software practitioners to comprehend. In this paper, we propose a property pattern based specification language, named PROPOLS, and use it to verify BPEL service composition schemas. PROPOLS is easy to understand and use, yet is formally based. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
It builds on Dwyer et al.\uc3 \u8217\'e2\'80\'99s property pattern system and extends it with the logical composition of patterns to accommodate the specification of complex requirements. PROPOLS is encoded in an ontology language, OWL, to facilitate the sharing and reuse of domain knowledge. A Finite State Automata based framework for verifying BPEL schemas against PROPOLS properties is also discussed.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Model checking [5] is a formal approach to software behavioral compliance checking. In this approach, a software application is abstracted as a formal model like Labeled Transition Systems (LTS), Finite State Automata (FSA), Petri nets, or process algebra. The behavioral requirements are specified as properties in formalisms such as Linear Temporal Logic (LTL), Computation Tree Logic (CTL), or Quantified Regular Expressions (QRE). Then the formal model can be verified against the specified requirements/properties through exhaustive state space xploration. A serious problem, however, prevents the wide adoption of this approach. That is, the formal properties are surprisingly difficult to write for practitioners, who usually don\uc3 \u8217\'e2\'80\'99t have solid mathematical backgrounds. \u8592\'e2\'86\'90 well, that and state-space explosion?!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
good for future paper:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The property patterns enable people who are not experts in temporal logics to read and write formal specifications with ease and thus make model checking tools more accessible to common software practitioners [8]. Although it is claimed in [6] that patterns can be nested, no further work has been done on how to define composite patterns and what are their semantics. PROPOLS refines/extends the original pattern system in [6] by introducing the logical composition of patterns. This mechanism enables the definition of complex requirements in terms of property patterns, which is previously difficult or even impossible. PROPOLS uses the Web Ontology Language (OWL) as its base language. This makes PROPOLS properties sharable and reusable within/across application domains.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Representing the semantics of PROPOLS properties as FSAs, representing the semantics of a BPEL schema as a LTS/FSA using Foster\uc3 \u8217\'e2\'80\'99s BPEL2LTS tool [9], and checking the language inclusion between these two FSAs. Property specification patterns were first proposed by Dwyer et al in [6]. These patterns include a set of commonly occurring high-level specification abstractions for formalisms like LTL, CTL or QRE.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A pattern property specification consists of a pattern and a scope. The pattern specifies what must occur and the scope specifies when the pattern must hold. Patterns are classified into occurrence patterns and order patterns. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Occurrence and order - one dimension; scope - another dimension. Basically time is one dimension, and frequency is another (sort of)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Figure 1 important; but yeah, \uc3 \u8220\'e2\'80\'9cglobally\u8221\'e2\'80\'9d properties are easy with FSM. How about other categories?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Every pattern (whether order or occurrence has a scope)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We may write a composite}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
pattern connected with the \uc3 \u8216\'e2\'80\'98And\u8217\'e2\'80\'99 operator:\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Customer.GetOrderFulfilled Precedes Bank.Transfer Globally}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
And}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Customer.GetOrderFulfilled LeadsTo Bank.Transfer Globally}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this situation, both \uc3 \u8216\'e2\'80\'98GetOrderFulfilled\u8217\'e2\'80\'99 and \u8216\'e2\'80\'98Transfer\u8217\'e2\'80\'99 should occur and must occur sequentially in the program. As stated earlier, every elementary pattern property has a corresponding FSA semantics. We thus define the semantics of a composite pattern property from the logical composition of FSAs of its component pattern properties The language set that can be accepted by a composite FSA is the composition of the language set of the component elementary FSAs. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
NICEST explanation of a monitoring process \uc3 \u8592\'e2\'86\'90 for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
As shown in Fig. 8, the verification is conducted in 3 steps. (1) For every pattern property, a semantic equivalent Total and Deterministic FSA (TDFA) is built. If the property is a composite one, the corresponding TDFA is constructed by composing the TDFAs of its sub-properties according to the composition semantics definition in section 4.2. (2) For the BPEL schema, a finite and deterministic LTS model is generated, from which a TDFA is built by introducing the set of final states and an error state to collect all the unacceptable events (or operation invocations) of each state. (3) The compliance of the BPEL schema to the PROPOLS properties is then checked as a verification problem of whether the accepting event sequences of the BPEL TDFA are all present in the accepting event sequence set of the property TDFA. This is done by testing the emptiness of the intersection of the BPEL TDFA and the complement of the property TDFA. The most significant difference between these approaches and our work is that we focus on a practitioner-oriented approach to property specification.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Debugging UML Designs with Model Checking (2002!)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For future work: nesting of temporal operators can increase the complexity of verification and decrease the confidence in the meaning of the formula}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
general correctness properties: non-reachable code, absence of deadlocks, arithmetic errors \uc3 \u8592\'e2\'86\'90 they don\u8217\'e2\'80\'99t require explicit formulas\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
very informal, probably good for ppt; good definition of a monitoring process automaton}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
some very good stuff underlined;}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
very intuitive non-technical explanation of overapproximation/underapproximation and which properties are suitable. Just what I need for extending the CCGrid paper with \uc3 \u8220\'e2\'80\'9c+\u8221\'e2\'80\'9d explanation of abstractions by nondeterminism.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Alternative way to SDs is to consider }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
OCL as a property language!}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: Although this technique is successfully applied to many formal description techniques, it is not commonly used by the object oriented programming community, in general, nor by UML developers, in particular. In this paper, we provide a comprehensive overview and rules to integrate model checking into UML-based designs, showing its usefulness from a practical point of view}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: Model Checking represents one of the most useful results of almost thirty years of research in formal methods to increase the quality of software and other related systems. A model checker is an automatic tool that is able to compare two descriptions of the behavior of a given system. Usually, one description is considered as the requirements and the other one as the actual design of a system to meet these requirements. The main constraint is that the description of thedesign, usually called the model, must be executable. This executability makes it possible to perform an analysis of all the execution paths (exhaustive analysis). The main usefulness of model checking is its capability to produce a counter-example, or sequence of steps in the model, leading to the violation of a particular property. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Unified Modeling Language (UML) provides a wide range of notations to model a software system from different perspectives, organizing them in five interrelated views: design view, process view, implementation view, deployment view, and use case view.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for future work, for ppt also?: However, it is more complex to detect when a dynamic behavior described by several state diagrams corresponds to an acceptable scenario. Our aim in this work is to show how a very well known technique (i.e. model checking) can be applied to overcome the lack of tools to support exhaustive analysis of diagrams describing dynamic behavior of UML models, specially when modeling concurrent systems with UML. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
the program can be encoded with formalisms very similar to programming languages, and some current tools can even work with the final code. The verification task consists in ensuring that all, some or no execution paths, in the current design for the software, satisfy a particular (desirable/undesirable) property. This task is carried out automatically by generating and analyzing all the potential (finite)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
states of the program (exhaustive analysis). The structure is obtained by executing all potential interleavings of the concurrent program. Modern model checking tools work by translating the formula into an automaton to recognize the correct/incorrect execution paths. As the verification is performed as soon as the states are produced (and stored), the method does not require the previous construction of the whole state graph. This is why it is called on-the-fly model checking.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The success of model checking to debug models of concurrent software (writing the models in academic formal description techniques and properties with temporal logic) has made this term relatively popular to describe other verification methods such as: 1) the automatic analysis of general correctness properties of concurrent systems that do not require a particular representation with a property language (absence of deadlock, non-reachable code, arithmetic errors, etc), 2) the automatic verification of more commercial formal description techniques (for example SDL) }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Nice overview of the type of UML views}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To cover all these possibilities, UML includes structural (class, object, component, deployment) and behavioral (use case, sequence, collaboration, state, activity) \~iagrams. All these diagrams are distributed in the so-called views, giving five different perspectives of the same model, all of them organized around use cases. Dynamic behavior is captured by four different kinds of diagrams: sequence diagrams, interaction diagrams, state diagrams, and activity diagrams. \~}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Our idea is to apply model checking to compare the behavior described by a sequence diagram (or a collaboration diagram) with the behavior expressed by a set}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
of state diagrams. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt: If we consider that state and sequence diagrams are the two most representative notations to describe the dynamic behavior of a system, then three main phases have to be covered to apply model checking. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
As model checking works automatically, the Most of UML-based tools include some possibilities of consistency analysis and automatic system to be analyzed must be closed with respect to the environment. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The automaton evolves synchronized with the system being debugged, observing events in the statecharts, and when it reaches a final state (the last event in the sequence diagram), then the property is verified. Of course, the automaton is never accessible to the user, and the verification tool must keep it hidden, but it allows extending the basic verification method in Phase 1 to deal with the sequence diagram verification.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Partial order reduction is a method for replacing several interleaved sequences of events (or actions) by only one that represents the whole set. The State compression method reduces the use of memory by compressing the representation of the states without losing information, but increasing the verification time.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In general, abstracting the model of a system means to construct a simpler specification which is equivalent to the initial one with respect to the properties to be verified. The abstract model can be verified using less time and memory.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The most powerful abstraction of statecharts to verify sequence diagrams is the abstraction of events. This kind of abstraction consists in using a single name of event (an abstract event) to represent a set of real events. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
How to know if button is representing play or load to fire the correct transition? We need to introduce non-determinism in order to preserve at least the same potential execution sequences as in the initial statechart. This is a key point to obtain useful verification results !!!! \uc3 \u8592\'e2\'86\'90 THIS IS THE IDEA BEHIND THE CCGrid paper guidelines\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The verification of undesired one in Figure 8 (left). It is worth noting that the never produces a sequence like thebehaviors (Phase 3) is done directly: If M* does not verify SD\uc3 \u8727\'e2\'88\'97, then M does not verify SD. \~\u8592\'e2\'86\'90 overapproximation: if it\u8217\'e2\'80\'99s absent in the M* which contains more behavior than M, then it\u8217\'e2\'80\'99s absent in M too!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
However, the loss of precision in the events and the addition of non-determinism in the statecharts make the verification of desirable behaviors (Phase 2) a more demanding task. One abstract event represents a set of real events, so the occurrence of the abstract event is not conclusive to decide about the occurrence of the real one \uc3 \u8592\'e2\'86\'90 overapproximation is good for absence, but not for proving presence of good traces. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The same problem appears when the tool reports an error in the verification of undesirable properties. In both cases, we have to use the abstract trace in order to check whether a particular sequence of events represented by this one, is possible in the initial model. If the sequence exists in M, then we have information to give a result regarding the behavior of M. Otherwise, we have to revise the abstraction. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
But, even if the scenarios were formalized (e. g. as sequence diagrams) the construction of the whole use-case tree (as a graphical view of the system) limits the possibilities for automatic verification for two reasons. The first is that a path in the use-case tree could contain all model events, so the scenarios should also consider every event, including those produced by objects which are not actually participating in the scenario. These problems in Barnard\uc3 \u8217\'e2\'80\'99s method are overcome in our proposal by considering partial verification as a debugging method. Our observability conditions combined with the \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
objective}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
(desirable/undesirable sequence diagram) for just one property in each verification reduces the size of the scenarios. The underlying automata-based verification for sequence diagrams allows us to explore the state space with an on-demand generation of states (on-the-fly model checking).}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Being temporal logic outside the UML framework, our approach is more suitable for the way UML software engineers normally work. A related and non-explored alternative closer to UML could be the use of OCL as a property language.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Tool vUML [LP99], although keeps Promela hidden to the user, only supports the verification of general properties of statecharts.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
HUGO [SKM01] also employs Promela and SPIN as the core verification technology, but its users work with UML descriptions. HUGO verifies whether the desirable behavior described by a collaboration diagram is feasible for a set of UML state machines (equivalent to our Phase 2.)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
UML formal semantics: lessons learned}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
OCL usage examples}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: modelers typically choose a semantics which is considered correct in a general, or convenient for their own purposes}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
fUML== foundational UML: subset of computationally complete executable models expressed in UML. \uc3 \u8592\'e2\'86\'90 disregards state machines and SDs?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
end users systematically discard any formal semantics for UML, because of the accompanying complexity and lack of industry-scale tool support; UML diagrams are not properly related with eachother and integrated; consensus exists on the static UML semantics, still many challenges with the dynamic UML sublanguages.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
UML offers elements of a graphical concrete syntax to create visual models of software-}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
intensive systems. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
UML aims to be a }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
standard modelling language for concurrent and distributed systems. Though UML is not a development method by itself, it was designed to be compatible with the leading object-oriented software development methods of its time. Development methods have been created based on UML, the best known is the Rational Unified Process (RUP [8]) of IBM. The UML rapidly gained popularity in industry, as it facilitated the communication between most diverse stakeholders about a system at different phases of development, on one hand, and, on the other, several points of view onto that system, including its context. In contrast to its popularity, there are severe reservations about the UML in science and various domains of application. The most fundamental criticism of UML made by the models-based engineering community has been its lack of informal and formal semantics, i.e., the colloquial nature of UML\uc3 \u8217\'e2\'80\'99s semantic description in natural language or in terms of UML itself; see [10,11]. Therefore, as pointed out in [12], multiple and potentially contradictory interpretations of one and the same model are not excluded, and automatic interpretation must be hard coded in some way or another in the tool chain. Another matter is whether object-oriented programming concepts provide the right modelling concepts. However, according to [16], the UML specification is highly technical, terse, and very difficult for beginners to understand, and the question of [17] Why are some specifications so hard to read? Needless to say, an informal description unavoidably involves ambiguities and lacks rigour, and thus precludes the reasoning,early simulation and automated analysis of a system design expressed by a UML model. This issue was speedily tackled by the research community as soon as the potential of UML as a de facto standard was recognised.1 While (a large portion of) the static semantics of UML seems to have promptly reached a consensus,2 the dynamic semantics of the UML sub-languages, such as activities, interactions and state machines, poses a major challenge. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: No reliable quality assurance can be undertaken as long as the very language employed to describe the system under scrutiny is deprived of a precise semantics. One consequence of these open issues is the low level of automation in tool support for the UML.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The UML sublanguages are complicated as many constructs and features have been put at disposal without the necessary fine tuning with each other. The Object Constraint Language (OCL [18]), for example, is used to formulate well-formedness rules in UML models, and is also intended to be an adjunct to UML for modellers who wish to add to their models more precision that cannot be otherwise (e.g., graphically) stated. OCL can be used as a navigation language, to write class invariants and pre-/post-conditions of methods within classes of a class diagram, guards of transitions of state machines, and guards of communication between instances in a sequence diagrams, among other uses.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The UML interactions describe possible message exchanges between system instances, and make up a powerful language which, besides integrating the standard operations like sequential, parallel, and iterative composition of interactions, provide means to specify recursive behaviour and negative behaviour, i.e., behaviour forbidden in system implementations. These three interpretations of interaction negation are based on manipulations of sets of event traces, such that the universe opossible traces is partitioned into \uc3 \u8220\'e2\'80\'9cvalid,\u8221\'e2\'80\'9d \u8220\'e2\'80\'9cinvalid\u8221\'e2\'80\'9d and \u8220\'e2\'80\'9ccontingent\u8221\'e2\'80\'9d traces. A further interpretation for negation is given in [23], which treats negation as a modality rather than an operator. UML interactions also put an operator for assertion at disposal, whose meaning is closely related to that of negation; the semantic discussion in relation to negation also applies to assertion. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Compositionality amounts to the meaning of a complex expression being determined by the meanings of its constituent expressions and the rules used to combine them.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
On the one hand, a vague description of the UML sublanguages allows for a \uc3 \u8220\'e2\'80\'9cfree\u8221\'e2\'80\'9d interpretation of them (e.g., negation of interactions). This is in line with the observation\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
of [15] cited above, that modellers typically ignore any normative UML semantics and concoct a one which is considered correct in general or convenient for their own purposes. \uc3 \u8592\'e2\'86\'90 a word of caution: not everything is vague, in fact a small subset of the language is \u8592\'e2\'86\'90 for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
OMG made a request for proposal in order to enable a chain of tools that support the construction, verification, translation, and execution of computationally complete executable models expressed in a subset of UML; see [28].4 The current draft version of the official adopted specification is called Foundational UML (fUML [29]). The semantics of fUML is defined in fUML itself and using a base UML (bUML) in order to break circularity. A base semantics provides an interpretation of bUML as a set of first-order axioms over possible execution traces; the base semantics specifies when particular executions conform to a model defined in bUML, it does not generate executions. The subset addressed by this proposal most noteworthy disregards state machines and interactions (i.e., sequence diagrams).}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
On the one hand, a semantic core denominated the System Model theory was defined. In general, the System Model forms a foundation for structure, behaviour and interaction}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
of object-oriented, possibly distributed systems. The System Model is abstract enough to be of general value, but also sufficiently detailed to allow simulation and execution of UML models. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
What these efforts inevitably left untreated is the fact that a particular language may have different intended semantics when used at different stages of development. But these interaction specifications, at different stages, may be devised with a different intended semantics in mind: during integration test, they are (at least desirably) exhaustive, whereas during analysis they not necessarily are striven for exhaustiveness. Indeed, as pointed out in [27], the claim of universality of UML, meaning that (for ppt)?: }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
UML is a notation suitable for analysis, design and documenting the implementation, necessarily entails multiple interpretations.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In practice, mainly for description of structure and seldom for the specification of behavior. As surveyed in [14], the reasons for this situation are that the notations provided by the UML for describing behaviour are complex, poorly defined and poorly integrated, that round-tripping between code and model is far too lossy and error prone, and that tools in general are poor in how they integrate modelling artefacts into the lifecycle. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
deficits of UML as, e.g., circular and contradictory definitions...UML which is a result of tries, failures and successes that were never theoretically justified.}
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The formal exploration of those accomplishments appear to be of no interest to the tool vendors possibly for political reasons. End-users, on their side, systematically disregard any formal semantics for UML because of the accompanying intrinsic complexity and lack of proper (i.e., at industrial scale) support. Unsurprisingly, the reaction from academia, besides questioning model-driven development methods for which UML was thought as a vehicle (see [36,37]), is a shift of focus to other challenges.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
He had the feeling that striving to give formal meaning to his graphical formalisms would ruin the whole proposal.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt? }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
On the one hand, graphical notations are undoubtedly very useful, even when they are}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
only informal. They allow us to sketch ideas in early stages of development, when many details need not be considered. Had those notations a formal meaning, many of the graphical descriptions would be actually false at least with respect to details in which nobody is interested at that stage of development. \~What is needed is a robust set of concepts with unambiguous meaning, clearly directed towards the concepts used in engineering systems. However, this characterisation does not apply to the UML. In many respects, }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
UML is far too much triggered by specific concepts of programming like object-oriented constructs, which are overly close to a explicit execution model with some express operational meaning. T}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
he UML sublanguages are not properly related to each other and integrated. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: If one is interested in a formal modelling language, which supports the seamless development process including round-trip engineering and code generation with a great deal of automation by means of tools, a formal semantics is indispensable. Such a modelling language is thus close to a high-level design language and also to a programming language. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For that modelling language, all formal semantic questions have to be solved in order to achieve the essential goal of portability and independence of particular implementations of tools.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We have understood that designing a full-blown modelling language as an engineering tool has to be done from foundational principles and not out of the amalgamation of a number of not completely understood concepts.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Large-Scale Formal Verification in Practice: A Process Perspective}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This is for project managers; with Isabelle theorem prover [customized]}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Verification here is: whether the software is consistent with the specification}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Our analysis of the project is based on complete access to project logs, meeting notes, and version control data over its entire history, including its long-term, ongoing maintenance phase. The aim of this work is to aid understanding of how to successfully run large-scale formal}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
software verification projects.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Formal methods (FM) is the application of mathematical techniques to specify programs (formal specification) and to prove that programs meet those specifications (formal verification). The L4.verified project has performed not just formal specification, but also formal verification; not just at design level, but down to C source code; and not just for lightweight properties, but for the full functional correctness of a highly complex software system\uc3 \u8212\'e2\'80\'94the seL4 .\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A kernel is the part of the OS that runs in the privileged mode of the hardware. It has direct access to all hardware resources and provides the basic mechanisms for implementing the rest of the system. A microkernel, as opposed to more common monolithic OS kernels, is reduced to the bare minimum of functionality and code. This radical reduction in size comes with a price in complexity. It is a challenge to design a formally verifiable kernel while maintaining high performance. To obtain high performance, kernel developers usually take a bottom-up approach to design, focusing on low-level details that allow efficient management of hardware. In contrast, formal methods practitioners often prefer a top-down approach based on simple models with a high level of abstraction.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This intermediate target is a prototype of the kernel written in the functional language Haskell. It}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
is translated automatically into the executable specification of the kernel in the theorem prover Isabelle/HOL [9]. The prototype can be used to directly exercise user-level programs that interface with the kernel and thereby validate the API under development. The importance of the use of executable specifications in formal verification in a theorem prover has been recognized previously in the ACL2 community [10], focussing on microprocessor verification in particular.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt: The abstract specification is a formal description of the functionality of the kernel. It specifies the interface and effects of system calls, but not the details of how these effects are implemented. In other words it describes what is expected from the kernel, whereas the executable specification describes how the kernel will achieve its purpose.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The proof that the executable specification refines the abstract specification (on the right in Fig. 2) was carried out first. This proof can be seen as design verification. \~Then a low-level, high-performance implementation of the kernel was manually written in the C programming language. The second proof (on the left in Fig. 2) shows that this C code correctly implements the executable specification, which we will also refer to as code verification. Note that the C code is translated automatically into the theorem prover for verification }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Verification of Java Programs Using Symbolic Execution and Invariant Generation}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Technique for loop invariant generation \uc3 \u8592\'e2\'86\'90 crucial for checking programs that manipulate unbound data, such as arrays; not so relevant, maybe only underlined; symbolic execution tree \u8592\'e2\'86\'90 figure, nicely shows the concepts;\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
code instrumentation for model checking with Java PathFinder is demonstrated with an example;}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
conclusions section says it all; not sure how they prove a property just by looking at the resulting invariant; examples they give are trivial methods/algorithms; explains basics of symbolic execution; otherwise it\uc3 \u8217\'e2\'80\'99s all about invariant generation which is only one of the issues to be covered for symbolic execution;\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We present a novel framework, based on symbolic execution, for the automated verification of software. The framework uses annotations in the form of method specifications and loop invariants. ...It allows for checking universally quantified formulas. Our framework is built on top of the Java PathFinder model checking toolset and it was used for the verification of several non-trivial Java programs. \uc3 \u8592\'e2\'86\'90 how about existential?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Our technique for loop invariant generation works backward from the property to be checked and has three basic ingredients: iterative invariant strengthening, iterative approximation and refinement.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Loop invariant generation has received much attention in the literature A recent paper [13] describes a loop invariant generation method for Java programs that uses predicate abstraction. The method handles universally quantified specifications but it relies on user supplied input predicates. We show (in Section 5) how our iterative technique discovers invariants for (some of) the examples from [13] without any user supplied predicates. The main idea behind symbolic execution [24] is to use symbolic values, instead of actual data, as input values, and to represent the values of program variables as symbolic expressions. As a result, the output values computed by a program are expressed as a function of the input symbolic values.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The state of a symbolically executed program includes the (symbolic) values of program variables, a path condition (PC) and a program counter. The path condition is a (quantifier-free) boolean formula over the symbolic inputs; it accumulates constraints which the inputs must satisfy in order for an execution to follow the particular associated path. The program counter defines the next statement to be executed. A symbolic execution tree characterizes the execution paths followed during the symbolic execution of a program. The nodes represent program states and the arcs represent transitions between states.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Our symbolic execution framework automates test case generation and allows model checking concurrent programs that take inputs from unbounded domains with complex structure. To enable a model checker to perform symbolic execution, the original program is instrumented by doing a source to source translation that adds nondeterminism and support for manipulating formulas that represent path conditions. The model checker checks the instrumented program using its usual state space exploration techniques \uc3 \u8212\'e2\'80\'94 essentially, the model checker ex-\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
plores the symbolic execution tree of the program. \~\uc3 \u8592\'e2\'86\'90 usual state-space exploration techniques; it\u8217\'e2\'80\'99s always bounded to some depth, right? \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Note that performing (forward) symbolic execution on programs with loops can explore infinite execution trees. This is why, for systematic state space exploration, the framework presented in [23] uses depth first search with iterative deepening or breadth first search. The framework can be used for test input generation and for finding counterexamples to safety properties. If there is an upper bound on the number of times each loop in the program may be executed, the framework can also be used for proving correctness, since the corresponding symbolic execution tree is finite. However, for most programs, no fixed bound on the number of times each loop is executed exists and the corresponding execution trees are infinite. \~Our framework uses the Java PathFinder(JPF) [30] model checker to analyze the instrumented programs. Since it is built on a JVM, it can handle all of the language features of Java, but in addition it also treats nondeterministic choice expressed in annotations of the program being analyzed \uc3 \u8212\'e2\'80\'94 annotations are added to the programs through method calls \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
As an illustration of the instrumentation, consider the code from Figure 1. Figure 3 gives part of the resulting code after instrumentation and Figure 4 gives part of the library classes that we provide. The generation of loop invariants is an intricate problem We propose to use a simple, but powerful approximation technique to help termination.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
If there is an error in the program, our method is guaranteed to terminate, reporting the error. However, if the program is correct with respect to the given property, this iterative method might not terminate (and the refinement might continue indefinitely).}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Variable oldPC stores the value of the path condition before the check of the inductive step; the value of oldPC is used in the approximation phase for invariant strengthening. Model checking the program using JPF prints all the path conditions PC (together with oldPC) for the assertion violations.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We have presented a method that extends the framework presented in [23] with the ability of proving partial-correctness specifications. This yields a flexible framework for checking Java programs. The general methodology for using our framework is to first use it as a model checker, using depth first search with iterative deepening or breadth first search. \uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
partial correctness?}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
If no errors are found up to a certain depth, then there is some confidence that the program is correct (with respect to the given property), and a proof of correctness can be attempted using the method presented in this section. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Our current system is not fully automated; although we discover all path conditions that lead to an assertion violation automatically, we combine the conditions by hand into a candidate invariant and add it back to the code to check if it is inductive.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Most of these methods use techniques that are domain specific. Our method for invariant generation uniformly treats different kinds of constraints. Our method could be viewed as an iterative-deepening search of a sufficient set of constraints that could express an invariant that is strong enough for verifying the property. Each step in this search is guaranteed to terminate, but deepening (refinement) may be non terminating.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
...This invariant is sufficient to prove the property. \uc3 \u8230\'e2\'80\'a6 \u8592\'e2\'86\'90 manually? how?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Unlike [13], our method works backward starting from the property to be checked and it naturally discovers the necessary constraints over the program\uc3 \u8217\'e2\'80\'99s variables, through symbolic execution and refinement. There has been a lot of recent interest in applying model checking to software. Java PathFinder [30] and VeriSoft [15] operate directly on a Java, respectively C program. Other projects, such as Bandera [6], translate Java programs into the input language of verification tools. Our work would extend such tools with the ability to prove partial-correctness specifications. \~The SLAM tool [1] focuses on checking sequential C code with static data, using well-engineered predicate abstraction and abstraction refinement tools.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We should note that tools like SLAM perform abstraction on each program statement, whereas our method performs approximation (which can be seen as a form of abstraction) only when necessary, at loop headers. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The framework uses annotations in the form of method specifications and loop invariants. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We presented a novel iterative technique for discovering these loop invariants automatically.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The technique works backward from the property to be checked and it systematically applies approximation to achieve termination.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We illustrated the applicability of our framework to the verification of several non-trivial Java programs. Although we made our presentation in the context of Java programs, JPF, and the Omega library, our framework can be instantiated with other languages, model checkers and decision procedures. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
--------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\chcbpat4\rtlch \ltrch\loch\fs22\loch\f5
Assert and negate revisited: Modal semantics for UML sequence diagrams}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for future work: this paper has several nice figures of accepting/rejecting automata based on scenarios (well not SDs but Live Sequence Charts...close enough to be used!!)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
LSC - multi-modal scenario-based properties: mandatory, possible and forbiden scenarios.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Assert and negate in UML for specifying mandatory and forbidden scenarios. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Main point: assert and negate are }{\scaps0\caps0\cf1\i0\ul\ulc0\b0\rtlch \ltrch\loch\fs22\loch\f5
modalities}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
, not }{\scaps0\caps0\cf1\i0\ul\ulc0\b0\rtlch \ltrch\loch\fs22\loch\f5
operators.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
But are these operators the only problem blocking precise semantics for UML?}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
they define }{\scaps0\caps0\cf1\i0\ul\ulc0\b0\rtlch \ltrch\loch\fs22\loch\f5
modal interaction fragments}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Clearly explains the problems with assert and negate, by quoting the spec. in different places}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
constraints are boolean expressions over attributes associated with participants in the SD}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
essentially they try to formally define a visual language sufficient for expressing the design but also the requirements.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Live Sequence Charts (LSC) extend Message Sequence Charts (MSC), mainly by distinguishing possible from necessary behavior. They thus enable the specification of rich multi-modal scenario-based properties, such as mandatory, possible and forbidden scenarios. The sequence diagrams of UML 2.0 enrich those of previous versions of UML by two new operators, assert and negate, for specifying required and forbidden behaviors, which appear to have been inspired by LSC. The UML 2.0 semantics of sequence diagrams, however, being based on pairs of valid and invalid sets of traces, is inadequate, and prevents the new operators}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
from being used effectively. We propose an extension of, and a different semantics for this UML language\uc3 \u8212\'e2\'80\'94Modal Sequence Diagrams (MSD)\u8212\'e2\'80\'94 based on the universal/existential modal semantics of LSC.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In particular, in MSD assert and negate are really modalities, not operators. We define MSD as a UML 2.0 profile, thus paving the way to apply formal verification, synthesis, and scenario-based execution techniques from LSC to the mainstream UML standard. While the language of Message Sequence Charts (MSC), defined by ITU [18] is a popular means for specifying interactions between objects or processes, it is expressively weak, being based on a modest semantic notion of a partial ordering of events. This is true also for most proposed extensions of MSC, where despite enhancements with regular expression constructs, the underlying semantics of a partial order remains intact. Live Sequence Charts (LSC), introduced in [7], extend MSC by allowing a distinction between possible and necessary behavior, with, for example, a hot/cold modality for elements within the charts. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
It thus enables specification of rich multi-modal scenario-based properties, such as liveness and safety, using mandatory, possible and forbidden scenarios.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Since its introduction in 1998, the LSC language with its formal (operational) semantics has triggered much research both on the requirements/specification level and as an executable programming language for reactive systems.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The Unified Modeling Language (UML) includes a section on sequence diagrams, which early versions of the standard adopted directly from MSC UML 2.0 Sequence Diagrams specification is based on a revised metamodel and has adopted additional important and useful features from MSC and high-level MSC (HMSC) [18]. These include, for example, the concept of InteractionUse (originally called MSC reference), which allows referring to another interaction from within a diagram (sharing portions of an interaction between several other interactions), the notion of InteractionFragment, and its operators for choice, sequential, parallel, and iterative composition.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
However,}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
the most interesting addition to sequence diagrams in the UML 2.0 standard are two new and crucial operators, assert and negate, which were probably intended to bring the multi-modal hot/cold essence of LSC into the new standard,}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
and to allow the specification of required and forbidden behaviors, respectively. These two new operators constitute the main mechanism adopted by the UML 2.0 authors for increasing the actual expressive power of the language. Unfortunately, in Sect. 2.3 we show that the semantics suggested in the UML 2.0 specification document, which is based on pairs of valid and invalid sets of traces, is inadequate, and does not lead to a well defined semantics of these new features of the language. The semantic confusion around the use of assert and negate prevents these features from being used effectively, since the ability to specify liveness and safety properties, e.g., via required and forbidden behaviors, is a fundamental prerequisite for the use of sequence diagrams in specification, testing and verification, and also, of course, when executing the language and using it for actual programming. \uc3 \u8592\'e2\'86\'90 why the most interesting? as property specifications? liveness / safety? Thus, in this paper we propose Modal Sequence Diagrams (MSD)2 , which is an extension of UML 2.0 Sequence Diagrams based on the universal/existential distinction that is at the heart of live sequence charts. MSD allows denoting parts of an interaction, such as messages and constraints, or a complete interaction, as universal, i.e., mandatory, thus specifying that messages have to be sent, conditions must become true, etc. Technically, we do this by defining modal interaction fragments. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Thus, assert and negate, we claim, are not to be viewed as operators but as modalities. Still, we believe our version, MSD, is very close to UML 2.0 Sequence Diagrams as they are described in the standard documents, yet has stronger expressive power and far more robust semantics. The fact that MSD is defined as a UML profile makes it possible to carry over to mainstream UML most of the recent results and applications worked out for LSC, in formal verification, testing, synthesis, and scenario-based execution. The LSC language [7] defines two types of charts: universal (annotated by a solid borderline) and existential (annotated by a dashed borderline). Universal charts are used to specify restrictions over all possible system runs. A universal chart typically contains a prechart that specifies the scenario which, if successfully executed, forces the system to satisfy the scenario given in the actual chart body. Existential charts specify sample interactions between the system and its environment, and must be satisfied by at least one system run. They do not force the application to behave in a certain way}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
in all cases, but rather state that there is at least one set of circumstances under which a certain behavior occurs. \~\uc3 \u8592\'e2\'86\'90 in OO systems this is not very natural? Why would you say that some scenario is mandatory? all the behavior is mandatory and optional at the same time!!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A message typically associates two OccurrenceSpecifications, corresponding to sending and receiving events. CombinedFragment, consisting of an operator and a number of operands, which may be either plain interactions or, again, combined fragments. The semantic domain for UML 2.0 Interactions consists of OccurrenceSpecifications, which represent moments in time (with no duration) associated with actions, such as the sending or receiving of a message. A trace is a sequence of occurrence specifications. According to the standard, the semantics of an interaction is given as a pair of sets of traces, representing, respectively, the valid and invalid traces.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In addition to these high-level structural operators, the standard defines a macro-like mechanism for modularity, using the ref operator. If we forbid the use of recursive references (which, by the way, the standard does not refer to at all, so there is no way of knowing whether they are allowed or not. . . ), the semantics of a fragment that includes ref is simply the semantics of the fragment after syntactically substituting the references with copies of the referenced interactions. We now briefly illustrate the inadequacy and vagueness of assert and negate as they are defined in the standard specification document [34]. As to assert, the standard explains that \uc3 \u8220\'e2\'80\'9cthe sequences of the operand of the assertion are the only valid continuations. All other continuations result in an invalid trace\u8221\'e2\'80\'9d [34, p. 456]. This suggests that the invalid set of traces for an asserted fragment is its complement, i.e., the set of all other possible traces. Later however, the standard declares that \u8220\'e2\'80\'9cthe invalid set of traces are associated only with the use of a Negative CombinedFragment\u8221\'e2\'80\'9d\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
As to negate, according to the standard, it \uc3 \u8220\'e2\'80\'9cdesignates that the combined fragment represents traces that are defined to be invalid\u8221\'e2\'80\'9d [34, p. 455], so neg seems a reasonable and a natural way to specify counterexamples. However, \u8220\'e2\'80\'9call interaction fragments that are different from Negative are considered positive meaning that they describe traces that are valid and should be possible\u8221\'e2\'80\'9d\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
These semantic confusions are significant, in that they prevent these important features from being used effectively. Indeed, assert is defined in the standard specs but is not mentioned in recent works such as [11], which discuss liveness in sequence diagrams, nor does it appear in the popular UML user guide [2]. In fact, no tool seems to exist which adequately supports a reasonable interpretation of assert and negate as they are defined in the standard, nor have we seen any paper with a satisfactory proposal for such an interpretation. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
As a basis for the extension, we start off with the so called existential or positive fragment of UML 2.0 Interactions, i.e., without assert and negate. To allow the specification of modalities over interactions, we define a stereotype modal with a single attribute interactionMode, which, in the spirit of LSC, can be either hot (universal) or cold (existential) (see Fig. 3). The new stereotype is introduced as an extension of the abstract class InteractionFragment, and hence}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
also of its subclasses: Interaction, OccurrenceSpecification, and StateInvariant.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A system-model satisfies an MSD specification if (1) every one of its possible runs satisfies each universal diagram in the specification, and (2) every existential diagram is satisfied by at}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
least one possible system run. To conform to the standard\uc3 \u8217\'e2\'80\'99s notation, we allow the use of assert in MSD, but we interpret it as syntactic sugar \~\~for assigning a hot mode to all the OccurrenceSpecifications inside the interaction fragment operand. \~\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
!! basics for semantics explained in continuation...formulas blabla}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We define the trace-language of a universal MSD using an alternating weak word automaton (AWW)...}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Still, the ability to explicitly specify forbidden scenarios is very important in practice since in many cases, specifically in formal verification, it is more natural and shorter to specify what should never happen (a safety property; a counterexample) than to specify all legal possibilities.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To use the standard\uc3 \u8217\'e2\'80\'99s notation, we allow the use of the negate operator. As in the case of assert, we interpret it as syntactic sugar for adding a hot constant FALSE constraint immediately after the last OccurrenceSpecification (actually, all the last ones) in the InteractionFragment operand;\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This solution, however, keeps the important liveness requirements within textual logical formulas outside the visual syntax of the modeling language. If the extensive use of textual logical formulas outside the diagrams is necessary, then one could use other appropriately expressive formalisms (e.g., temporal logic) to specify a system\uc3 \u8217\'e2\'80\'99s behavior. The challenge we try to meet in our own work is to formally define a scenario-based specification language that is sufficiently expressive yet intuitive and visually appealing.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In [11], it is shown how to derive liveness and safety automata from UML 2.0 Sequence Diagrams, but that paper employs a different interpretation of the standard semantics, with no reference to the assert operator. Validity is interpreted as \uc3 \u8220\'e2\'80\'9cliveness\u8221\'e2\'80\'9d, as in \u8220\'e2\'80\'9ceach finite execution should be extendible to an execution where the positive trace eventually\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
happens\uc3 \u8221\'e2\'80\'9d \u8592\'e2\'86\'90 find [11] \u8220\'e2\'80\'9cSafety-Liveness Semantics for UML 2.0 Sequence Diagrams\u8221\'e2\'80\'9d \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
STAIRS [17,30] is a requirements specification methodology based on UML 2.0, where the semantics of interactions is given using interaction obligations, which are pairs of sets of traces categorized as positive and negative. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Roughly, xalt means \uc3 \u8220\'e2\'80\'9cfor each operand one of the alternatives must be possible\u8221\'e2\'80\'9d.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In STAIRS, a correct implementation \uc3 \u8220\'e2\'80\'9cmay only produce traces belonging to the positive and inconclusive trace sets of the obligation, i.e. no negative trace must be produced by the implementation\u8221\'e2\'80\'9d. Thus, we claim that increasing the expressive power of sequence diagrams to allow liveness and safety specifications requires a universal interpretation: assert and negate are thus to be considered as modalities, not as operators. \uc1 }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
\uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
this means embedding desired properties into the system itself somehow?!}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this paper we mainly considered synchronous messages and strict sequencing, and did not explicitly address the semantics and use of MSD in asynchronous settings. This may also be a topic for future work.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Our definition of MSD in the present paper precludes nesting of hot fragments inside existential diagrams. Indeed, following the stated justification given in [7], we judge that such nested quantification is too complex for real world usage of sequence diagrams (in particular, if hot fragments inside existential diagrams are allowed, a single system run may no longer suffice to ensure the satisfiability of an existential diagram). In addition, given the fact that MSD is defined as a UML profile, our work paves the way to apply recent work on LSC in formal verification [8,19,31,36] to the UML. As a first step, one can formalize and implement a translation from MSD to Temporal Logic, similar to the one suggested for LSC in [22].}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Automated Formalisation for Verification of Diagrammatic Models}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
bullshit mostly?}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
underlined useful for ppt. Just intro, rest is BS. Just class and state machine diagrams? experts create templates with EGL and FTL languages?? FTL templates as model-transformation mappings? it\uc3 \u8217\'e2\'80\'99s like a meta-model for defining transformation templates and meta-theorems.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
There are challenges in applying formal analysis to these approaches, either because the semantics is inadequately defined, or because the level of detail of the semantics does not admit interesting or useful formal analysis. Conversely, the formal notations used in verification of critical systems and in academia are considered inaccessible by many practical engineers. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
However, few integrations have found favour, either because formalisation does not meet engineeringneeds, or because engineers are exposed to the formalisation and formal model.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
bringing formalisms into practical engineering \uc3 \u8592\'e2\'86\'90 title for thesis?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Am \uc2 \u769\'cc\'81lio demonstrates an instance of GeFoRME called UML+Z, comprising a library of templates that capture the object semantics of UML. Instantiating the templates with details from UML diagrams results in a Z model that conforms to Am \u769\'cc\'81lio\uc3 \u8217\'e2\'80\'99s object-oriented (OO) Z structuring, ZOO [4,7,3,10]. UML+Z has been used on small case studies [3,9] of conventional object-oriented models including UML class and state diagrams and Catalysis ...and traceability between\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
the formal and diagrammatic models... \uc3 \u8592\'e2\'86\'90 for ppt, I have this \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In all the work with UML+Z, however, a major inhibiting factor is the lack of tool support for management and instantiation of templates. \uc3 \u8592\'e2\'86\'90 for ppt!!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
model-driven development (MDD) \uc3 \u8211\'e2\'80\'93 the family of approaches to tool-supported practical software development that focuses on the construction and manipulation of primarily-diagrammatic models [29]. As in formal translation, MDD model transformation defines a mapping from a source model to a target model [11]. The mapping, or transformation defi-\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
nition, comprises transformation rules which specify how each modelling construct is transformed. In transforming diagrammatic models to formal models, we apply a model-to-text (as opposed to model-to-model) transformation. Model-to-text transformation is most commonly used for code generation \uc3 \u8592\'e2\'86\'90 mapping a set of transformation rules which specify how each modeling construct is transformed. Does Z notation cover dynamic aspects? doesn\u8217\'e2\'80\'99t seem to!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
He notes the need to model concepts that cannot be expressed diagrammatically \uc3 \u8211\'e2\'80\'93 constraints and model properties \u8211\'e2\'80\'93 and considers the general problem of semantics.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In most cases, the semantics is clarified only when a diagrammatic model is converted to code \uc3 \u8211\'e2\'80\'93 thus, a class diagram that forms the basis for a Java program assumes a Java semantics, but the same diagram used to create a C++ program assumes a C++ semantics. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In practice, little attention is paid to consistency across model-views or between diagrams and constraint expressions. \uc3 \u8592\'e2\'86\'90 for ppt: we take consistency as assumption\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Most attempts to associate formal semantics to diagrammatic modelling assign a specific formal meaning to each diagrammatic concept. Whilst this significantly reduces ambiguity, and admits formal analysis, the formalisation assumes a single, fixed semantics for each concept [9] \uc3 \u8211\'e2\'80\'93 and the semantics that is assumed is often only apparent to the formalist. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
By contrast, Amalio\uc3 \u8217\'e2\'80\'99s approachs advocate a framework for rigorous, but practical MDD [9]; concept semantics are captured explicitly in the templates, so a different semantics simply requires use of a different set of templates...allows the formalism to be completely hidden from the developer.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Am \uc2 \u769\'cc\'81lio devised the Formal Template Language (FTL) [3,8] as the rigorous underpinning to the GeFoRME framework The tool needs to catalogue the existing UML+Z templates efficiently and support the addition of new templates and meta-proofs: there is potential to extend the existing UML+Z templates with a wide range of alternative concept semantics.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The AUtoZ tool is a framework on which different instance tools can be built. The two instances that currently exist are AUtoCADiZ and AUtoZ/Eves. AUtoZ is a plug-in for the Eclipse development environment, which is used as the basis for many modelling and model-management activities in software engineering. \uc3 \u8592\'e2\'86\'90 meta tool, so! :P\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Common MDD diagramming tools provide serialised XMI output, and are underpinned by a metamodel that defines the abstract syntax (concepts) of the notation. This allows concepts and their labels to be automatically extracted from diagrams, to instantiate the FTL templates. Here, we use the existing Eclipse modelling plug-in, UML2 (www.eclipse.org/uml2/), since it supports UML 2.x modelling, uses a standard metamodel-based approach to abstract syntax, and sits within the Eclipse development environment. However, in principle AUtoZ could use XMI output from many other modelling tools. \uc3 \u8592\'e2\'86\'90 ppt?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
FTL templates as model transformation mappings EGL, the Epsilon Generation Language, supports model-to-text transformation. An EGL run configuration specifies a file containing the XMI source model, and a file containing EGL transformation rules to be executed on the source model, as described in [26] \uc3 \u8592\'e2\'86\'90 check? no, it\u8217\'e2\'80\'99s template based, no thanks, works well for static aspects! \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The AUtoZ Eclipse plug-in is a customised EGL run configuration that executes the transformations on a UML2 XMI source model to generate Z L TEX markup, which is then input directly to the formal support tool for analysis. Figure 4 summarises the workflow of AUtoZ. A developer provides the UML model; the tool calls an AUtoZ run configuration file; Eclipse plug-ins convert UML to Z L TEX via EGL, and call the relevant Z tool. The result of the formal analysis is returned to the user.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This is necessary to support the basic user, a developer who is well-versed in diagrammatic modelling but has little interest in formal methods. \uc3 \u8592\'e2\'86\'90 for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The expert user needs to be familiar with formal methods and able to interact directly with formal}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
notations and tools, in order to develop new FTL templates and meta-theorems and to write and edit EGL transformation rules corresponding to the FTL templates}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
An expert user needs some understanding of the template languages (EGL, FTL), and the formalisation process. FTL maps readily on to EGL, and we note that an expert user involved in template maintenance would need to be familiar with both languages. FTL is also needed for meta-theorems and proof work, because of its formal underpinnings}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Transformation and Verification of Executable UML Models (2004)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Compositional Temporal Logic of Actions = CTLA formal specification language}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
check this \uc3 \u8594\'e2\'86\'92 improvement in UML2 \u8594\'e2\'86\'92 Action Semantics \u8594\'e2\'86\'92 a metamodel for action-based description language \u8592\'e2\'86\'90 read it\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
I don\uc3 \u8217\'e2\'80\'99t see any human-readable traces from their case study, everything is blabla\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
and how is this verification done? long paragraphs with proofs...}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The formal specification technique compositional Temporal Logic of Actions (cTLA) provides for modular descriptions of behavior constraints and its process composition operation corresponds to superposition. Furthermore, cTLA facilitates the selection of an arbitrary subsystem of a complex specification which is composed of processes. \~In a first step of the verification, the abstract and the detailed model are transformed to cTLA specifications. Thereafter, we can prove that the cTLA specification of the more detailed}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
model implies the cTLA description of the more abstract one by application of the model checker TLC (Temporal Logic Checker).}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
advantage of model checker application to the frameworks is that the proofs can be performed in a }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
highly automated}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 \uc3 \u8592\'e2\'86\'90\uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
( for ppt) fashion. Since UML-based system descriptions tend to describe systems in a relatively abstract manner, we expect that the modeled state space of many real-life systems can be handled by a model checker. Therefore we decided to apply the powerful checker TLC (Temporal Logic Checker) [24,33], to perform the refinement proofs. Tools for the transformation of UML specifications into cTLA [9,11] and of cTLA specifications into TLA [19] exist. The transformation utilizes the compositional features of cTLA extensively since a UML diagram can be transformed into a separate cTLA process. Our approach complements a lot of other approaches formalizing UML diagrams by formal models (cf. [25,28,30,31]) which, however, do not use compositionality in the way explained in this paper. We adapted our formalization to the upcoming UML 2.0 standard since the improved action semantics (which was introduced in UML 1.5) and the compositional aspects of sequence diagrams facilitate the transformation into cTLA processes. Based on these new semantical features we redefined our transformation rules from UML diagrams to cTLA processes fostering the generation of very compositional cTLA system descriptions which facilitate the carrying out of suitable refinement proofs by means of the model checker TLC. In order to stay within the boundaries of this paper, we had to restrict ourselves into sketching the process of transforming a UML model into the corresponding cTLA processes and to verify some example properties. In UML 2.0, transitions can be provided with a statement containing an event name, a guard condition, and an activity identifier. By the event name it is possible to specify a UML change event, call event, send event or completion event. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Furthermore, one can allow the deferral of events. If an event cannot be processed in the current state, it is stored in an event queue and can be used later. \~One can define so-called composite states from substates which can contain substates as well. A composite state can be a nested state corresponding to the OR-States in a statechart diagram. If an incoming transition of the nested state is fired, exactly one of its substates gets active. The other kind of a composite is a concurrent state which corresponds to an}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
AND-state in a statechart diagram. Here, the substates carry out transitions concurrently. In UML 2.0, sequence diagrams are strongly influenced by the current Message Sequence Chart (MSC) standard }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The occurrence of messages is described by the aid of traces. A trace consists of sequences of event occurrences < E1 , E2 . . . , En >. In UML 2.0, it is possible to incorporate traces of foreign sequence diagrams into another diagram using the keyword ref and an identifier which refers to another sequence diagram. Moreover, one can compose sequence diagrams from other diagrams by application of so-called CombinedFragments. A CombinedFragment may contain so called InteractionOperands. That are special regions in the diagram where events may occur in arbitrary orders defining a set of alternate traces. In the following, we will introduce two of the currently 11 defined InteractionOperators:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
seq}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
: This InteractionOperator determines that the CombinedFragment provides a weak sequencing of the behavior of its InteractionOperands. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Weak sequencing}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
is defined on a set of traces which fulfill the following three properties. Firstly, the order of event occurrences of each InteractionOperand \~\~is preserved in the result. Secondly, event occurrences on different lifelines which stem from different InteractionOperands may occur in an arbitrary order. Thirdly, the event occurrences on the same lifeline stemming from different InteractionOperands are sequenced with respect to the order of these InteractionOperands.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
strict}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
: The strict InteractionOperator implies that a CombinedFragment has }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
a strict order}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
of the event occurrences belonging to each InteractionOperand. The strict sequencing, however, is only enforced on the uppermost level of CombinedFragment with the operator strict. Thus, if the strict CombinedFragment A contains another combined fragment B, the event occurrences of B will not be directly compared with those of A. Another major improvement of UML 2.0 is the new Action Semantics defining a meta-model for action based description languages [32]. In contrast to the traditional Object Constraint Language (OCL) it facilitates the description of dynamic behavior enabling the generation of implementation code from UML models. Actions are the fundamental units of executable functionality. The Action Semantics does not define a particular syntax for action statements but more abstract class definitions which can be realized by applying various different syntaxes. Two actions exchange data and object information via special input and output pins. \uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
check this! I have mCRL2 which is also action-based; exactly like explained here}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Invocation Actions are used to perform operation calls and transmission of signals between objects. A relevant derived action is the so called CallOperationAction which transmits an operation call request to a target object where it invokes an associate behavior. The operation call is completed by a reply transmission which is performed by a ReplyAction/ So called Object actions are responsible for the creation and destruction of objects. \~\uc3 \u8592\'e2\'86\'90 for ppt: \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
these UML events I do not handle, but can be added}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
!!!! FOR PPT:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Systems and subsystems are described as compositions of concurrent processes. As in the ISO/OSI specification language LOTOS [20], a set of processes interact in a rendezvous-like way by performing actions jointly, and the data parameters of the actions can model the communication of values between processes. Each process encapsulates its variables and changes its state by atomic execution of its actions. The system state is the vector of the process state variables. State transitions of the system correspond to simultaneously executed process actions or to so-called process stuttering steps (i.e., the process does not change its state). \~The basic idea is to create a separate cTLA process for the state machine of each UML class.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt structure random thoughts:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
> Why Sequence Diagrams?}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
- state machines are easier?}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
- but these are closest to actual code}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In the UML2.0, an activity is modelled by a kind of Petri Net. Since a Petri Net corresponds with a state transition system, it can be transformed relatively easily to corresponding cTLA variables and actions. \uc3 \u8592\'e2\'86\'90 for ppt: activity diagrams are easily transformed into state transition system \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Read and Write Actions as well as Computation actions have only local scope whereas invocation actions have access to other objects. For each UML action with local scope it is sufficient to introduce a new cTLA action transforming the semantics of the UML action and describing its access to its input and output pins as well as its incoming and outgoing control edges. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
CreateObjectActions and DestroyObjectActions are supported by cTLA actions that change the value of the state variable lifecycle if the creation and destruction of objects is handled in the corresponding UML model. \uc3 \u8592\'e2\'86\'90 for paper: how to implement create/destroy actions: object will have a property lifecycle: dead or alive\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Invocation actions have to reflect that they are coupled with other actions in a peer object. In consequence, the corresponding cTLA action will be coupled with another action in a different process modelling the peer behavior. The two linked process actions have to carry identical action parameters modelling the arguments of the operation call. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
PPT (same with my approach):}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In the UML, however, an incoming reply transmission is accepted by the same CallOperationAction which also triggered the initial call. Since this non-atomic behavior cannot be specified by a single cTLA action, we describe CallOperationActions by two cTLA actions modelling the execution of an operation call resp. the acceptance of the reply transmission. In the process Adapter the actions callControl and callControlReply are both used to model a single CallOperationAction.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In the UML, sequence diagrams are used to describe the interaction of objects. Thus, they form a link between the state chart diagrams describing the (}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
individual!) }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
behavior of the objects.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
now comes the fuzzy case study part:...}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Thus, we have to prove that the call event passes the proxy and the adapter in a lively manner and will be eventually enqueued in the message queue of the detailed sensor object enabling the action sensorDequeueCall. We have to find a sequence of system states which are passed in the transmission process of the call event. <- what da fuck?}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
UML Automatic Verification Tool with Formal Methods (2005!!)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Figure 1: tool overview useful}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
they use SMs and ADs (good explanation of their relationship!) and translate them to SMV model checker algebra. But no formulas or heavy formalisation etc...;}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for property specification they take the 1999 paper as a starting point, so they made a tool/wizard assistant with catalogue to choose; the user does not need to understand the structure of the specification to carry out verification.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
tja, they claim everything is automated, but counterexample traces are not in the UML domain}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The tool uses SMV [10] (Symbolic Model Verifier) like formal specification, as it has the adequate characteristics for representing the active behaviour of a specification in UML. The main reason for this is that it is based on labeled transition systems and because it allows the user\uc3 \u8217\'e2\'80\'99s own defined data types to be used, thus facilitating the definition of variables. It also uses symbolic model checking for the verification, which means that the test is automatic, always obtains an answer and more importantly, should the property not be satisfied generates a means of identifying the originating error. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Focus is mainly on reactive systems in which the active behaviour of the classes is represented through state diagrams, while activity diagrams are used to reflect the behaviour of class operations. \~\uc3 \u8592\'e2\'86\'90 the whole point of using them; for ppt mention why!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Three kinds of diagram are taken into account when transforming the active behaviour from UML into SMV: class, state and activity diagrams. The first provides information concerning the elements that make up the system and their relationships, while the second and third provide information about the behaviour, through time, of each of those elements.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
An additional class called environment also has to be included. It has no associated behaviour and contains details of the signals produced outside the system and which are input signals. \uc3 \u8592\'e2\'86\'90 for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In addition, the fact that combined states, both sequential and concurrent, may appear within a machine means that additional variables are needed in order to deal with the submachines. These will be dealt with following the same reasoning as for the main machine, with the exception of the peculiarities they possess with respect to activation and deactivation. The evolution of an active object can lead to different actions, including sending signals and modifying the value of class attributes.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
They show below how SMs and ADs are related.cool.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Fundamentally, show the control flow between activities. Its SMV specification can be found in the module that reflects class behaviour. These activity diagrams are activated whenever a call to an activity is produced within a state using the notation do / <activity>.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Activity diagrams can be considered as a special case of state diagrams where the majority of states are activity states and most transitions are fired by termination. So the mechanism used to represent them is similar to that used for state machines. The only difference is that, for concurrent evolution, the special states of division and union (fork and join) are used. They are activated whenever any state which has a call to this activity inside it is activated. Likewise, they are deactivated whenever a transition is produced that deactivates the state in which it is contained.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In our tool, verification is carried out using the SMV tool model checker. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The property must be expressed in a temporal logic present in SMV 7 , CTL (Computation Tree Logic) or LTL (Linear Temporal Logic). This property writing is not a trivial problem. To write them correctly, advanced knowledge of logics and the type of specification obtained from the system is necessary. Our tool overcomes this problem as it has an assistant that guides the user through the writing of properties until the property to be verified is finally obtained following the appropriate syntax. Our starting point was the pattern classification proposed by Dwyer et al. [4] to which our own cataloguing of the different properties to be automatically verified has been added. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Property patterns}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The property writing assistant is based on the pattern scheme proposed by Dwyer et al [4] where it is established a first classification between patterns of occurrence and order. Most of the properties of a system to be verified in practice, fit in with one of these two categories.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Occurrence}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
patterns describe properties with respect to the occurrence of a state or signal during the evolution of a system. These include absence (never), universality (always), existence (sometimes) and bounded existence (appearing a certain number of times). }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Order}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
patterns establish properties with respect to the order in which they occur. They include: precedence (s precedes p), response (s responds to p), and combinations of both: chain precedence (s and t precede p or p precedes s and t), chain response (s and t respond to p or p responds to s and t), and constrain chain (s and t without z respond to p). }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
On the other hand, each kind of pattern has a }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
scope}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
of application which indicates the system execution on which it must be verified. There are five basic scopes: Global (the entire program execution), Before R (the execution up to a given property), After Q (the execution after a given property), Between Q and R (any part of the execution from a given property to another given property) and after Q until R (like between but the designated part of the execution continues even if the second property does not occur). Figure 7 illustrates the portion of an execution that are designated by the different kinds of scopes.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Most works dealing with UML verification using formal method techniques focus on state diagram verification. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The tools developed for verifying UML system specifications can be classified according to the formal language used:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Promela:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
vUML [9,13]. vUML is a tool for the automatic verification of UML \~models, focusing on state diagrams. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
HUGO [14,7]. This project includes a set of tools to apply model checking to UML state diagrams and collaborating ones. The latter are used to check whether the interaction represented in the collaboration diagram can be performed using state machines. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Most works do not carry out an automatic verification and vUML [9,13], which does, does not use the potential of temporal logic, implementing a limited verification based on checking that it is impossible to reach error states. }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
These error states are introduced by the user in the diagrams, so the diagrams are more complicated}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. \uc3 \u8592\'e2\'86\'90 for future work: oh, so it\u8217\'e2\'80\'99s limiting to check for reachability error-states with monitors! think about: how many of the categories can be expressed with an automaton? But in this case the error states must be introduced by the user, in our case it is transparent.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Applying Software Model Checking Techniques for Behavioral UML Models}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We translate UML to verifiable C code which preserves the high level structure of the models, and abstracts details that are not needed for verification. We combine of static analysis and bounded model checking for verifying LTL safety properties and absence of livelocks.We implemented our approach on top of the bounded software model checker CBMC. We compared it to an IBM research tool that verifies UML models via a translation to IBM\uc3 \u8217\'e2\'80\'99s hardware model checker RuleBasePE. Our experiments show that our approach is more scalable and more robust for finding long counterexamples. We also demonstrate the usefulness of several optimizations that we introduced into our tool.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: Model checking [6] is a successful automated verification technique for checking whether a given system satisfies a desired property. Model checking traverses all system behaviors, and either confirms that the system is correct w.r.t. the checked property, or provides a counterexample demonstrating an erroneous behavior. Model checking tools expect the checked system to be presented in an appropriate description language. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Our translation indeed preserves the high-level structure of the UML system: event-driven objects communicate with each other via an event queue. An execution consists of a sequence of Run To Completion (RTC) steps. Each RTC step is initiated by the event queue by sending an event to its target object, which in turn executes a maximal series of enabled transitions. Model checking assumes a finite-state representation of the system in order to guarantee termination with a definite result. One approach for obtaining finiteness is to bound the length of the traversed executions by an iteratively increased bound. This is called Bounded Model Checking (BMC) [3]. BMC is highly scalable, and widely used, and is particularly suitable for bug hunting. We find this approach most suitable for UML models, which are inherently infinite due to the unbound size of the event queue. We emphasize that our goal is to translate the UML model into verifiable C code that suits model checking, rather than produce executable code. \~Recall that the verifiable C code will be checked by BMC with some bound k. We choose k to count the number of RTC steps. This implies that along an execution of size k only the first k events in the queue are consumed, even if more were produced. It is therefore sufficient to hold an event queue of size k. We thus obtain a finite-state model without losing any precision. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We verify two types of properties: LTL safety properties and livelocks.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Safety properties require that the system never arrives at bad states, such as deadlock states, states violating mutual exclusion, or states from which the execution can continue nondeterministically. LTL safety properties can further require that no undesired finite execution occurs. Checking (LTL) safety properties can be reduced to traversing the reachable states of the system while searching for bad states. We apply Bounded reachability with increasing bounds for finding bad states. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Another interesting type of properties is the absence of livelocks. Livelocks are a generalization of deadlocks. While in deadlock states the full system cannot progress, in livelock states part of the system is \uc3 \u8220\'e2\'80\'9cstuck\u8221\'e2\'80\'9d forever while other parts continue to run. Livelocks can be hazardous in safety critical systems and often indicate a faulty design. Scalable bounded model checking tools mostly handle safety or linear-time properties. However, absence of livelocks is neither safety nor linear-time property and is therefore not amenable to bounded model checking. We identify an important subclass of livelocks, which we refer to as cycle-livelocks, and show that they can be found by combining static analysis and bounded reachability. To the best of our knowledge, absence of livelocks has never been verified in the context of behavioral UML models. We implemented our approach to verifying UML models with respect to LTL safety properties and cycle-livelocks in a tool called soft-UMC (software-based UML Model Checking). Our tool is built on top of the software model checker CBMC [8] which applies BMC to C programs and safety properties. We ran it on several UML examples and interesting properties, and found erroneous behaviors and livelocks. For safety properties, we also compared soft-UMC with an IBM research tool that verifies UML models via a translation to IBM\u8217\'e2\'80\'99s haprdware model checker RuleBasePE [24]. Our experiments show that soft-UMC is more scalable and more robust for finding long counterexamples.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Our experimental results also demonstrate the usefulness of the optimizations applied in the creation of the verifiable C code.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
UML objects process events. Event processing is defined by statecharts [13], which extend conventional state machines with hierarchy, concurrency and communication. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Objects communicate by sending events (asynchronous messages). \uc3 \u8592\'e2\'86\'90 wha? they communicate also with synchronous messages! But I guess this is fit for a different purpose\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Events are kept in an event queue (EQ), managed by an event queue manager (EQ-mgr). When object A sends an event to object B, the event is inserted into the EQ. The EQ-mgr executes a never-ending event-loop, taking an event from the EQ, and dispatching it to the target object. If the target object cannot process the event, the event is discarded. Otherwise, the event is consumed and the target object makes a run-to-completion (RTC) step, where it processes the event, and continues execution until it cannot continue anymore. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We also place restrictions on the action language and disallow dynamic allocation of objects and memory, dynamic pointers, unbounded loops, and recursion. \uc3 \u8592\'e2\'86\'90 I also place a restriction on recursion! \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A Kripke structure is a tuple M = (S, I0 , R), where S is a set of states, I0 \uc3 \u8838\'e2\'8a\'86 S is a set of initial states, and R \u8838\'e2\'8a\'86 S \uc2 \u215\'c3\'97 S is a total transition relation. An execution of M is an infinite set of states s0 , s1 , ... s.t. for every i \uc3 \u8805\'e2\'89\'a5 0, (si , si+1 ) \u8712\'e2\'88\'88 R. \~The Linear-time Temporal Logic (LTL) [21] is suitable for expressing properties of a system along an execution path. We assume the reader is familiar with LTL. In this work we restrict ourselves to a fragment of LTL, in which only safety properties are expressible. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
These are properties whose }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
violation occurs along a finite execution}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 \uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for meeting and future work: could this be the problem? That with some properties the violation occurs along an infinite execution trace? (livelocks?) And this cannot be captured with a monitoring automaton.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A general method for on-the-fly verification of LTL safety properties is based on a construction of a regular automatonA\uc2 \u172\'c2\'ac\u968\'cf\'88 , which accepts exactly all the executions that violate \u968\'cf\'88. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Bounded Model Checking (BMC) [3] is an iterative process for checking models against LTL formulas. The transition relations for a Kripke structure M and its specification are jointly unwound for k steps and are represented by a boolean formula that is satisfiable iff there exists an execution of M of length k that violates the specification. The formula is then checked by a SAT solver. If the formula is satisfiable, a counterexample is extracted from the output of the SAT procedure. Otherwise, k is increased. The atomic unit in our translation is a single RTC step, rather than a single transition. (Run To Completion). The EQ is represented as a bounded array. The main method of the program executes the never-ending loop of taking an event from the EQ, and dispatching it to the relevant target object. C code can be automatically generated by UML tools such as Rhapsody, but this code would not be suitable for verification. We, on the other hand, are interested in verifying only the user-created behavior of the system, and therefore we can abstract the event queue and the operating system. A behavioral UML model M can be viewed as a Kripke structure M = (S, I0 , R), where S is the set of all possible CONFs in M. R can be defined either at the RTC level (denoted RRT C ) or at the transition level (denoted Rt ). }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We now show how to verify safety LTL properties over behavioral UML models using an automata based approach. We assume the atomic propositions of the property are predicates over the CONFs of the model. We extend the C program created from M with a method representing the automaton A\uc2 \u172\'c2\'ac\u968\'cf\'88 . \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The method runs in lock step with the system, and identifies property violations. \uc3 \u8592\'e2\'86\'90 for ppt: monitoring automaton \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A Livelock describes the case where part of the system cannot progress, even though the other parts of the system do. In this section we focus on finding livelocks in behavioral UML models. As mentioned before, absence of livelocks in neither safety nor LTL property and therefore cannot be handled by scalable bounded model checking tools. For that reason, we identify a subclass of livelocks, and present a method for finding }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
such livelocks within our framework. This is done by a reduction to a safety property, which requires a preceding syntactic analysis of the UML model.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Following, we present a characterization for a subclass of livelock CONFs, which we call }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
cycle-livelocks. Intuitively, a CONF C is a cycle-livelock if there is a subset of objects that are stuck at C, and for every object o in the subset all of the producers of events that o is stuck on, and all of the modifiers of the guards that o is stuckon, are in the subset as well. his is because all objects that may \uc3 \u8220\'e2\'80\'9crelease\u8221\'e2\'80\'9d a stck object by producing an event or changing a guard are in the same set. That is, they are stuck as well. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
There is one subtle point that still needs to be solved: We need a finite epresentation of the queue. Recall that for verifying safety properties, for k-bounded executions we bound the queue to k. However, when searching for cycle-livelocks this is incorrect because a configuration is cycle-livelock if there are }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
no future}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
executions that can release the stuck states. Thus, we must keep track of all events inserted into the queue (within k RTC steps). }
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We have implemented the algorithm described above in a tool called Soft-UMC (software-based UML Model Checking). The implementation reads a UML (version 2.0) model, and translates it to verifiable C code. Static analysis is applied at this stage, according to the type of property to be checked: (LTL) safety or livelock. We then apply CBMC[8] (version 4.1) as our C verifier. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Our approach to finding cycle-livelocks in UML models is novel. Static analysis identifies syntactically potential cycle-livelock states. A suitable finite representation of the event queue then enables to apply BMC for finding reachable such states. We expect similar approaches to be useful for proving additional non-safety properties.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
From Interaction Overview Diagrams to Temporal Logic}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this paper, we use UML Interaction Overview Diagrams as the basis for a user-friendly, intuitive, modeling notation that is well-suited for the design of complex, heterogeneous, embedded systems developed by domain experts with little background on modeling software-based systems. To allow designers to precisely analyze models written with this notation, we provide (part of) it with a formal semantics based on temporal logic, upon which a fully automated, tool supported, verification technique is built. The modeling and verification technique is presented and discussed through the aid of an example system. Modeling-verification-code generation are three pillars in the model driven development }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
of complex embedded systems; they are most effective when (i) modeling is based on user-friendly, intuitive, yet precise notations that can be used with ease by experts of domains other than computer science; (ii) rigorous, possibly formal, verification can be carried out on the aforementioned models, though in a way that is hidden from the system developer as much as possible; (iii) executable code can be seamlessly produced from verified models, to generate implementations that are correct by construction.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The plan is to exploit both \uc3 \u8220\'e2\'80\'9cconventional\u8221\'e2\'80\'9d UML diagrams [15] and a subset of the MARTE (Modeling and Analysis of Real-Time and Embedded systems) UML profile [14]. We want to use Class Diagrams to define the key components of the system. State Diagrams to model their internal behaviors, and Sequence and Interaction Overview Diagrams to model the interactions and cooperations among the different elements. These diagrams will be augmented with clocks and resources taken from MARTE. The result is a multi-faceted model of the system, automatically translated into temporal logic to verify it. Temporal Logic helps glue the different views, create a single, consistent representation of the system, discover inconsistencies among the different aspects, and formally verify some global properties.\uc1 }
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This paper starts from Interaction Overview Diagrams (IODs) since they are often neglected, but they provide an interesting means to integrate Sequence Diagrams (SDs) and define coherent and complex evolutions of the system of interest. IODs are ascribed a formal semantics, based on temporal logic, upon which a fully automated, tool supported, verification technique is built.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The choice of IODs as the starting point for a modeling notation that is accessible to experts of different domains, especially those other than software engineering, is borne from the observation that, in the industrial practice, SDs are often the preferred notation of system engineers to describe components\uc3 \u8217\'e2\'80\'99 behaviors [3]. However, SDs taken in isolation are not enough to provide a complete picture of the interactions among the various components of a complex system; hence, system designers must be given mechanisms to combine different SDs into richer descriptions, which is precisely what IODs offer.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this article we provide a preliminary formal semantics of IODs based on metric temporal logic. While this semantics is not yet complete, as it does not cover all possible mechanisms through which SDs can be combined into IODs, it is nonetheless a significant first step in this direction. The provided semantics has been implemented into the Zot bounded satisfiability/model checker [16]2, and has been used to prove some properties of an example system. \uc3 \u8592\'e2\'86\'90 this Zot model checker has two commiters in repository, it\u8217\'e2\'80\'99s an italian project. Blah.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
SDs have been considerably revised and extended in UML2 to improve their expressiveness and their structure. }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
IODs are new in UML2.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
They allow a designer to provide a high-level view of the possible interactions in a system. IODs constitute a high-level structuring mechanism that is used to compose sce}{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
narios through mechanisms such as sequence, iteration, concurrency or choice. IODs are a special and restricted kind of UML Activity Diagrams (ADs) where nodes are interactions or interaction uses, and edges indicate the flow or order in which these interactions occur.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Semantically, however, IODs are more complex compared to ADs and they may have different interpretations.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A control flow is a directed connection (flow) between two SDs (e.g., between diagrams delegateSMS and downloadSMS in Figure 2). As soon as the SD at the source of the flow is finished, it presents a token to the SD at the end of the flow. A fork node is a control node that has a single incoming flow and two or more outgoing flows. Incoming tokens are offered to all outgoing flows (edges). The outgoing flows can be guarded, which gives them a mechanism to accept or reject a token. In the IOD of Figure 2, there is one fork node at the top of the diagram (between the initial node and SDs waitingCall and checkingSMS ) modeling two concurrent execution of the system. The dual operator is the join node, which synchronizes a number of incoming flows into a single outgoing flow. Each (and every) incoming control flow must present a control token to the join node before the node can offer a single token to the outgoing flow. A decision node is a control node that has one incoming flow and two or more outgoing flows. In the IOD of Figure 2 there are four decision operators (e.g., the one between SDs waitingCall and delegateCall ) with their corresponding Boolean conditions. Conversely, a merge node is a type of control node that has two or more incoming flows and a single outgoing flow.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
TRIO [7] is a general-purpose formal specification language suitable for describing complex real-time systems, including distributed ones. TRIO is a first-order linear temporal logic that supports a metric on time. The TRIO specification of a system includes a set of basic items, such as predicates, representing the elementary modeled phenomena. The system behavior over time is formally specified by a set of TRIO formulae, which state how the items are constrained and how they vary in time, in a purely descriptive (or }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
declarative}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
) fashion. \uc3 \u8592\'e2\'86\'90 uhm, a set of formulae for describing system behavior? Not convenient! \u8592\'e2\'86\'90 declarative vs procedural\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The goal of the verification phase is to ensure that the system S satisfies some desired property R, that is, that S |= R. In the TRIO approach }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
S and R are both expressed as logic formulae \uc3 \u8592\'e2\'86\'90 OY OY OY\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The formalization is organized into sets of formulae, each of them corresponding to one of the SDs appearing in the IOD.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
They assume total ordering of messages and blabla bullshit; But important to take away is that Interaction Overview Diagrams are maybe useful, rather than using a combo of Interactions and Activity Diagrams.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Finally, if n is the number of occurrences of invocations involving object A, in the IOD, formula (25) states that all executions involving A are mutually exclusive. \uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
BIGGEST TRAP, DOES NOT HOLD IN DISTRIBUTED SETTING! \uc3 \u8592\'e2\'86\'90 maybe quote it for ppt ? As an example of the faulty reasonings.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The property checks all seem to be in the format cause=>effect.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
There is no state space generation since it\uc3 \u8217\'e2\'80\'99s deduction formulas. Not very useful.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We measure the complexity of the translation in terms of the number of predicates and the size of the TRIO formulas that are produced }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\ulnone\ulc0\animtext0\rtlch \ltrch
\uc3 \u8220\'e2\'80\'9c\uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Finally, since every object is blocked while sending or receiving a message, in every SD\uc3 \u8221\'e2\'80\'9d \~\u8592\'e2\'86\'90 for ppt cite this as well!? Misconception.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Finally, since every object is blocked while sending or receiving a message, in every SD every execution occurrence cannot be true at the same time instant as another execution occurrence. This can only happen if the execution occurrences are inside diagrams that can be executed in parallel (because of fork operators). \uc3 \u8592\'e2\'86\'90 okay they do mention it here ...\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Many works focus on the separate formalization of sequence diagrams and activity diagrams. St \uc2 \u776\'cc\'88rrle analyzes the semantics of these diagrams and proposes an approach to their formalization [18]. More recently, Staines formalizes UML2 activity diagrams using Petri nets and proposes a technique to achieve this transformation [17]. Also, Lam formalizes the execution of activity diagrams using the \u960\'cf\'80 \uc3 \u8722\'e2\'88\'92 Calculus, thus providing them with a sound theoretical foundation [13]. Finally, Eshuis focuses on activity diagrams, and defines a technique to translate them into finite state machines that can be automatically verified.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Other works investigate UML2 interaction diagrams. Cengarle and Knapp in [6] provide an operational semantics to UML 2 interactions, and in [5] they address the lack of UML interactions to explicitly describe variability and propose extensions equipped with a denotational semantics. Knapp and Wuttke translate UML2 interactions into automata and then verify that the proposed design meets the requirements stated in the scenarios by using model checking. \uc3 \u8592\'e2\'86\'90 I have the paper, it\u8217\'e2\'80\'99s \u8220\'e2\'80\'9cModel checking of UML 2.0 interactions\u8221\'e2\'80\'9d\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
When multiple scenarios come into play, like in IODs, there is the problem of finding a common semantics. Uchitel and Kramer in [19] propose an MSC-based language with a semantics defined in terms of labeled transition systems and parallel composition, which is translated into Finite Sequential Processes that can be model-checked and animated. Harel and Kugler in [10] use Live Sequence Charts (LCSs) to model multiple scenarios, and to analyze satisfiability and synthesis issues. To the best of our knowledge very little attention has been paid to IODs. Kloul and K \uc2 \u776\'cc\'88ster-Filipe [11] show how to model mobility using IODs and propose a formal semantics to the latter by translating them into the stochastic process algebra PEPA nets. Tebibel uses hierarchical colored Petri nets to define a formal semantics for IODs [4]. Our work is quite different, because it uses metric temporal logic to define the semantics of IODs; as briefly discussed in Sections 1 and 6, this opens many possibilities as far as the range of properties that can be expressed and analyzed for the system is concerned.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
They don\uc3 \u8217\'e2\'80\'99t show InteractionFragments at all.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A Logic-based Semantics for the Verification of Multi-diagram UML Models > Same authors as above, with this italian Zot model checker where the system is translated in a set of formulas. B.S.!}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This paper addresses a significant and consistent set of UML diagrams, called MADES UML, and uses a metric temporal logic to ascribe a formal semantics to them. It also introduces a prototype verification tool based on a bounded model/satisfiability checker. \~\uc3 \u8592\'e2\'86\'90 their case study is different only; used to be a telephone system, now it\u8217\'e2\'80\'99s a car collision avoidance system\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
If we think of UML as a graphical representation of a well-known programming language (e.g., Java), the subset of the notation usually considered is limited, and the actual semantics is borrowed from the target language. In contrast, if we considered UML as a \uc3 \u8220\'e2\'80\'9cpure\u8221\'e2\'80\'9d modeling notation, a more precise definition of the meaning of its elements would allow users to reason on designed models. \u8592\'e2\'86\'90 for ppt?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To this end, this paper proposes a semantics based on a metric temporal logic to provide a significant subset of UML with a consistent and coherent interpretation. This subset is called MADES UML, after the project in which it was defined. }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
MADES deals with model- based development of reactive, (time) critical embedded systems, hence MADES UML is particularly well-suited for modeling this category of systems.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 \~\uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
actually, good to know that this methodology is suitable only for reactive embedded systems. for ppt: maybe I should describe the category}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
It includes: (a) Class diagrams and Object diagrams, to model the static parts of the system and define the alphabet of the specification, (b) State diagrams, to model the behavior of the different elements, \~}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
(c)}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Sequence diagrams, to model the \uc3 \u8220\'e2\'80\'9clocal\u8221\'e2\'80\'9d interactions among the components, and (d) Interaction Overview diagrams, to relate the different sequence diagrams, and describe more complete, general, and system-wide interactions \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
[OMG10b]. Clocks, taken from MARTE [OMG09], add the time dimension and constrain the behavior of components. Designed models are rendered in terms of predicates and axioms written in \~TRIO [CCC+ 99], which is a first-order linear temporal logic that supports a metric on time. \~The use of a logic formalism for ascribing the semantics to UML diagrams. We believe that, unlike more common notations like Petri nets, automata, and transition systems, logics offers the flexibility and scalability we need to formalize a wide and rich notation like MADES UML. \uc3 \u8592\'e2\'86\'90 really?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A prototype verification tool that translates UML models (we are currently experimenting with the UML Modelio modeler) into the input language of Zot [PMS08], a bounded model/satisfiability checker, to provide users with a complete specification and verification environment. Zot has been preferred to tools like Isabelle/Hol [NPW02] because it is completely automatic and transparent to the user. The majority of the approaches that address the deisgn notation solely focuses on the structural aspects (namely, on the class diagrams), and the dynamic semantics of its behavioral diagrams such as activities, interactions and state machines, is still an open problem [BC11]. T}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
he existing work on the verification of OCL constraints against class diagrams [CCR08] is orthogonal to the formalization problem.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The OMG recently released fUML, which identifies a subset of the UML 2 meta-model to provide a shared foundation for higher-level UML modeling concepts. \~It does not address \uc3 \u8220\'e2\'80\'9cadvanced\u8221\'e2\'80\'9d UML diagrams such as sequence and state diagrams, and the fUML execution model is itself a model, written in fUML, that specifies how fUML models are to be executed. This circularity is broken by the separate specification of a base semantics for the subset of fUML actually used in the execution model. The execution model specifies how fUML models should be executed but it does not specify how to verify user-defined properties over all the possible execution traces. Moreover fUML does not analyze the semantics of time, concurrency and inter-object communication. If we consider multi-diagram UML models, the number of proposals is limited. The UML Semantics Project [BCD+ 06] developed a mathematically-formalized semantic definition of UML organized in three layers. The bottom one defines a universe of interacting state machines that describe the behavior of objects and their relationships with each other. Inter-object and intra-object behaviors are defined on top of these diagrams. Finally UML activities, state, and interaction diagrams rely on previously-defined actions to modify the state of the objects.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Class diagrams (CD) provide the static definitions of the elements in the system. Attributes and method parameters can be defined over the integers, over the reals, or finite subsets thereof. \uc3 \u8592\'e2\'86\'90 for ppt: mention that you use class diagrams as well (for types/arguments of class operations)\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
State diagrams (STD) can be used to describe the behavior of (significant) system objects. Sequence diagrams (SD) describe partial behaviors of the system. They describe the messages exchanged between the objects defined in the OD. The messages should be instances of the operations defined in the CD for that object. Interaction Overview diagrams (IOD) constitute a high-level structuring mechanism that is used to compose SDs through standard operators such as sequence, iteration, concurrency or choice. The different diagrams share a common set of events. Interrupts, beginnings and ends of messages, clock ticks, execution occurrences of SDs, and states entered and exited are only some examples of all the events considered in MADES UML; To this end, our approach supports the analysis of partial models by simply avoiding the translation of the diagrams the user is not interested in. This results in a \uc3 \u8220\'e2\'80\'9clightweight\u8221\'e2\'80\'9d approach, in which the user can focus the verification on the parts of the model that are really involved in the properties to be proved, without the need for translating the entire UML model.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The semantics of MADES UML is defined in TRIO [CCC+ 99], which is a first-order linear temporal logic (}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
LTL)}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
that supports a metric over time. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Objects which are inside an execution occurrence must be considered busy. \uc3 \u8592\'e2\'86\'90 but what if multiple processes execute the same operation. is it twice busy? :D\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The IOD is a special type of Activity Diagram where the activity nodes are SDs. \~The formalization in temporal logic of STDs (SMs) is fairly standard.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Time Constraints. Both SDs and STDs can include time constraints between pairs of events included in the diagram (Figure 1). Time constraints are included in the UML/MARTE specification [OMG09]. A time constraint is an inequality between two events. For reasons of brevity we do not show the entire axiomatization of time constraints.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
SD parameters are useful to create a correspondence between values exchanged by the objects of an SD, typically through the actual parameters of the operations invoked; }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In the MADES UML notation, parameters (of SDs or of operations) can be arbitrary integers, and the semantics describes some rules for their evolution, something that in literature is mostly lacking \uc3 \u8592\'e2\'86\'90 for ppt, I deal with them!!!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To implement in practice this kind of semantics, which includes arithmetic constraints such as v = Past(v, 1), which states that the value of v in the current instant is the same as the value at}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
the previous instant, we use the features offered by Satisfiability}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Modulo Theories (SMT) solvers; \uc3 \u8592\'e2\'86\'90 with process algebra keeping the value from one instant to another is natural;\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To carry out these activities in practice, a prototype tool has been implemented to produce formulae written in the input syntax of the Zot bounded model/satisfiability checker }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The capabilities of the Zot tool have been used also to validate the semantics proposed in Section 4, for example by producing traces compatible with snippets of the diagrams that we checked for conformity with the desired dynamics. \uc3 \u8592\'e2\'86\'90 for ppt definitely, to check the validity of the transformation\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The CCAS is modeled with one CD, one OD, one IOD, two SDs (sendSensorDistance, sendBrakeCommand), and three STDs (corresponding to the objects declared in the OD). \uc3 \u8592\'e2\'86\'90 for ppt: trivial example!? \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In fact, it can be the case that different UML diagrams are inconsistent because, for example, the information provided in a view violates the constraints imposed by another view. To answer this first question, it is enough to feed Zot with the formal model, then ask the tool to check its satisfiability; in case the model is satisfiable, Zot produces a valid trace of the system; otherwise, in case of inconsistencies, Zot indicates that the model is unsatisfiable. \uc3 \u8592\'e2\'86\'90 CASE tools like RSA have already this built in\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The paper proposes a complete and coherent semantics (based on a metric temporal logic) for MADES UML. In contrast to most existing proposals, which focus on limited sets of diagrams, our approach addresses a significant set of modeling elements and diagrams, and provides users with a solution usable for the design and analysis of a wide family of software systems. The proposed semantics is presented through its predicates and axioms, while a first assessment is based on an example car collision avoidance system.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Again, InteractionFragments not tackled. Also, how about larger models?}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
On the relationship between modeling and programming}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Model checking of UML 2.0 interactions (2007)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
- good explanation of an observer automaton}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
- this should be my CORE starting point for future work, inspiring!}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We describe a translation of UML 2.0 interactions into automata for model checking whether an interaction can be satisfied by a given set of message exchanging UML state machines. The translation supports basic interactions, state invariants, strict and weak sequencing, alternatives, ignores, and loops as well as forbidden interaction fragments. The translation is integrated into the UML model checking tool HUGO /RT. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We propose a translation of UML 2.0 interactions into automata. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This synthesised operational behaviour description can be used to verify that a proposed design meets the requirements stated in the scenarios by using model checking. On the one hand, the translation comprises basic interactions of partially ordered event occurrences, state invariants, the interaction combination operators for weak and strict sequencing, parallel and alternative composition, as well as a restricted form of loops, which can have potentially or mandatorily infinitely many iterations. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
On the other hand, besides these uncontroversial standard constructs, we also handle a classical negation operator [3], which avoids the introduction of three-valued logics as suggested by the UML 2.0 specification by resorting to binary logic. A system of message exchanging UML state machines together with the generated automaton representing a UML interaction for observing message traces is translated into the input language of an off-the-shelf model checker, which then is called upon to check satisfiability. Currently, we support interaction model checking over state machines with S PIN [6] and, partially, with U PPAAL [7]. \uc3 \u8592\'e2\'86\'90 brilliant, try this really! Especially see how it goes with SPIN, what the automata looks like!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Vertical juxtaposition of interaction fragments implies}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
weak sequencing}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
, such that in the second operand of the alternative the sending of c, active on obj1, comes before any event on obj1 inside the not fragment, and the receiving of c before any event on obj2. Both operands to alt are guarded by conditions, which determine which operands can be chosen at \uc3 \u8220\'e2\'80\'9cruntime\u8221\'e2\'80\'9d. \u8592\'e2\'86\'90 weak sequencing is for interaction fragments; The primitive interaction fragments we consider are basic interactions, consisting of a set of event occurrences with a \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
partial order }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
[1, p. 410], and state invariants for a single or several lifelines that has to hold if the state invariant is reached. Of the interaction operators [1, p. 410\uc3 \u8211\'e2\'80\'93412], we consider weak (seq) and strict sequential composition, parallel composition (par), alternative (alt), weak and strict sequencing loop, ignore of messages not mentioned, and a binary negation (not). \u8592\'e2\'86\'90 partial order is for message occurrences, or \u8220\'e2\'80\'9cprimitive interaction fragments\u8221\'e2\'80\'9d\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt: We interpret a UML 2.0 interaction as an observer of the message exchanges and state changes in a system. Whenever the system under observation sends or receives a message or one of its objects terminates successfully, the observer is notified and can act accordingly by making a move accepting the event or by producing a failure. However, it may also refrain from doing so, if it does not deem the state change relevant. Taking such an observer to be an automaton accepting words of system changes, i.e. state changes or events, }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
the acceptance conditions for finite and infinite runs can be rendered as the corresponding ones in finite state machines and B \uc2 \u776\'cc\'88 chi automata [8].\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Interaction automata, realising such an observer from an interaction by a state-transition system, are defined over an interaction alphabet (L, E, \uc2 \u931\'ce\'a3) of a finite set of involved lifelines L, a set E of termination, send and receive events from messages exchanged between the lifelines, and a set \u931\'ce\'a3 of system states. The transitions outgoing from a state define a set of events that, when occurring, enable the transition. Moreover, transitions may be guarded by conditions arising from the conditions in the interaction. Finally, an interaction automaton may also use and manipulate a set of counters V that allow to record how often lifelines in loops have executed. A run of an interaction automaton N: N accepts a finite run, if this run reaches a state in the accepting states A of N , and it accepts an infinite run if this run reaches one of N \uc3 \u8217\'e2\'80\'99s recurrence\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
states R infinitely often. It may be noted that although we define interaction automata to be finitely represented, the configuration space may be infinite due to unbounded increases of counters. However, for bounded interactions, in which no lifeline in a loop is allowed to proceed arbitrarily in advance with respect to another lifeline in the loop [9], the configuration space can be kept finite, and even for unbounded interactions, the system under observation may not produce runs that exhibit unbounded differences between counters. \uc3 \u8592\'e2\'86\'90 WTF? \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We translate UML 2.0 interactions into interaction automata }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
following the generally agreed upon semantics of basic interactions, state invariants, and the interaction operators seq, strict, par, alt, ignore, and, in a restricted form, loop [3,4]. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Furthermore, we handle a binary logic not operator; not and loop are restricted to basic interactions \uc3 \u8592\'e2\'86\'90 we don\u8217\'e2\'80\'99t restrict \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
loop}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
to basic interactions..}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In contrast to other approaches (e.g. [10,11]) we propose not to generate one automaton for every object in an interaction, but to use only a single observing interaction automaton for the entire interaction. This single automaton represents the property to be checked by a model checker. Our translation of basic interactions is a simplified version of the construction for Live Sequence Charts (LSCs) given by Brill et al. [12], the handling of weak sequencing cuts down techniques of Alur and Yannakakis for bounded MSCs [9]. These interaction fragments form the primitive blocks in our translation procedure and have to be represented as interaction automata directly. }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
\uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Entire section 4.1 on translating the basic building blocks.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Negation. We replace UML 2.0\uc3 \u8217\'e2\'80\'99s notorious negation operator neg by a binary logic variant not which simply accepts all those traces that are not valid for its operand. However, an algorithm for negating general interaction automata is out of reach. \u8592\'e2\'86\'90 this is the problem, I need the negation of an automaton \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The negation operation on these interaction automata basically means that all accepting states become non-accepting states and all non-accepting states become accepting states in the negated automaton. A new recurrent state is added, and from all complemented states transitions to this accepting state are added to accept all events that were not accepted in the corresponding state of the original automaton.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This additional accepting state is also equipped with a self-loop accepting all possible events.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We apply interactions as observers in model checking by translating the generated interaction automata into observing processes in the model checker S PIN. The system to be observed are message exchanging UML state machines. S PIN is called upon to check whether there is a run of the UML state machines that is accepted by the observer interaction automaton. The translation of UML state machines into S PIN, the translation from UML 2.0 interactions into interaction automata, and the translation of interaction automata into S PIN are integrated into the UML model checking tool H UGO /RT.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for pp: The counters of an interaction automaton are represented as variables of the observing process. For recording events }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
the system is instrumented to communicate with the observer via rendezvous channels: Each time a message is sent or received, or a state machine terminates successfully the observer is notified. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Over time there have been various approaches to formalising scenario descriptions}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Klose [17] proposes an automaton-based interpretation of LSCs and gives a}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
n algorithm to create automata out of basic LSCs}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. Harel and Maoz [19] propose to port the semantics of LSCs to UML 2.0. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
With CHARMY, Autili et al. [20] present a tool based on an approach similar to ours. The focus of C HARMY are architectural descriptions and the verification of their consistency. The semantics of interactions, given by their translation rules, however, deviates substantially from what can be gleaned from the UML 2.0 specification. Furthermore, in the program version we tested, combined fragments are not supported. \uc3 \u8592\'e2\'86\'90 for future work, try all actual tools for support of all!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for future work below:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Since in the current implementation loop and not are restricted in terms of operands, one direction of future work will be to detail to which extent these restrictions can be removed. We also intend to integrate the remaining operators specified by the UML 2.0 specification, which we have disregarded so far. Furthermore, the specification patterns for scenarios described by Autili et al. [20] should be combined with our approach. Finally, we plan to integrate timing constraints and to enhance the translation of interactions into the real-time model checker U PPAAL.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt!! Entire Section 2:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
UML 2.0 interactions consist of interaction fragments. These fragments can be occurrence specifications, specifying the occurrence of events within an object that is participating in the interaction. Sets of occurrence specifications, which we call basic interactions, and combined}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
fragments aggregate occurrence specifications into bigger interaction fragments. A combined fragment comprises an operator, defining the meaning of the particular fragment, and one or more operands. The operands are interaction fragments themselves, and can be guarded by an optional condition, limiting the possibilities for when this operand may be executed. The example in Fig. 1 shows instances of the important aspects of a UML 2.0 interaction. The two objects obj1 and obj2 exchange messages, specified by message occurrence specifications on their respective lifelines.3 Weak sequencing is implicit in the second operand of the alternative, such that the sending of c, active on obj1, comes before any event on obj1 inside the not fragment, and the receiving of c before any event on obj2. Both operands to alt are guarded by conditions, which determine the operand that needs to be chosen at \uc3 \u8220\'e2\'80\'9cruntime\u8221\'e2\'80\'9d. Furthermore, the two operators (alt and not) occur on different levels of nesting, showing how larger, nested interactions can be composed.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The primitive interaction fragments we consider are basic interactions and state invariants. A basic interaction consists of a set of event occurrences with a partial order subject to the following constraints: The dispatch of a message, the send event, occurs before the arrival of the message, the receive event; all event occurrences active for the same lifeline are totally ordered; and a termination event (cross), if any, must be the last event on its lifeline. A state invariant defines a condition (in a rounded box) for a single or several lifelines that has to hold if the state invariant is reached.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 \uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt: great definition of partial ordering of events}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Moreover, UML 2.0 puts a number of interaction-building operators at the user\uc3 \u8217\'e2\'80\'99s disposal. In sequential composition, the behaviour of the resulting interaction is the behaviour of the first operand followed by the behaviour of the second operand. There are two kinds of sequential composition, which differ in the meaning of the word \u8220\'e2\'80\'9cfollowed\u8221\'e2\'80\'9d. Strict composition, denoted by the operator strict, requires the behaviour of the first interaction to be completely performed before starting with the behaviour of the second interaction. Weak composition (implicit or explicitly with seq) only requires the behaviour specified for an object in the first interaction to be completely performed before starting with the behaviour for that object in the second interaction.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Other operators currently supported by our implementation are parallel composition (par), alternative (alt), loop, ignore, and negation (not). Two parallel interactions are to be executed by interleaving. An alternative means to execute one of two given interactions; this may be a non-deterministic choice if the conditions of the alt fragment overlap. A loop repeatedly executes its operand between bounds m and n, where it has to iterate at least m times and at most n times. Standardly only the upper bound may be infinity. We, however, also handle loops where also the lower bound is infinite. If a loop requires k iterations, this amounts to the k-fold weak sequencing of the operand. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We restrict the use of weak sequencing loops to contain only a basic interaction, }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
but we also support an unrestricted operator sloop, which enforces strict sequencing of the operand.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The negation operator not is intended for the specification of forbidden behaviour and presents a simpler variant of the }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
controversial neg operator of UML 2.0:}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Everything but the precise behaviour of its operator is valid for not. Finally, ignore allows additional messages to occur besides the ones specified in its operand. \uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: the loop restriction is somewhat too restrictive, this means you can\uc3 \u8217\'e2\'80\'99t straightforwardly present a code like this: \u8230\'e2\'80\'a6 \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Interaction automata are defined over such an interaction alphabet and realise a finite description of an observer by a state-transition system. The transitions outgoing from a state define a set of events that, when occurring, enable the transition. Moreover, transitions may be guarded by conditions arising from the conditions in the interaction.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In order to reflect weak sequencing of interactions, the events and the guard of a transition show a set of lifelines, which are active when making a move by this transition. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Finally, an interaction automaton may also use and manipulate a set of counters that allow to record how often lifelines in loops have executed. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In concrete representations of interaction automata, we show states as ellipses and transitions as arrows. Accepting and recurrence states are doubly and triply outlined, respectively. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Transition inscriptions show (a description of) the set of accepted events \uc2 \u951\'ce\'b7, the guard condition g, and the action a in the format \u951\'ce\'b7[g]/a; any of these parts may be omitted and the active lifelines are left implicit.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In contrast to other approaches (e.g. [3, 16]) we propose not to generate one automaton for every object in an interaction, but to generate only a single observing interaction automaton for the entire interaction. This single automaton represents the property to be checked by a model checker.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Brill et al. [17] discuss the generation of automata for basic LSCs. Our translation of basic interactions is inspired by their algorithm. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Loops. The UML 2.0 defines loops which have a lower and an upper bound for the number of iterations their operand has to perform; the lower bound has to be finite, while the upper bound may be infinity. We change this and also allow the lower bound to be infinity. This way we can specify loops that must not terminate. However, we restrict loops to contain only a basic interaction. For finite or infinite loops of a basic interaction the algorithm for unwinding a basic interaction can be reused. As weak sequencing is used for loops, the lifelines in the underlying basic interaction can make different progress. Thus the history stored in a phase for a basic interaction becomes insufficient for loops, as not all prerequisite events for a given event will be present in the history if the lifeline\uc3 \u8217\'e2\'80\'99s event is lagging behind the lifeline of one of its prerequisites. We introduce counters for recording the separate progress of each lifeline. It remains to ensure that the number of iterations of the loops indeed is between its lower and upper bound. If the lower bound is finite, a phase becomes accepting if the counters for all lifelines are equal and the counters are greater than or equal to the lower bound. If the upper bound is finite a new cycle of a lifeline may only be started, if the counter of the lifeline has not reached the upper bound. Finally, if either the lower or the upper bound of iterations is infinite, we also have to introduce a recurrent state which is run through every time the lifeline counters are equal. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Negation. We replace UML 2.0\uc3 \u8217\'e2\'80\'99s notorious negation operator neg by a binary logic variant not which simply accepts all those traces that are not valid for its operand. However, an algorithm for negating general interaction automata, in particular involving counters, is out of reach. Thus we restrict the application of not to basic interactions, such that the interaction automaton to be negated is deterministic and does not involve counters. \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The negation operation on these interaction automata basically means that all accepting states become non-accepting states and all non-accepting states become accepting states in the negated automaton. \uc3 \u8592\'e2\'86\'90 not really the correct interpretation? you negate actions (events). not states. The expressive power of the translation of not fragments could be greatly enhanced by adopting a general negation construction for non-deterministic B \uc2 \u776\'cc\'88 chi automata [19]; however, the size of the resulting automaton would be exponential in the size of the input automaton.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Parallel Composition. The parallel composition N1 N2 uses a construction very similar to the parallel composition of B \uc2 \u776\'cc\'88 chi automata [15], where a special counter k is employed to record if first N1 and then N2 are running through a recurrent state and only if both automata have run through a recurrent state, N1 N2 goes through a recurrent state. This construction only has to be adapted to cover that both or one of the interaction automata do not show recurrence states.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Weak Sequencing.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A slight modification of the construction for parallel composition can be used for obtaining the weak sequential composition \uc3 \u8592\'e2\'86\'90 for ppt if they ask? \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Strict}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Sequencing}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. The strict sequential composition N1 ; N2 is achieved by building an automaton which appends N2 at every accepting state of N1 \~}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Alternatives}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
. Thus, given interaction automata for each operand of an alt fragment, we integrate them into a single automaton with guarding transitions from a new initial state. The guards of these transitions show the conditions of the operands. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The translation of UML state machines into SPIN, the translation from UML 2.0 interactions into interaction automata as well as the translation of interaction automata into SPIN are integrated into the UML model checking tool HUGO /RT [12].}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For recording object terminations and the messages exchanged in the observed system, the system is instrumented to communicate with the observer via rendezvous channels: Each time a message is sent or received, or a state machine terminates successfully the observer is notified.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
These optimisations are done on the fly without constructing the product automaton. What is more, the unwind algorithm produces rather large automata, even with sharing: For n independent events on n lifelines the resulting number of states will be 2^n ; for n consecutive messages from one lifeline to another the number of states is (n + 2)(n + 1)/2. Thus it is beneficial to encode a phase not into the states of an interaction automaton, but to employ an external bit-array which encodes the progress of the phases and to use tests on this bit-array for checking whether an event can be accepted }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The case study seems to be smallish, only 3-4 diagrams! \uc3 \u8592\'e2\'86\'90 for future work!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We have presented a translation from UML 2.0 interactions into a special class of automata showing features of finite state automata, B \uc2 \u776\'cc\'88 chi automata and counter automata. These interaction automata have been further translated into concrete programs for model checkers. \~\uc3 \u8592\'e2\'86\'90 so the tool allows just creation of the automata, not the concrete SPIN code directly. Investigate!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The added expressiveness allows the use of our approach to specify properties which before would have required formalisms other than UML interactions. Furthermore, many of the operators now also allow shorter diagrams, because the new syntax makes explicit unwinding or repetition unnecessary.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Checking Properties Described by State Machines: On Synergy of Instrumentation, Slicing, and Symbolic Execution}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Finite State Machines as a formalism for describing properties}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
static analysis is flexible and scales well, but due to the overapproximation, many false positives. => better to use slicing}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
symbolic execution does not suffer from false positives, but the \uc3 \u8220\'e2\'80\'9cprogram\u8221\'e2\'80\'9d is run on symbolic input. Drawback - they detect low-level violations of programing language semantics. No idea about \u8220\'e2\'80\'9cthe design\u8221\'e2\'80\'9d (agnostic?)\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
they propose in the end a combination to get the best of both, using slicing}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
they instrument code that implements the state machine of the porperty}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
symbolic execution executes real program paths, only on symbolic input. They show that slicing makes it feasible}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Case study in C, only limited to locking errors state machine;}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
they use symbolic executor called KLEE. Case study is functions of the Linux kernel;}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
symbolic execution is the bottleneck in the chain, results show}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
There are several successful formalisms for description of program properties. One of the most popular is a finite state machine (FSM). This formalism is simple and still flexible enough to describe many often studied program properties including locking policy in concurrent programs, null-pointer dereferences, resource allocations, and resource leaks.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To sum up, static analysis tools like xgcc, ESP, and Stanse are highly flexible, fast and thus applicable to extremely large software projects (e.g. the Linux kernel). It examines all the code and finds many error reports. Unfortunately, many of the reports are false positives.1 As manual sorting of error reports containing a pile of false positives is tedious work, the practical applicability of such tools is limited.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In contrast to static analysis, test-generation tools based on symbolic execution do not suffer from false positives, since the checked program is actually executed (but on symbolic input instead of concrete one). In this paper, we introduce a new fully automatic program analysis technique offering flexibility of FSM property specification with zero false positive rate of symbolic execution. The technique symbolically executes only parts of the analysed program having impact on the checked property. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In our algorithm, the purpose of the instrumentation is to insert a code implementing a state machine into the analysed program. Nonetheless, the semantics of the program being instrumented must not be changed. A result of this phase is therefore a new program that still has the original functionality but it also simultaneously updates instrumented state machines. \~The instrumentation starts by recognizing code fragments which manipulate with locks in the analysed program. The input of the slicing algorithm is a program to be sliced and a so-called slicing criteria. A slicing criterion is a pair of a program location and a set of program variables. The slicing algorithm removes program statements that do not affect any slicing criterion. More precisely, for each input data passed to both original and sliced programs, values of the variable set of each slicing criterion at the corresponding location are always equal in both programs. It might be the case for some program and checked property, that the sliced code still contains loops. Then the subsequent symbolic execution can be very costly due to the well-known path explosion problem. Fortunately, there have been done some work tackling the problem. The framework provides us with a C compiler clang. We also use an existing symbolic executor for Llvm called Klee.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A Formal Semantics of UML Sequence Diagram (2004)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Formalisation is based on classic computational model of transition systems (?)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Useful for explaining \uc3 \u8220\'e2\'80\'9cpartial order\u8221\'e2\'80\'9d of messages in an SD \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
most informal parts of UML are links between different UML diagrams \uc3 \u8592\'e2\'86\'90 for ppt: some claim this is the blurries thing, others claim nesting of peculiar fragments like negation strict etc.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Need to formalize Class diagrams first}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
PA is natural for some aspects, not so natural for other aspects; example are }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
State Machines which are natural to model with PA, but barely used as the basis for large scale general-purpose OO systems; for concurrent systems even less}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In abstract syntax form, a well-formed sequence diagram corresponds to an ordered hierarchical structure tree. The static semantics of a sequence diagram is to check whether it is consistent with the class diagram declaration as well as with its well-formed tree structure. Meanwhile, the dynamic semantics is defined in terms of the state transitions that are carried out by the method invocations in the diagram. When a message is executed, it must be consistent with system state, i.e., object diagram and the state diagrams of its related objects. The semantics clearly captures the consistency between sequence diagram with class diagram and state diagram. Therefore, it is useful to develop the model consistent checking functions in UML CASE tools.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The Unified Modeling Language (UML) [6, 21] is a general-purpose visual modelling language that is used to specify, visualize, construct, and document the artifacts of a software system. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The motivation is to provide a natural and intuitive formal semantics of UML sequence diagram based on the people\uc3 \u8217\'e2\'80\'99s general understanding of object-oriented programming language\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
How can we check that a model of design correctly realizes a model of system requirements? \uc3 \u8592\'e2\'86\'90 for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For example, if a sequence diagram uses an object, the class (or type) of the object should be defined in class diagram. As for the second, we must guarantee that each use case can be realized by its corresponding sequence diagrams in the context of the design class diagram. }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
\uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: this is a thing of the past, UML tools have this built in}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Since we only consider the synchronous method call, the event of sending and receiving signals is ignored in this paper. We directly interpret the interaction between objects into object method invocation in object oriented programming language sense. Concurrency with asynchronous communication can be considered in an extension of this semantic model for component-based development [11]. Therefore, the object, method call and other concepts of object-oriented programming language can be used as basic concepts for defining the semantics of sequence diagram. The dynamic semantics of a sequence diagram in this paper is interpreted as a trace-based terminated process (thread) of CSP. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A class diagram \uc3 \u8710\'e2\'88\'86 of an application identifies the environment in which the sequence diagrams\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
operate. \~The dynamic semantics of a sequence diagram is to be defined in terms of state changes of the system. A state of the system with a given class diagram is in fact a UML object diagram of the class diagram. An object diagram is a snapshot of the class diagram which consists the information about what the current objects are, what the current links by associations among these objects are, and what the state of the objects are, i.e. the values of their attributes. Sequence diagrams are used to present the dynamic behavior of system design while class diagrams are system static structure. As one of two kinds of UML interaction diagrams, a sequence diagram shows interactions between objects arranged in a time sequence.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Before defining the semantics of sequence diagrams, we need to give the formal syntax of sequence diagrams. We introduce an ordered hierarchical structure tree to present well-formed sequence diagram for a thread with synchronous method calls. For the complex concurrent system with multithreads and asynchronous method calls can be defined based on this work.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
On the relationship between modeling and programing languages}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Software developers create and use models for a variety of purposes. For example, the following are three common forms of uses:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
= Models as sketches: Developers find it useful to sketch descriptions of requirements, design or deployment concepts on whiteboards or paper when discussing their ideas with other developers or customer representatives. This promotes communication?}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
= Models as analysis artifacts: Developers build analyzable models to check specified properties (e.g., consistency and satisfiability properties), to predict implementation qualities (e.g., performance), or to simulate implemented behavior. Included in this category of models are formal, non-executable specifications that can be statically analyzed, and executable models that support more dynamic forms of analysis. These models typically contain only the information needed to analyze target properties, and thus may not include information that is needed to generate full implementations. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
= Models as the basis for code generation or synthesis of software artifacts: Models can be built for the purpose of generating implementations, test cases, deployment or software configuration scripts, or other software artifacts. These models must contain all necessary information in a form that allow a generator to mechanically synthesize software artifacts.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
One of the most important uses of modeling techniques and languages is to build executable models. Executing a model often involves code generation. From a practical standpoint}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
it makes a difference whether the developer\uc3 \u8217\'e2\'80\'99s intent is to produce industrial-strength code when executing a model, or to produce code that animates modeled behavior to provide the developer with feedback on the adequacy of the model. Modeling languages that support the building of executable models can be viewed as approximate forms of very high-level programming languages, that is, languages above the current high-level general-purpose programming languages (GPL). We use the term \u8220\'e2\'80\'9capproximate forms\u8221\'e2\'80\'9d because we do not consider that current modeling languages can completely replace or mask out GPLs; there may be particular\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
algorithmic elements that probably cannot and should not be}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
modeled in a more abstract way than through statements in a GPL. The term \uc3 \u8220\'e2\'80\'9cvery high-level\u8221\'e2\'80\'9d is used to reflect our view that models are more abstract and compact than implementations expressed in a GPL. For example, technical details (e.g., details related to efficient implementations of complex data structures) and domain-specific functionality can be added through intelligent code generators and therefore need not be present in the model used to generate the code. First, there is currently no successful tight integration between modeling and programming technologies. Another major problem that the modeling community currently encounters is the lack of modularity. Good modularity allows a developer to encapsulate strongly related design concepts in a single code module (e.g., a procedure or class) and to expose only the information needed by other modules through an interface. This is the major driving force for incremental compilation, reuse, use of code libraries, dividing work amongst team members, and therefore provides the means to scale development projects. With the exception of Matlab/Simulink, today\u8217\'e2\'80\'99s modeling languages do not support the definition of an \u8220\'e2\'80\'9cinterface\u8221\'e2\'80\'9d for a model. The lack of interfaces leads to a different handling of models during the development process. Tools typically load a single large model in their workspace (we can be glad that we have enough space to actually do this) and therefore expose developers to all the details of the model. Any change in the model, no matter how small, typically enforces a complete regeneration. Models are thus monolithic entities that expose all details to developers. This makes reuse of models challenging and gets in the way of developing libraries of reusable model fragments. As long as we are not able to deal with models in a modular way, the cost of developing and using models of complex systems may outweigh the benefits of using the models in the development process.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The hidden models of model checking}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
What made this shift possible and what roles did models play in this? That is the main question we consider here. We survey approaches that transform domain-specific input models into alternative forms that are invisible to the user and which are amenable to model checking using existing techniques\uc3 \u8212\'e2\'80\'94we refer to these as hidden models. We observe that keeping these models hidden from the user is in fact paramount to the success of the domain-specific model checker.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: (google trends screenprint)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Model checking, since its introduction in the late 1970s, has become hugely popular, so much so that Clarke, Emerson and Sifakis received the 2007 Turing award for their pioneering work in the field. Although much of the early work on model checking focused on manual creation of models in the notation of the model checker\uc3 \u8217\'e2\'80\'99s input, as the field matured there was a shift to model checkers that directly take domain-specific notations as input. We believe this shift is what made model checking such a successful technique, since it not only allowed domain experts that do not know how a model checker works to use one, but also allowed the model checkers to exploit domain knowledge to become more efficient. We argue that the key to making domain-specific model checking possible is the use of hidden models that are used during the transformation of domain notations to model checking input to support efficient analysis and to allow domain-specific output to reach the user.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To make the intermediate model both hidden and efficient, are two very difficult goals Model checking is an algorithmic verification technique that is particularly effective for finite-state systems. It was co-invented by Clarke and Emerson [22] and Queille and Sifakis [86] over three decades ago}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt, visualise the stuff below, but also, show the modeling code to state transition system phase:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Model checking involves two inputs: a state transition system (S) that encodes a set of behaviors to be reasoned about and a temporal logic formula (\uc2 \u966\'cf\'86) that encodes a set of desirable behaviors. The model checking problem asks whether S is a logical model 1 of \u966\'cf\'86, i.e., whether the behaviors encoded by S satisfy \u966\'cf\'86. Algorithms for model checking are able to answer this question and when the answer is negative they produce a counterexample, i.e., a behavior encoded by S that falsifies \u966\'cf\'86. Counterexamples provide valuable information for locating errors in the transition system model or in the temporal logic formula.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
These approaches can be characterized in several dimensions, of which we consider three: (1) the language features of the models S, (2) the logics that can be used for describing properties over the models (\uc2 \u966\'cf\'86), and (3) the algorithms used to perform the analysis.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
With symbolic algorithms, the model and set of explored states are represented symbolically as Boolean formulae. For symbolic approaches, there are two main \uc3 \u8220\'e2\'80\'9cengines\u8221\'e2\'80\'9d that are used to solve the generated Boolean formulae: SAT/SMT solvers [38] and Binary-Decision Diagram solvers [12]. The choice of solver leads to different classes of algorithms for model checking.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
There are many model checkers available, but two of the most popular are Spin2 [54] and }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
NuSMV. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
On the upper right in Fig. 1 is a formula written in Spin\uc3 \u8217\'e2\'80\'99s syntax for LTL. This specification assumes that boolean variables are present in the system indicating when the system is initialized, when a resource is open and when it has been closed. The LTL formula states that after initialization a call to open will eventually be followed by a call to close. The open, close, and init must be defined in terms of the transition system model; they could capture the calls to a file open method, a file close method, and the creation of a file instance for a file API. Researchers have collected a variety of models from the literature [30,31] that illustrate the diversity of specification languages and properties targetted with model checking. <- Dwyer\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Here, we will assume all translations between models are correct, but it should be acknowledged that proving such translations correct are non-trivial. Environment model As stated in Sect. 2, model checkers analyze a closed system, i.e. a system composedwith its execution environment. The so-called Environment Model is often an abstraction (both under- or overapproximation) of the actual environment}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
When using an analysis technique such as model checking there is a system whose behaviors are the subject of the analysis. While a system might be expressed in any number of notations, typically, when working in a particular problem domain there are notations that are both familiar and convenient. For example, tele-communication protocols are often specified in SDL [60], software is expressed in its source language, such as Java, or C, and hardware components might be expressed as VHDL }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In Fig. 2, this semantic gap is addressed by \uc3 \u8220\'e2\'80\'9c(2) Intermediate Models\u8221\'e2\'80\'9d that transform the domain model to the input of the model checker. A successful domain specific model checker, bridges this semantic gap in a fully automated fashion. Requiring user assistance to construct this model means that only model checking specialists can use the system. Equally important, this effort must be repeated every time the system changes and is to be re-analyzed, significantly increasing the cost of analysis.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Historically, model checkers have been designed with problems in a specific domain of application in mind. For example, Spin was developed to reason about network protocols and, consequently, PROMELA is well-suited for expressing such problems. When applying model checkers beyond their originally intended domain of application, one often encounters significant semantic mismatches between domain-specific notations and model checker notations.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In achieving an efficient and effective translation. Initial efforts to model check Java programs using Spin [26,51] had to address the lack of heap allocated data, references, garbage collection, inheritance, and exception handling. It is widely accepted that automated techniques were needed to bridge the gap between domain models, e.g., Java programs, and model checker inputs, e.g., PROMELA, since relying on human users to express their problems in model checker notations is costly and error prone. Moreover, when counterexamples are produced they describe property violations in terms of the model checker\uc3 \u8217\'e2\'80\'99s input not the original\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
domain-specific model. Thus, a kind of reverse translation must be performed and not just once, but for every counterexample generated.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Finally, model checking tools are built to support the semantics of their input language. When expressing a domain model in such a language the semantics of the domain model are lost. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Creating the environment model is one of the most difficult parts of model checking [92], and we argue this is because there are no hidden models readily available to simplify the process for a domain expert.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In areas where there have been significant industrial success with software model checking systems, it is often the case that the domain has been limited to the extent that environment models can be created and packaged with the model checking system.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Unlike domain or environment modeling, the process of describing a desirable system property is much more focused. For example, after several decades during which competing temporal logics were used for specifying hardware properties in 2005 IEEE standardized the property specification language (PSL).}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
When a model checker detects a violation of a property it generates a representation of the ways in which the system\uc3 \u8217\'e2\'80\'99s behavior violates the specified property\u8212\'e2\'80\'94a counterexample. The nature of the counterexample depends on the type of specification. For example, the violation of a property stating that variable x is always positive would be described as a sequence of steps in the system execution, starting at the initial state and interacting with the environment model as appropriate that ends in a state in which x \u8804\'e2\'89\'a4 0.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
When a property is true of a domain model and its environment, there is the option that the wrong property was specified (or the property was specified incorrectly)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
When resource limits are exceeded, coverage data can also give an indication of the extent to which the model checking was able to explore the set of system behaviors. \~\uc3 \u8592\'e2\'86\'90 yeah, would be good for mCRL2\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
During the application of these reductions, models are created that preserve relevant behavior of}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
the original model, but simplify the model checking. Since those models only exist during the model checking run they are referred to as transient. Many reduction techniques can be viewed as constructing a transition system model that preserves the ability to answer the model checking question (or at least to answer it in the affirmative). For example, property directed model slicing [50] eliminates portions of the transition system that are provably unrelated to the temporal logic formula under analysis. Partial order reductions (POR), e.g., [41] and symmetry reductions [58] effectively ignore behaviors of the input transition system that are provably equivalent relative to the temporal logic formula under analysis. Essentially, they construct a reduced model on-the-fly during analysis. Predicate abstraction [44] techniques transform the transition system model by selectively replacing non-deterministic choice with abstracted branch predicates to sharpen the precision of analysis results while minimizing the cost of analysis.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In addition, as the formulae are being solved, it is often \~the case that the solver changes the formula encoding to make it more efficient to solve. For example, a Binary Decision Diagram (BDD) is a directed acyclic graph representation of a Boolean formula that is ordered by the Boolean variables in the formula. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
It became quickly apparent that the semantic gap could not be easily bridged and custom model checkers were developed instead [4,40,87,95]. These custom checkers took the original source code as input and were able to exploit the domain knowledge captured within the models to improve the model checking.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
An interesting case is the SPIN model checker [54] that in its early form only allowed PROMELA models, i.e. custom notation for modeling protocols, but now supports also the analysis of C code. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The Verisoft model checker [40] was one of the first to target source code and used an underlying logical model based on interleavings of concurrent statements. The C library code for threading was instrumented to allow all possible enabled actions to be executed. Furthermore, it was the so-called stateless model checking since no states were stored and executions were replayed from the start rather than use a backtracking based search. The logical model was thus a tree of concurrent transitions (or code segments) rather than the more common graph of states. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
JPF [95] and BOGOR6 [87] also support concurrent programs, but in this case Java programs. The logical model used in both cases is a graph of reachable states that allow one to check both safety and liveness properties However, the hidden models used here are more complex and based on executing Java bytecode.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
SLAM [4] and CBMC8 [21] only focus on sequential programs}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
, but use very different logical models: SLAM uses boolean programs derived from abstractions of C code and CBMC encodes the reachability problem for C/C++ programs as a satisfiability problem and uses a technique called bounded model checking to do the analysis.}
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Note that all software model checkers augment the classic programming languages they analyze with the capability of expressing non-deterministic choice. This capability allows one to specify (among other things) the range of possible inputs to be used when analyzing the program. Without a non-deterministic choice operation, useful environments cannot be generated and in some sense model checking degenerates to testing (in the sequential case at least; for concurrent programs the scheduler is still non-deterministic in general). For example, JPF has a highly user-customizable ChoiceGenerator framework that allows all forms of non-determinism, including custom data choices, scheduling choices, etc.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
Although model checking is historically focused on using temporal logic properties for analysis, software model checking tends to use only safety properties and not liveness properties. Stateless model checkers cannot handle liveness by definition since they cannot detect cycles}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
, but even model checkers like JPF and BOGOR do not support liveness; SPIN does support liveness but when using C code in the models, one must specify which part of the state must be tracked during model checking (exposing the hidden model). }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
The most common types of properties are simply local safety properties in the form of assertion violations}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
(including contracts) or uncaught runtime exceptions (for example null pointer dereferences). }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
Another class of property is finite-state machine properties, such as every open should be followed by a close operation. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The internal optimizations used in software model checking are numerous, but essentially two techniques stand out: partial-order reductions [41] and predicate abstraction [44]. Partial-order reductions reduce the number of interleavings that need to be analyzed during model checking of concurrent programs, by not considering interleavings of independent transitions. The dependency information was traditionally determined by a static analysis before model checking, but due to the dynamic nature of software, dynamic partial-order reduction [37] is more popular in software model checking. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Where partialorder reduction is a precise abstraction of the original program (i.e. no behaviors are added or removed) the boundedcontext switching approach is an under-approximation that}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
could miss errors.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The underlying technology required for predicate abstraction (as well as symbolic execution) is decision procedures for satisfiability that can reason over the domain of the program instructions, e.g. linear integer arithmetic, strings, arrays, bitvectors, etc. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Hardware designers use hardware description languages (HDLs) to describe the design of electronic circuits. The two most popular languages are Verilog [89] (and its superset SystemVerilog [88]) and VHDL [56], though there are a wide range of notations that are used.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Synthesis revisited: Generating statechart models from scenario-based requirements}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
mind you, this is for reactive systems / embedded systems...not sure if it fits}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this paper we describe a methodology for synthesizing statechart models from scenario-based requirements. The requirements are given in the language of live sequence charts (LSCs), and may be played in directly from the GUI, and the resulting statecharts are of the object-oriented variant, as adopted in the UML. We have implemented our algorithms as part of the Play-Engine tool and the generated statechart model can then be executed using existing UML case tools. Scenario-based inter-object specifications (e.g., via live sequence charts) and state-based intra-object specifications (e.g., via statecharts) are two complementary ways to specify behavioral requirements. In our synthesis approach we aim to relate these different styles for specifying requirements. The main motivation for suggesting the use of LSCs as a requirement language in [10] is its enhanced expressive power. LSCs are an extension of message sequence charts (MSCs; or their UML variant, sequence diagrams) for rich inter-object specification. One of the main additions in LSCs is the notion of universal charts and hot, mandatory behavior, which, among other things, enables one to specify forbidden scenarios. Synthesis is considerably harder for LSCs than for MSCs, and is tackled in [10] by defining consistency, showing that an entire LSC specification is consistent iff it is satisfiable by a state-based object system. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: There are several issues that have prevented the approach described in [10] from becoming a practical approach for developing complex reactive systems. A major obstacle is the high computational complexity of the synthesis algorithms, that does not allow scaling of the approach to large systems. Additional problems are more methodological, related to the level of detail required in the scenarios toallow meaningful synthesis, the problem of ensuring that the LSC requirements are exactly what the user intended, and a lack of tool support and integration with existing development approaches. We suggest a synthesis methodology that is not fully automatic but rather relies on user interaction and expertise to allow more efficient synthesis algorithms. One of the main principles we apply is that the specifier of the requirements provide enough detail and knowledge of the design to make the job easier for the synthesis algorithm. The algorithm tries to prove, using verification methods, that a certain synthesized model satisfies all requirements; if it manages to do so, it can safely synthesize the model. We have developed a prototype statechart synthesis environment, that receives as input LSCs from the Play-Engine tool [13] and generates a statechart model that can then be executed byRhapsody [15], and in principle also by other UML tools}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
An important usage of scenario notations is for communicating ideas and for documentation. For such purposes sketching an inter-object scenario on a blackboard or diagram editor can be very helpful. When our goal is synthesizing a statechart model and eventually production code from the scenarios, we need a powerful and expressive inter-object scenario-based language with rigorously defined semantics. The language should still retain the simplicity and intuitive feel that made scenario-based languages popular among engineers. In our approach we use the language of live sequence charts (LSCs) introduced in [7]. LSCs extends classical message sequence charts, which have very limited expressive power. Among other things, LSCs distinguish between behaviors that may happen in the system (existential) from those that must happen (universal). According to this argument it is not possible to beneficially apply a synthesis approach for deriving a system implementation since the requirement model provides insufficient details. We attempt to overcome this challenge by using the play-in/play-out approach introduced in [13, 14]. In play-in the user starts with a graphical representation of the system and specifies various scenarios by interacting with the GUI and demonstrating the required behavior. As this is being done, the Play-Engine tool constructs the LSC that captures what was played in. \uc3 \u8592\'e2\'86\'90 weird We try to address this challenge in several complementary ways. First, the requirement language of LSCs, being an extension of classical MSCs, has intuitive semantics, and allows users who are not very technical to express complex behavioral requirements, while other formalisms, e.g., temporal logic, may prove to be trickier even for advanced users.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Scenario-based inter-object specifications (via LSCs) and state-based intra-object specifications (via statecharts) are two complementary ways for specifying behavioral requirements. In our synthesis approach we aim to relate these different styles for specifying requirements. According to the play-in/play-out approach the user specifies behavioral requirements by playing on a GUI representation of the system, as this is being done the Play-Engine automatically constructs corresponding requirements in LSCs.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
specifies a formalized representation of objects and classes and methods, via tuples with mathematical notations...not very complex, understandable, but then what?}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
LSCs as a declarative, inter-object behavior language, enables formulating high level requirements in pieces (e.g., scenario fragments), leaving open details that may depend on the implementation. The partial order semantics among events in each chart and }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
the ability to separate scenarios in different charts without having to say explicitly how they should be composed }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
are very useful in early requirement stages, but can cause under-specification and nondeterminism when one attempts to execute them. \uc3 \u8592\'e2\'86\'90 bold for ppt, ADs come to the rescue\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In order to apply the synthesis approach we encode play-out in the form of a transition system and then apply model-checking techniques. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We construct a transition system which has one process for each actual object.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 \uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
another paper constructs a single automaton for the property, isn\uc3 \u8217\'e2\'80\'99t that more convenient? \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A state in this system indicates the currently active charts and the location of each object in these charts. The transition relation restricts the transitions of each process only to moves that are allowed by all currently active charts. We now providesome more of the details on how to translate LSCs to a transition system. The encoding of the transition relation was developed as part of our work on smart play-out. We use the asynchronous mode, in which a send and a receive are separate events, but we support the synchronous mode too. The details of encoding the transition relation are rather technical, for more information see [11]. The basic synthesis scheme generates a statechart for each of the participating objects, using orthogonal states for implementing different scenarios and making use of additional events to guarantee synchronization of the distributed objects along each behavioral scenario. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The Antenna object, which is now in the sub-state P 1 of the OpenAnt component, takes the null}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
transition to state S0. Null transitions are transitions with no trigger event, and are taken spontaneously. \uc3 \u8592\'e2\'86\'90 wtf?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
here are several points were the synthesis algorithm can be optimized to produce more efficient and readable models, and indeed we have a first version of such an improved algorithm. When sending an event to all other objects to notify them of some occurrence (for example when taking the transition from state P0 to state P1 in orthogonal component OpenAnt of the Antenna) it is enough inour case to send the event only to the Display object, since the objects Cover}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
and Speaker do not participate and are not affected by the opening Antenna scenario.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The idea of deriving state-based implementations automatically from scenario-based requirements has been the subject of intensive research efforts in recent years; see, e.g., [17, 18, 20, 19, 29].}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The latest versions of the UML recognized the importance of scenario-based requirements, and UML 2.0 sequence diagrams have been significantly enhanced in expressive capabilities, inspired by the LSCs }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
behavioral descriptions: \uc3 \u8592\'e2\'86\'90 for ppt!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
intra-object == all pieces of stories for one object}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
inter-object == one story for all relevant objects}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Generating statechart designs from scenarios \uc3 \u8592\'e2\'86\'90 NASA paper, but old one :-/ 2000?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Each UML notation represents a particular aspect of a software system from a particular viewpoint. However, there exists a good deal of overlap between many notations. \uc3 \u8592\'e2\'86\'90 give visual example of overlap between Class,Sequence,State Machine diagram\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This paper presents an algorithm which supports the design process by generating statechart designs automatically from scenarios. In what follows, scenarios will be expressed as UML sequence diagrams and the design model will consist of a class diagram and UML state-charts}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Since scenarios only give a partial description of a system, we expect the use of this algorithm to be similar to that of a code generator - i.e., the algorithm produces a skeleton design which the user then has to modify/complete. Since the user needs to modify the generated statecharts, they must be readable. This means that the statecharts must include sensible use of hierarchy and orthogonality. We have devised a number of ways of introducing hierarchy into the generated state-charts. We believe that the use of hierarchy is crucial to the success of design generation tools.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Statecharts, introduced originally by D. Hare1 [6], are finite state machines extended with hierarchy and orthogonality (parallelism), allowing a complex system to be expressed in a more compact and elegant way. Conflicts between multiple sequence diagrams: There are two extreme ways to overcome this problem. First, insist that the user provides a complete, formal domain theory providing semantic information about the messages. Second, assume no additional semantic information but interpret scenarios based on some heuristic. Neither of these is sufficient, however. The provision of a complete domain theory is overly burdensome and an algorithm with no semantic information ultimately produces incorrect results. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Once conflicts have been resolved, we are ready to generate a statechart. Our strategy is to generate a number of flat statecharts (in fact, finite state machines (FSMs)) for each individual SD, one for each object in the SD. \~Messages directed towards a particular object, 0, are considered events in the FSM for 0. Messages directed away from 0 are considered actions. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Figure 8 shows how a single SD is translated into a FSM for each object. A FSM, as generated by Figure 8, is a 6-tuple ( N ,SO,V,p, L, 6) where N is the set of nodes, SO E N is the initial node, V is the set of state vectors, p : N + V is a labelling of the nodes with state vectors, L is the set of transition labels and 6 N x L x N is the transition relation. Transition labels are either events, denoted (ev,m), or actions, denoted (ac,m), where m is a sequence of messages. \uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
the algorithm is pretty understandable. But is it useful? Is every Stat Machine Buchi automaton?}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The algorithm that we use subsequently is a variant of a standard algorithm for transforming a non-deterministic finite automaton (NFA) into a deterministic finite automaton (DFA) [l]. Each state in the DFA is a set of NFA states which simulates \uc3 \u8220\'e2\'80\'9cin parallel\u8221\'e2\'80\'9d all possible moves the NFA can make on a given input string. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Transitions between states have labels of the form e[c]/a . If event e occurs and guard c holds, then the transition may be selected to fire which results in action a being taken and a state change occurring. \~\uc3 \u8592\'e2\'86\'90 leverage this form event[condition]/action when creating a monitoring process.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
what follows is a heuristics for making the state charts hierarchical...blabla}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Most other approaches assume the correctness of the input scenarios. In practice, the scenarios will contain ambiguities and inconsistencies. Our algorithm detects conflicts which may correspond to such ambiguities and hence can be used as a guide for refining the scenarios. \uc3 \u8592\'e2\'86\'90 for ppt; well...\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li40\ri0\lin40\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Synthesizing hierarchical state machines from expressive scenario descriptions !! (2010)}
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li40\ri0\lin40\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The motivation for these is to automate the transition from scenario-based requirements to early behavioral design models. To date, however, these synthesis algorithms have tended to generate flat state machines which can be difficult to understand or adapt for practical systems. One of the reasons for this is that relationships between scenarios are often not taken into account during synthesis\uc3 \u8212\'e2\'80\'94either because the relationships are not explicitly defined or because the synthesis algorithms are not sophisticated enough to cope with them. If relationships are not considered, it is impossible for a synthesis algorithm to know, for example, where one scenario stops and another continues. \u8592\'e2\'86\'90 for ppt!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li40\ri0\lin40\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
With the introduction of interaction overview diagrams (IODs) in UML2.0, relationships such as continuation and concurrency can now be specified between scenarios in a way that conforms to the UML standard. But synthesis algorithms do not currently exist that take into account all of these relationships. This article presents a novel synthesis algorithm for an extended version of interaction overview diagram. }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
This algorithm takes into account not only continuation and concurrency}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
, but also preemption, suspension and the notion of a negative scenario. \~}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li40\ri0\lin40\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Furthermore, the synthesis algorithm generates well-structured state machines. These state machines are executable and can therefore be used to validate the scenarios. The hierarchy generated aids readability and so the state machines are more amenable to subsequent design steps. Our IOD extensions have a formal semantics and are supported by a synthesis and execution tool, UCSIM, which is currently provided as a plug-in to IBM Rational Software Modeler.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li40\ri0\lin40\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In UML [OMG 2007], scenarios can be described using interaction diagrams (e.g., UML sequence diagrams). For reactive systems, it is also important to model state-dependent behavior using some form of finite state machine (FSM).}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li40\ri0\lin40\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
[Many] have tried to automate this transition from interaction diagrams to FSMs. This is important research for the following reasons. First, it automates a key activity of many OOAD processes and therefore can save developers valuable time. Second, it transforms scenarios into an executable form (namely, FSMs). Since FSMs are executable, they can be simulated. Hence, automation of the transformation is a way of simulating scenario-based requirements. This simulation can be used in requirements validation.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li40\ri0\lin40\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The transition from interaction diagrams to finite state machines is essentially from a global view of object interactions to a local, object-based view. Each interaction diagram contributes to the state-based definition of one or more objects participating in the interaction, and each object may participate in multiple interaction diagrams. It is this fundamental mismatch between the global and local view that makes synthesis nontrivial. A synthesis algorithm must not only consider the behavior of a given object in one scenario, but must unify all of the object\uc3 \u8217\'e2\'80\'99s behavior from multiple scenarios. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li40\ri0\lin40\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Before UML2.0, scenario-based specifications often did not make explicit the relationships between scenarios. In other words, scenarios were written in isolation and their associations (e.g., continuation, overlapping, parallelism) were not specified. This was partly because early versions of UML did not support the specification of these relationships. In the absence of scenario relationships, synthesis algorithms have taken one of two approaches to elicit them. Either the algorithm infers the relationships or the algorithm requires the scenario writer to explicitly give the relationships in some form (e.g., by explicitly identifying overlapping states [Kruger 2000]). The inference approach is problematic because it results in false positives. Specification of explicit relationships is problematic because it may rely on a nonstandard methodology with which users are not familiar.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li40\ri0\lin40\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
With the introduction of interaction overview diagrams (IODs) in UML2.0 [OMG 2007], developers were given standard ways for specifying relationships between scenarios, in much the same way that high-level Message Sequence Charts (hMSCs) [ITU 2004] had been used in the telecommunications industry. There remain, however, fundamental gaps in synthesis algorithm technology. First, existing synthesis algorithms do not yet consider the full range of relationships that can be specified in IODs. Some works [Uchitel et al. 2003b, 2004] presented a synthesis algorithm for hMSCs but they include only continuation. IODs allow concurrency to be specified and, in fact, this article will introduce new relationships not currently available in IODs. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li40\ri0\lin40\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This article addresses both of these limitations of current synthesis algorithms. It presents a novel synthesis algorithm for an extension of IODs that includes not only relationships such as continuation and concurrency, but also additional relationships found to be useful in specifying distributed, concurrent systems, namely, preemption, suspension, and the notion of negative scenario.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li40\ri0\lin40\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The synthesis algorithm presented generates hierarchical state machines that make use of UML\uc3 \u8217\'e2\'80\'99s structuring mechanisms for state machines, namely, composite states and orthogonal regions. This makes the generated state machines easier to read and, therefore, means that they can be used in subsequent design steps.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li40\ri0\lin40\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The synthesis algorithm presented in the article works on an extension of IODs that was first introduced in Whittle [2005] and given a formal semantics in Whittle [2007]. The key contribution of this article is the synthesis algorithm. The main application of this algorithm to date has been to simulate scenarios, but the generated FSMs could also be used in test generation and automated verification.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li40\ri0\lin40\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In summary, our synthesis algorithm goes beyond previous synthesis algorithms because:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li40\ri0\lin40\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
- it takes into account a rich set of relationships between scenarios such as preemption, parallelism, and negation;}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\li40\ri0\lin40\rin0\fi0\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
- it synthesizes hierarchical state machines which can be built upon in subsequent analysis and design steps.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The synthesis algorithm has been implemented in the UCSIM tool [Jayaraman and Whittle 2007; Whittle and Jayaraman 2006]. This tool allows its users to describe scenarios for a system under development, including complex and rich relationships between scenarios. The tool synthesizes a set of hierarchical state machines from the scenario description\uc3 \u8212\'e2\'80\'94in particular, one hierarchical state machine is generated for each state-dependent object. UCSIM comes with an FSM simulator so that the generated state machines can be simulated, which helps the user to debug the scenarios. Finally, UCSIM is designed as a vendor-independent tool that can be integrated with existing UML modeling tools. So far, \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
UCSIM has been integrated with IBM Rational Software Modeler (RSM) [IBM 2008]. Users draw scenarios in RSM, generate state machines from within RSM, and simulate those state machines in RSM. The architecture of UCSIM is such that integration with other modeling tools is straightforward. \uc3 \u8592\'e2\'86\'90 check rational software modeler!! \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We briefly review IODs and then motivate extensions to IODs that both we and other authors have found to be useful. This extended scenario description language will be called EIODs (extended IODs). Furthermore, we advocate a particular way of modeling with EIODs and introduce that in this section also. Finally, we give an overview of the semantics of EIODs so that it can be compared with the semantics of the state machines generated by our synthesis algorithm. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The 2.0 release of }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
UML introduced interaction overview diagrams (IODs), a notation based on activity diagrams, for specifying relationships between interactions.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
IODs are based on high-level message sequence charts (hMSCs) [ITU 2004], a well-established notation for specifying interactions originally developed for the telecommunications domain. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The UML standard interprets the semantics of messages in terms of send and receive events, corresponding to the sending or receipt of a message by a participant. Events are partially ordered by weak sequential composition that defines the following: (1) events on the same lifeline are ordered according to their vertical location; (2) a message\uc3 \u8217\'e2\'80\'99s send event always comes before its receive event. Weak sequential composition means that sometimes the intuitive vertical ordering of messages is not respected in the semantics. For example, two messages without a common lifeline may occur in any order irrespective of their vertical positioning when drawn graphically. \u8592\'e2\'86\'90 for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
UML includes state invariants as a way of defining states in sequence diagrams. State invariants are essentially labels that can be used to identify different points along the lifeline of a participant (or participants). Before their introduction into UML2.0, they were called state labels by other authors. State invariants are useful to capture the fact that two points along a lifeline are meant to be the same. For example, they are an easy way to define loops (see Figure 1(b)) or to identify points in different sequence diagrams. State invariants allow very fine-grained connections between sequence diagrams. In this article, we do not allow state invariants to be drawn across multiple lifelines. UML2.0 defines other operands as well but they will not be considered here. Neither will this article consider any of the other many modeling constructs for UML sequence diagrams, such as dynamic creation and destruction of participants, timing constraints, and the modeling of data. \uc3 \u8592\'e2\'86\'90 for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Interaction overview diagrams are a restricted form of UML activity diagram for capturing some kinds of relationships between interactions \uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt!}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
However, activity diagrams are extremely rich in expressiveness and some concepts do not necessarily make sense when applied to interaction modeling.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Specifically, EIODs allow those additional constructs from activity diagrams: }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
- an interruptible activity region. The dotted box is an activity group that scopes nodes and edges. An interruptible activity region is an activity group that can be interrupted\uc3 \u8212\'e2\'80\'94shown by the lightning bolt. If an interrupting event occurs, all activities within the region are stopped.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
- an activity with the keyword <<singleCopy>> which denotes that all invocations of the activity are handled by the same execution. This is in contrast to allowing a separate copy of the activity to handle each new invocation of the activity. The latter is the default semantics if the <<singleCopy>> keyword is not shown. If an activity is marked with <<singleCopy>>, then a new invocation of the activity may have to wait until a previous invocation has completed. For example, a Process Order activity marked as <<singleCopy>> would only allow one order to be processed at a time, whereas if separate copies are allowed, then multiple orders can be processed simultaneously. The UML activity semantics is token-based (as in Petri Nets) and so activity invocation corresponds to the receipt of a new token. As we shall see, there are no tokens in the usual semantics for interactions, so the notion of <<singleCopy>> must be reinterpreted for interaction diagrams. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
- a final flow node which terminates the current flow but does not terminate the activity diagram. EIODs have a formal semantics [Whittle 2007] which builds upon the semantics of Haugen et al. [2005] for IODs. }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
\uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
todo: see if they exist in RSA!}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The main extensions are given below:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Nodes in EIODs may have single or multiple concurrent executions\uc3 \u8212\'e2\'80\'94that is, <<singleCopy>> is allowed in EIODs. For convenience, we prefer the UML1.x notation for single/multiple copies over that of UML2.x\u8212\'e2\'80\'94that is, we define the default to be a single execution and mark activities with multiple executions with an asterisk. Most interactions tend to be single copy so this way turns out to be more convenient. In addition, we extend the notion of multiple copies to sets of nodes and borrow the concept of activity group from interruptible regions to allow this. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
EIODs allow interruptible regions, but define two types of interrupt\uc3 \u8212\'e2\'80\'94one for preemption and one for suspension. The type is denoted by a stereotype <<preempted>> or <<suspended>> attached to the lightning bolt for an interruptible activity region. The difference between preempt and suspend is that, for preempt, the interrupted interaction is never returned to, whereas, for suspend, once the suspending interaction is complete, control returns to the interrupted interaction at the point where it was interrupted.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
EIODs also include a notion of scoped negation. Although negation can be modeled in IODs by referencing a sequence diagram which includes a neg fragment, we allow a negative scenario to be scoped over an activity group. That is, the scenario is negative only if it occurs during the execution of activities in the activity group. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
EIODs include the notion of a flow final node which can be used to show that a scenario results in failure EIODs may have two types of final nodes\uc3 \u8212\'e2\'80\'94a final node represents successful completion of the scenario and a\uc1 }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
flow final node}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
represents completion but with failure. We restrict EIODs to those with well-nested fork/join branches and such that there are no recursive interaction references. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The full formal definition is too lengthy to include here but more details can be found in Whittle [2007]. The following definition gives the interpretation of an EIOD in terms of a pair of positive and negative trace sets. A trace is a sequence of events where an event may be the sending or receipt of a message. For a message m, the event of sending a message will be denoted as !m and the event of receiving a message will be denoted as ?m. A trace is well defined if, for each message, the trace contains both a send and receive event for the message, and, furthermore, the send event comes earlier in the sequence than the receive event.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Positive traces define potential behaviors in any implementation of the EIOD. Negative traces may never occur in a valid implementation of the EIOD. \uc3 \u8592\'e2\'86\'90 for ppt: so we don\u8217\'e2\'80\'99t need cold/hot traces, this is a good definition, \uc1 }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
potential}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
behaviors! }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For multiple concurrent executions, a traversal may choose to replace the asterisk by any positive number of parallel executions\uc3 \u8212\'e2\'80\'94that is, by a term with any number of par operators. \~\u8592\'e2\'86\'90 how about if you have \u8220\'e2\'80\'9cn\u8221\'e2\'80\'9d parallel executions in the design?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
As is usual, we define parallel edges by interleaving. \uc3 \u8592\'e2\'86\'90 wtf? why?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The novelty of the algorithm, over that of previous synthesis algorithms, is as follows:}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
- A range of sequence diagram interaction operators, namely alt, opt, seq, par, neg, all, exist are included in the algorithm. Previous algorithms have generally been limited to basic sequence diagrams without interaction fragments}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
- Additional IOD constructs are taken into account, namely preemption, suspension, multiple concurrent executions, flow final nodes, and negation scoped over IOD nodes.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
- The generated state machines incorporate hierarchical states and orthogonal regions.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Note that a sequence diagram without interaction fragments composes its messages using weak sequential composition. This is equivalent to having a single seq fragment surrounding the entire sequence. Hence, we consider the case for seq fragments here. \uc3 \u8592\'e2\'86\'90 ppt?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The algorithm generates a HFSM for each participant in the sequence diagram. It starts by creating an empty HFSM for each participant. Then, for each participant, O, its HFSM is constructed by proceeding vertically down the participant\uc3 \u8217\'e2\'80\'99s lifeline and creating new states and transitions in the HFSM as messages (and state invariants) are encountered. A message m directed away from O to another object becomes an action, !m, in the HFSM for O to send that message to the target object. A message directed toward O becomes a triggering event, !m, in the HFSM and results in a new transition. If a state invariant is encountered, a named state is created, where the state has the same name as the state invariant. All references to the state invariant result in a transition to this named state. If a state invariant is reached and the corresponding named state already exists, a transition is created to this state. Otherwise, a new named state is created. \u8592\'e2\'86\'90 ftw good algorithm for converting into a SM!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This straightforward algorithm ensures that all traces in the sequence diagram are also traces of the generated HFSM. There could be additional traces in the HFSM not present in the sequence diagram. These are the so-called implied scenarios [Uchitel et al. 2001] and are a well-known issue for this type of synthesis algorithm. Implied scenarios arise because the global behavior in}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
sequence diagrams must be distributed across a set of objects, each with local behaviors. It is not generally possible to avoid implied scenarios unless all objects agree to synchronize. However, such a solution would be inefficient or may not even be implementable. Therefore, we do not enforce synchronization in this paper but leave implied scenarios as a recognized issue that is being dealt with by other authors.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A par fragment is handled by introducing an orthogonal region into the generated HFSMs. This preserves the sequence diagram traces because the UML semantics for orthogonal regions is interleaving of events from different regions. For an opt fragment (see Figure 12), two branches are created in the generated HFSMs\uc3 \u8212\'e2\'80\'94one for the optional messages and one for mandatory messages. Note that, if the opt fragment is followed by additional messages, these messages will appear in both branches. Hence, in Figure 12, m2 appears in both the optional and mandatory branches. This correctly captures the semantics of opt. An alt fragment is handled simply by introducing a branch in the generated HFSMs.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Figure 14 illustrates an example for neg. The construction is similar to the case for opt in that two branches are created\uc3 \u8212\'e2\'80\'94one for the positive behavior and one for the negative behavior. The negative behavior results in a branch containing error states. Similarly to opt, if the neg fragment is followed by additional messages, according to the neg semantics, these messages form part\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
of the negative trace and so appear in both branches. In Figure 14, according to the semantics of neg (as defined in Section 2.2.6), there are three negative traces: a trace from just the neg fragment, and two traces from joining the neg fragment with what follows it. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Parallel fork/join edges lead to orthogonal regions in the generated HFSMs. Since fork/join edges are well nested, there is no ambiguity in deciding where the orthogonal regions should be placed}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Negative edges result in orthogonal regions in the generated HFSMs. Negation is handled by monitoring for the negative events and transitioning to a special error state if they occur. The negative events under monitor are placed into an orthogonal region so that, if the sequence of negative events ever occurs (even with other events interleaved), then the error state will be entered. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
It is also important to note that the generated HFSMs are highly nondeterministic\uc3 \u8212\'e2\'80\'94in that the HFSM for a in Figure 21 autonomously decides to send any number of m1s. This, of course, results in an infinite stream of m1s. Developers typically require more control over such nondeterminism. However, to maintain consistency with the EIOD semantics, we expect that the HFSM simulator would provide an option to control nondeterminism if so required. \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The algorithm is compositional in the sense that combinations of edges and/or fragments are translated by applying the synthesis rules recursively. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
UCSIM is implemented as an Eclipse plug-in and EIODs can be created using IBM Rational Software Modeler (RSM) using standard UML notations and stereotypes where necessary. Although UCSIM currently works with RSM, it is designed in a vendor-independent way and can be adapted to other modeling tools in a relatively straightforward manner. UML deliberately marks some semantic decisions as semantic variation points. These variation points can be defined differently by different tools. This can cause problems because a state machine designed and tested in one tool may not behave identically in another tool. To help alleviate this problem, the user can configure the semantic variation points in CSMS and the execution of the state machine then changes to match the new semantic definition.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
These examples demonstrate (1) that }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
realistic specifications can be captured using EIODs and that our extensions are useful in practice}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
, and (2) that readable HFSMs can be generated for realistic examples. \uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt: realistic specifications can be captured?}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The first is a weather update subsystem of an air traffic control system developed at NASA [Denery et al. 1997]. The illustrative example used earlier in this article is a much simplified version of this subsystem. This particular example was used in an earlier article on synthesis [Whittle et al. 2005b]. Our particular contribution here is that we were able to use the extended features of EIODs to generate hierarchical state machines for the example. We gave the same scenarios as were used in Whittle et al. [2005b]. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
However, in Whittle et al. [2005b], heavy use of state invariants was made to connect scenarios together.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In essence, each sequence diagram used state invariants to label the states at the beginning and end of the sequence, and these state invariants were used to \uc3 \u8220\'e2\'80\'9cpaste together\u8221\'e2\'80\'9d the sequences. State invariants were also used within sequences to mark where, for example, a scenario was interrupted by another. This worked but did require the modeler to provide these state invariants. The constructs of EIODs provide a more elegant solution. The examples showed that the three-level structure of use case charts allow a wide range of behavior to be specified in a controllable way. If UML sequence diagrams alone had been used to capture the same information, the number of modeling elements needed would have been at least an order of magnitude larger. Indeed, it would have been extremely difficult if not impossible to capture some of the more complex behavior, such as preemption. Simply specifying the examples, of course, does not provide any evidence of how easy it is to develop the use case chart, nor how readable the generated HFSMs are. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Scalability and Usability. The three case studies conducted so far were of a reasonable size. As an indication, the shuttle system consisted of 7 use case nodes (level 1), 10 scenario nodes (level 2), an average of 7.2 participants per sequence diagram, 23 interaction fragments, and 144 messages. There were seven state-dependent objects for which HFSMs were generated. This resulted in a total of 117 generated states, four of which were composite states and nine of which were orthogonal regions. The studies showed that the new relationships in EIODs\uc3 \u8212\'e2\'80\'94preemption, suspension, negation\u8212\'e2\'80\'94were used infrequently but their application was crucial when used. This is to be expected. One would not expect, for example, preemption to be used as frequently as simple control flow. \u8592\'e2\'86\'90 for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Even for examples of medium size such as these, three factors were found to be crucial in making the generated HFSMs readable. First, the use of composite and orthogonal regions was essential. Hierarchical states allow the result to be viewed at different levels of abstraction. \~}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
importance of hierarchy is a key point. It is relatively straightforward to generate flat state machines that have equivalent behavior to an EIOD. In fact, this is basically the approach taken by research that defines the semantics of IODs in terms of automata or Petri Nets (see, for example, Grosu and Smolka [2005]). \~}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Such approaches are fine for a formal semantics definition or for when the result is not meant to be human-readable, but if the generated state machines are to be used in further development, readability is critical. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The formal semantics of EIODs have no problem in interpreting such cases, but, in general, branches that are not well nested are not supported by UCSIM yet. However, the general solution is still under investigation. \uc3 \u8592\'e2\'86\'90 for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Methodological Considerations. Our experiences with UCSIM raise a number of methodological considerations. We do not yet offer any in-depth guidelines on how to construct EIODs. In fact, there are very few works in the literature that address how best to use IODs. This is an especially important consideration when synthesis is being used, because the structure in the EIODs has a direct effect on the structure generated in the HFSMs. In Whittle et al. [2005a], we offered some initial hints on how to define a process for analyzing requirements with EIODs. \uc3 \u8592\'e2\'86\'90 for future work, use/cite this article, it\u8217\'e2\'80\'99s actually one of the few that uses IODs.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Currently, users of UCSIM must develop a complete EIOD in order to generate HFSMs\uc3 \u8212\'e2\'80\'94in the sense that, if a scenario S2 follows S1 and if a scenario S4 follows S3, then the user must also specify a relationship between S2 and S3. Otherwise, there is not enough information for UCSIM to decide how flow continues after S2. \uc1 }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
At the level of requirements analysis, specifying such detailed information could be overly restrictive. It would be interesting to investigate synthesis based on partial information. This could lead to nondeterminism in the generated models but could be a useful way of supporting exploration of requirements.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 \uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for ppt, for future work also!}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
There have been many papers on synthesizing state machines from scenariobased notations such as UML sequence diagrams [Whittle and Schumann 2000], message sequence charts [Kruger 2000; Uchitel et al. 2003b], and LSCs [Harel et al. 2005]. See Saiedian et al. [2005] and Amyot and Eberlein [2003] for recent surveys on this topic. For the most part, these works have considered a more limited set of scenario relationships than are considered in this article. The algorithm in Uchitel et al. [2003], for instance, takes into account simple control flow given in a hMSC but does not consider parallelism or preemption.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
One key distinguishing feature between these synthesis algorithms is how they decide on the relationships between different scenarios. There have been two broad classes of approaches\uc3 \u8212\'e2\'80\'94to derive the relationships or to assume that the user provides relationships explicitly. In the former case, the user may specify a set of unconnected scenarios. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Approaches to specifying scenario relationships explicitly differ in the amount of detail they expect from the user. At one end of the scale are approaches that use state invariants to label the start and end points of each scenario. Other approaches (e.g., Som \uc2 \u769\'cc\'81 [2005]; Whittle and Schumann [2000]) derived relationships from formally defined pre- and postconditions on scenarios. Once again, these approaches require a significant additional modeling effort from\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
the user. \uc3 \u8592\'e2\'86\'90 for ppt: we like to keep it as simple as possible in this case.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To the authors\uc3 \u8217\'e2\'80\'99 knowledge, there is no existing synthesis algorithm that takes into account as wide a range of relationships as in this article. We have seen no previous algorithms that incorporate preemption, suspension, scoped negation, and parallelism. \u8592\'e2\'86\'90 do we really need preemtion? \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The algorithm in Harel et al. [2005] also makes the perfect information hypothesis, that is, that}{\scaps0\caps0\cf1\ul\ulc0\b0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
each object synchronizes with all other objects when an event is received. Although this does alleviate the problem of implied scenarios\uc3 \u8212\'e2\'80\'94which occur because an object\u8217\'e2\'80\'99s local view of the system state, as captured in the generated FSM, is insufficient to enforce the global view captured in the scenarios\uc1 }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
\uc3 \u8212\'e2\'80\'94\uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
it appears to be overly restrictive and does not lead to efficient or modular implementations. \uc3 \u8592\'e2\'86\'90 for ppt!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Currently, simulation is done at the state machine level. This is advantageous because it allows the user to examine each subsystem independently. However, for stakeholders not familiar with state machines, the results of the simulation may be difficult to understand. We plan on implementing a visualization tool on top of UCSIM so that the simulation results can be viewed using graphical icons which are much closer to the domain language of requirements engineers. In addition, one could investigate simulation of the scenarios directly without first translating to state machines. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
So far, research has focused on technical issues such as how best to derive connections between scenarios or how best to ensure the correctness of the transformation. We feel the time is ripe for these algorithms to be put through their paces and to undertake in-depth studies on how they can most effectively support software engineers \uc3 \u8592\'e2\'86\'90 for ppt, actually, by using the simulator of mcrl2, you\u8217\'e2\'80\'99re basically a creating an executable specification...that\u8217\'e2\'80\'99s pretty intuitive (contains object/class/method call, poseible steps) important for modeling, otherwise it\u8217\'e2\'80\'99s like coding without compiler.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We currently generate HFSMs with error states for negative scenarios.<-- see how?}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
DETECTING EMERGENT BEHAVIOR IN DISTRIBUTED SYSTEMS USING SCENARIO-BASED SPECIFICATIONS}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
An effective approach for the design of distributed systems is to describe system requirements using scenarios. A scenario, commonly known as a message sequence chart or a sequence diagram, is a temporal sequence of messages sent between system components. However, scenario-based speci \uc2 \u772\'cc\'84cations are prone to subtle de \u772\'cc\'84ciencies with respect to analysis and validation known as incompleteness and partial description. In this research, a method for detecting emergent behavior of scenario-based speci \u772\'cc\'84cation is proposed. The method is demonstrated and veri \u772\'cc\'84ed using a mine-sweeping robot as an example A widely accepted model for behavioral modeling of individual system elements is the state machine. Several studies have already been conducted to facilitate the procedure of converting a set of scenarios to a behavioral model expressed by state machines [3\u192\'c3\'8010]. In the synthesis process, one state machine will be built for each system element. The state machine includes all the messages that are received or sent by that element. Then the behavior of the distributed system is described by the product (parallel execution) of all the state machines of the system elements.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In [8] an algorithm for safe realizability is proposed but there is no method to directly check whether implied scenarios exist in the \~\uc2 \u772\'cc\'84rst place. In other words, so far there is no formalized and precise representation for the cause of implied scenarios, so that by capturing that cause during the design phase, emergent behavior can be detected and removed. A main contribution of this paper is to give a de \u772\'cc\'84nition for indeterminism in behavior of distributed systems, so that by identifying indeterminism, one can detect the potential emergent behavior.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ppt: still a lot of emergent behavior in distributed systems, that is not explicitly modeled with the scenarios (because of the partial order of events, partial view of the system interactions within a scenario)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Although MSCs and sequence diagrams vary in notations, they are both capable of representing scenarios in an e\uc2 \u177\'c2\'b1cient and intuitive manner. In this research the prime focus is on MSCs. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
There are several reasons for choosing MSCs over sequence diagrams in this research. First, the notation of MSCs is simpler than sequence diagrams; which comes as no surprise as sequence diagrams are utilized in object oriented design [2, 24]. Sequence diagrams include additional notations to support illustrating the design.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Recall that upon building the behavior model of a system component, different states of the model need to be identi \uc2 \u772\'cc\'84ed. This is a very crucial step and in fact it is where the methodologies di\u174\'c2\'aeer from one another. This step is important since the detection of emergent behavior is a direct result of \~\u772\'cc\'84nding identical states in behavioral models. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
OCL is part of the UML standard and is a side-e\uc2 \u174\'c2\'aeect free and set-based constraint language [25]. The OCL specifi\u772\'cc\'84cations include the declaration of state variables. A state variable represents some important aspect of the system such as whether or not a component is coordinating with other components. Moreover the OCL speci \u772\'cc\'84cations enable the detection of con\u176\'c2\'b0icts between di\u174\'c2\'aeerent scenarios and allow scenarios to be merged scenario-based speci \u772\'cc\'84cation is an e\u177\'c2\'b1cient and e\u174\'c2\'aeective way to represent system requirements for distributed systems. However as each scenario only partially describes system's behavior, scenario based speci \u772\'cc\'84cations are subject to deficiencies such as incompleteness and contradictions. Thus having a methodology which can systematically discover system design errors prior to implementation is most beneficial and will lead to huge savings in time and cost. In this section, the \~\u772\'cc\'84rst part of this systematic approach, which is the synthesis of state machines from message sequence charts is described. As demonstrated in the previous section, by assigning state values based on semantic causality, the basis for comparing states and consequently discovering identical states is established. A goal in this research is to identify possible design flaws that might lead to runtime problems in distributed systems by analyzing the system speci \u772\'cc\'84cation expressed by scenarios. Unfortunately, manual review may not e\u177\'c2\'b1ciently detect all the design \u176\'c2\'b0aws due to the scale and complexity of the system. In this research we have provided sound techniques to automate the speci \u772\'cc\'84cation and design review of the distributed system and detect a subset of unwanted run time behaviors, including implied behaviors.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this paper, we provided a method to identify the exact cause of implied scenarios, so that by capturing it, implied scenarios can be detected and removed. This method is novel in the sense of formalization of the cause of implied scenarios. Furthermore, this technique can be modi \uc2 \u772\'cc\'84ed to take the UML's sequence diagrams as input and thus incorporate the analysis and design of distributed object oriented systems.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Facilitating the Construction of Specification Pattern-based Properties (2005)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Formal specification languages are often perceived as difficult to use by practitioners, and are therefore rarely used in industrial software development practices. Numerous researchers have developed specification pattern systems to facilitate the construction of formal specifications of system properties. Feedback indicates that these patterns are considered helpful, but many practitioners prefer capturing properties using informal notations, such as natural language, instead of formal specification languages. This paper describes a project that addresses this technology gap. First, we introduce a stepwise process for deriving and instantiating system properties in terms of their natural language representations. The key components of this process are structured natural language grammars and specification pattern systems. Second, we describe S PIDER, a prototype implementation of a tool suite supporting this specification process. Temporal logics, in particular, real-time temporal logics, are often perceived by practitioners as difficult to understand and apply. Feedback from industrial collaborators indicates that, typically, only developers with extensive training in formal methods are inclined to make use of temporal logics. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
To promote the use of formal specification techniques, we previously developed real-time}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
specification patterns [19] to be used in combination with the already established qualitative specification patterns by Dwyer et al. [8].}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In order to further enhance the accessability of these specification patterns and their analysis tools, this paper introduces a syntax-guided approach to deriving and instantiating qualitative and real-time specification patterns in terms of their natural language representations.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Specifically, the domain experts use natural language to capture appropriate properties identified for a given domain. The formal methods experts decide how to best represent these properties in terms of appropriate target specification languages. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Overall, our approach combines the completeness of a pattern system for specifying qualitative and real-time properties with the accessibility of a natural language representation. \uc3 \u8592\'e2\'86\'90 the essence of the work\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Dwyer et al. [8] developed several patterns applicable to software properties specified in different formalisms, such as LTL [23], computational tree logic (CTL) [5], graphical interval logic (GIL) [32], and quantified regular expressions (QRE) [28]. Specification patterns are categorized}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
into two major groups: occurrence patterns and order patterns. While a given specification pattern may have several scopes of applicability (e.g., globally, before an event/state occurs, after an event/state occurs), the original specification patterns do not include timing information. Therefore, we refer to the specification patterns by Dwyer et al. as qualitative specification patterns as they specify qualitative properties that are not amenable to quantitative reasoning about time.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In our preliminary work with requirements of embedded systems, it became clear that many of the requirements were often timing-based, which could not be specified in terms of Dwyer et al.\uc3 \u8217\'e2\'80\'99s specification patterns. Using our specification approach, the user follows a step-wise process to derive a structured natural language sentence capturing the requirement. This sentence can then be instantiated with UML model elements (from Figure 1) and then be mapped to a temporal logic formula in the specification pattern system.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Mapping}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
: Map the instantiated natural language sentence to the temporal logic required by the targeted formal validation and verification tool and analyze.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Currently, SPIDER includes a grammar and specification patterns for the specification patterns by Dwyer et al. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
[8], as well as a grammar and specification patterns for an extended specification pattern system (used in this paper) that also includes our real-time specification}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
patterns [19]. \uc3 \u8592\'e2\'86\'90 find it??\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Figure 5 shows a screen capture of }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
the Property Instantiator. The Sentence instantiation field}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
contains elements that are used to instantiate the derived natural language sentence. The Property Instantiator extracts model-specific information from formal system models (displayed in the Current model elements fields). To accomplish this task, the Property Instantiator potentially uses several Formal Model Interpreters, each of which has the ability to read a certain input format of a formal model. These elements can be inserted into boolean propositions to be used in the placeholder variables of a property. Next, the Property Instantiator is used to replace P and S with boolean propositions describing the appropriate states. SPIDER displays all the classes, with accompanying signal, state, and variable names, from the system model. In}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
this case, we are interested in the variables of the Fault-Handler and MalfunctionIndicatorLight classes...This instantiated sentence can then be mapped to a temporal logic representation. The following temporal logic property, automatically generated by SPIDER, denotes the LTL representation of the property captured in natural language in Expression (6), which can be analyzed by the model checker Spin Fantechi et al. [9] use natural language constructs that map directly into ACTL, an action-based variant of CTL. User input is used to resolve ambiguities that might be encountered in the input phrase. While this approach is directly related to ours, it restricts the source language according to the structure of the targeted temporal logic}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Smith et al. developed Propel [35], where they extended the specification patterns by Dwyer et al. [8] to address important and subtle aspects about a property, such as what happens in a cause-effect relation if the cause recurs before the effect has occurred. These extended specification patterns are specified in terms of finite-state automata instead of temporal logic formulae. \uc3 \u8592\'e2\'86\'90 find? \u8220\'e2\'80\'9cAn approach supporting property elucidation\u8221\'e2\'80\'9d\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Mondragon et al. developed a tool called Prospec [26] for the specification of properties based on Dwyer et al.\uc3 \u8217\'e2\'80\'99s specification patterns. The tool offers assistance in the specification process and extends the specification pattern system by Dwyer et al. with compositional patterns. Differing from our tool suite, they do not include support for natural language representations or real-time information. \u8592\'e2\'86\'90 find this also!!! \u8220\'e2\'80\'9cSupporting elicitation and specification of software properties through patterns and composite propositions\u8221\'e2\'80\'9d \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The idea is that instead of structured natural language templates, I offer SD templates. Or maybe not? }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
PROPEL: An approach supporting property elucidation (2002) \uc3 \u8592\'e2\'86\'90 !!! Important, VERY!!)\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Property specifications concisely describe what a software system is supposed to do. It is surprisingly difficult to write these properties correctly. There are rigorous mathematical formalisms for representing properties, but these are often difficult to use. No matter what notation is used, however, there are often subtle, but important, details that need to be considered. PROPEL aims to make the job of writing and understanding properties easier by providing templates that explicitly capture these details as options or commonly-occurring property patterns. These templates are represented using both "disciplined" natural language and finite-state automata, allowing the specifier to easily move between these two representations. These properties may be written in a number of different specification formalisms, such as temporal logics, graphical finite-state machines, or regular expression notations, depending on the finite-state verification system that is being employed. Although there are sometimes theoretical differences in the expressive power of these languages, these differences are rarely encountered in practice. A serious problem that is frequently encountered in practice, however, is expressing the intended behavior of the system correctly. Even though properties usually focus on some restricted aspect of a system's behavior, it is still surprisingly difficult to capture this behavior precisely}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Recent work on property patterns [8-10] recognized that the properties used in formal verification often map onto one of several basic property patterns. These patterns can be instantiated with specific events or states and then mapped to several different formalisms. When we tried to employ these property patterns to represent some actual natural language requirements, however, we found that they were not adequate. They failed to represent some of the subtle differences in interpretation that we encountered. In the work presented here, we build upon the property patterns in several important ways. First, we extend the patterns so that they are represented by pattern templates. Thus, instead of just parameterizing the pattern in terms of the events or states, we extend the patterns with alternative options that are explicitly shown to the specifier. Second, we represent these pattern templates using two different notations: an extended finite-state automaton (FSA) representation and a disciplined natural language (DNL) representation. Third, the instantiated FSA representation is mathematically well-defined and thus can be used as the basis for verification, as well as for testing the acceptance of event sequences. Although the input formalisms of the various finite-state verification tools, such as the temporal logics LTL and CTL [3] are very expressive, Dwyer et al. observed that nearly all the properties found in the finite-state verification literature could be classified into a small number of basic types, and suggested that a collection of patterns, which they described as "high-level, formalism-independent, specification abstractions," could assist finite-state verification practitioners in formulating most of the properties they wanted to check.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Each of the patterns describes an }{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
intent}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
(the structure of the specified behavior), a }{\scaps0\caps0\cf1\strike0\i\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
scope}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
(the extent of program execution over which the pattern must hold), mappings into the input formalisms for some finite-state verification tools, examples of known uses, and relationships to other patterns.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
[good overview of the paper...]}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A specifier who wishes to modify a pattern, however, must have significant expertise with the particular specification formalisms utilized by the finite-state verification tool being applied. Indeed, the property patterns themselves do not highlight the choices made and the notes do not attempt to point out all plausible modifications. It is assumed that the analyst who wants to verify a particular property can identify the ways in which it might differ from the particular forms in the property pattern system and, with some assistance from the notes, make the necessary modifications. Since the target audience for the property patterns system is users of finite-state verification tools, and expertise with the specification formalisms is a prerequisite for effective use of such tools, this is not an unreasonable requirement. In our previous work with finite-state verification systems, we have found that finite-state automata, with their corresponding graphical depictions, are some of the more accessible notations for representing properties. We have also observed that many of the "shall" phrases found in requirements and specification}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
documents seem to almost take on a template form. Thus, we wanted to see if we could marry these two notations via the property patterns. While the property pattern work included both state- and event-based formalisms, here we assume an event-based formalism.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A property pattern template is fully instantiated when all the optional choices have been resolved and partially instantiated if only some of the options have been resolved. An optional transition in an FSA template will either resolve to a regular transition or it will not exist in the instantiated property. A multi-label on a regular transition will resolve to only one of its label choices in the instantiated property. A multi-label on an optional transition will resolve to at most one of its label choices; an optional transition disappears if all of the label choices in its multi-label have been eliminated from consideration. An optionally accepting state will either resolve to an accepting state or a non-accepting state. After fully instantiating an FSA template by resolving all of the options, the specifier is left with an FSA property.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We illustrate how a property pattern is represented as an FSA template using the Response pattern. As noted above, the Response pattern is concerned with expressing the concept of a stimulus event that must be followed by a response event. An example of this property pattern as written in natural language might look something like this: After the elevator button is pushed, the elevator closes its doors. Questions arise: for example, should the doors close repeatedly if the button is pushed repeatedly? What, if anything, is allowed to occur after the button is pushed, but before the doors are closed? We find that these questions can be captured by using the extended FSA property notation with six options. These options in the Response pattern template combine to produce a total of sixty-four distinct variations on this property pattern. When all of the options have been decided, an FSA that represents only one of the sixty-four possible variations is created. The six Response pattern template options are as follows: }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Pre-arity, which determines whether action may occur one time or many times before response does; Post-arity, which determines whether response may occur one time or many times after action does; Immediacy, which determines whether or not other intervening events may occur between action and response; Precedency, which determines whether or not response is allowed to occur before the first occurrence of action; Nullity, which determines whether or not action must ever occur; and Repeatability, which determines whether or not occurrences of action after an occurrence of response are required to be followed by response. Since we assume that the alphabet may include more events than just action and response, Immediacy deals with whether or not these other events may occur at the second state. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Figure 2}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
shows the other FSA templates developed for PROPEL, based on the property patterns proposed by Dwyer et al. These three patterns and the Response pattern are the basic patterns that do not use any composition to express their concepts. The first pattern, Precedence, states that an action cannot occur until it has been preceded by the enable event. The second pattern, Existence, states that action must occur in the system execution. The last pattern, Absence, states that action must not occur in the system execution. Note that the Absence FSA template does not have any options. \uc3 \u8592\'e2\'86\'90 see figure 2, very useful!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
During the process of instantiating an FSA template, the specifier must define the alphabet and associate the appropriate events with their related pattern parameters. The FSA template structure is designed to assist the specifier in asking and answering the appropriate questions and in understanding the meaning of the decisions that are made. The specifier instantiates a property pattern template until all of the options have been resolved and anFSA property representation results.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
DNL is a restricted subset of natural language that is intended to capture meanings unambiguously. This representation is not intended to stand by itself; it is meant to be used in conjunction with the FSA template representation. Like FSA templates, DNL templates are designed to elucidate the decisions associated with a property pattern. Therefore, the same options that must be decided in the FSA template are options in the DNL template representation. A fially-instantiated DNL template results in a paragraph of natural language text that is grammatically correct, readable, and maps to one, and only one, fully-instantiated FSA property. The relationship between the options in a pattern's DNL template and those in a pattern's FSA template is not necessarily one-to-one, however, since some DNL options affect the FSA templates in more than one location.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
So far, we have discussed how to develop the intent (the structure of the behavior specified) of a property. In this section, we discuss the definition of a scope and how it is applied to the property}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
pattern template. As mentioned above, the patterns of Dwyer et al. have scopes that describe the extent of system execution over which the pattern must hold. For example, a specifier might want to say: Between pushing the button and arriving at the requested floor, the elevator does not change direction.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A scope can be used to specify when it is important that the property holds. \uc3 \u8592\'e2\'86\'90 future work!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Dwyer et al. identified five basic scopes and defined whether the scope was closed or open on either end for each pattern. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Most event-based formalisms use some version of an interleaved model of concurrent computation. In such formalisms, two events cannot coincide.}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In the property patterns system, therefore, event-delimited scopes are open at both ends; an event that occurs within the scope cannot occur at the same time as an event that marks the beginning or end of the scope. We make the additional restrictions that the set of delimiter events defining the scope is disjoint from the alphabet of the FSA defining the intent and that, if the scope has both starting and ending delimiters, these are distinct. These restrictions seem reasonable and greatly simplify the application of a scope to an intent. Thus, the five basic scopes become: }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Global}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
, which is over the entire system execution. This scope does not have delimiters, and it is not repeatable; }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Before P}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
, which is concerned with the event sequence up}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
to the first occurrence of P. This scope only has a ending delimiter, and it is not repeatable; }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
After Q}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
, which is concerned with the event sequence after the first occurrence of Q. This scope only has an starting delimiter, and it is not repeatable; }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Between Q and P}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
, which is concerned with the event sequence after an occurrence of the starting delimiter, Q, and before an occurrence of the ending delimiter, P. P is required to occur for this scope to exist. This scope may occur repeatedly over the course of the system execution; }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
After Q Until P}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
, which is concerned with the event sequence after an occurrence of the starting delimiter, Q, and before an occurrence of the ending delimiter, P. P is not required to occur for this scope to exist. This scope may occur repeatedly over the course of the system execution; }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A scope can be applied to an intent by adding additional states that we call "scope states" and by adding transitions between the scope states and the states of the FSA that represent the intent.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In the remainder of this section, we explain the additions needed to apply each scope to the Response pattern. Scopes are added to the intents of the other property patterns in much the same way. We interpret the Before P scope to mean that the scope begins at the start of the program execution, so there is no starting delimiter, and that the ending delimiter is the first occurrence of P in the program execution. Subsequent occurrences of P are ignored since this scope is not repeatable. When we apply the Before P scope to the intents, we must determine at each state what the effect will be of encountering the ending delimiter at that point in the sequence. Recall that the intent of the Response property is that an occurrence of action must be followed by an occurrence of response. An occurrence of P results in a scope that has been ended before the intent of the property has been entered. This is called an empty scope. An empty scope is handled differently for each of the property patterns. For instance, the Absence property holds if the scope is empty, since that is actually the meaning of the Absence property}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
pattern. Whether or not a Response property holds if the scope is empty, however, depends on the setting of the Nullity option, which determines whether or not action must occur at all. If action is not required to occur, then the first state, which is also the start state, will be an accepting state. If P occurs at this point and action is not required to occur, then this sequence is not a violation of the property and the empty scope does not prevent the property from holding. When the FSA is in the second state, an action has occurred that is not yet followed by a response. At this point, response must occur before a P ends the scope, or the property is violated. An occurrence of P when the FSA is in the second state therefore puts the FSA into a non-accepting trap state (not shown!). \~We interpret the After Q scope to mean that the scope is not started until the first occurrence of the starting delimiter, Q, in the system execution. Subsequent occurrences of Q are ignored since this scope is not repeatable. The scope is not ended until the execution ends, so there is no ending delimiter. As with the Before P scope, when we apply the After Q scope to the intents, we must determine at each state what the effect will be of encountering the ending delimiter at that point in the sequence. An occurrence of Q at this (first!) state would begin the scope and after this point the intent of the property would be required to hold. As is shown with the self-loop that is labeled " ~ Q " on state 1, all events that occur before the starting delimiter are ignored. An occurrence of Q at any of the other states would have no effect on the property, because after the occurrence of the starting delimiter all subsequent occurrences of Q are ignored. We interpret the After Q Until P scope to mean that the starting delimiter is an occurrence of Q and the ending delimiter is an occurrence of P. This scope can be repeated; whether or not it is repeatable is an option for the specifier to determine. For now, consistent with Dwyer et al., we assume that a scope with multiple occurrences of Q is ended by a single occurrence of P. Given this interpretation, when we apply the After Q Until P scope to the intents we must determine at each state what the effect will be o f encountering the ending delimiter at that point in the sequence. An occurrence o f Q at this (first!) state would start the scope and after this point the intent o f the property would be required to hold. As is shown with the self-loop that is labeled " ~ Q " on state 1, all events that occur before the starting delimiter are ignored. An occurrence o f P at state 1 would also be ignored, since an occurrence of Q has not yet started the scope. The Between Q and P Scope is identical to the After Q Until P scope except for one important difference. Figure 5d shows the difference: state 3 is accepting. The reason for this change is that the definition of the Between Q and P scope requires that both delimiters occur, whereas the After Q Until P scope does not. The Between Q and P scope does not exist unless both o f its delimiters occur. What this means is that if P does not occur, the intent of the property could be violated and yet the property as a whole would not be violated because it is not within an existing scope when the violation happens. \~}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The PROPEL approach described in this paper builds directly on the property patterns. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For instance, these patterns form the basis of the extensible specification language in the Bandera system [5, 6], and Paun and Chechik [23] have extended the patterns to deal with events in a state-based formalism. \uc3 \u8592\'e2\'86\'90 how about dealing with states in an event-based formalism? for future work\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
With PROPEL, users are provided with templates for the most common property patterns described in Dwyer et al. These templates are presented in an extended finite-state automaton notation and as natural language phrases, both of which explicitly indicate the options that must be considered. We hypothesize that this two-pronged approach will help specifiers elucidate the precise meaning of the properties that they are expressing. We are currently implementing the PROPEL system so that specifiers are presented with both notations and can move between them while instantiating the property templates incrementally. We believe that this approach is an effective way to achieve both accessibility \uc3 \u8592\'e2\'86\'90 todo!! FIND IMPLEMENTATION \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
(}{{\field{\*\fldinst HYPERLINK "http://laser.cs.umass.edu/tools/propel.shtml" }\scaps0\caps0\cf3\strike0\i0\ul\ulc0\b\animtext0{\fldrslt \cf2\ul\ulc0\langfe255\alang255\lang255\rtlch \ltrch\loch\fs22\loch\f5
http://laser.cs.umass.edu/tools/propel.shtml}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
}} \uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
java bljak)}
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Although we have applied this approach to several properties and been pleased with the results, we need to undertake a careful evaluation. \uc3 \u8592\'e2\'86\'90 for ppt!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
From UML 2 Sequence Diagrams to State Machines by Graph Transformation (2011) \uc3 \u8592\'e2\'86\'90 find the actual toolset, if there is one?\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This paper explores how we can specify graph transformation-based rules for a classical problem of transforming from sequence diagrams to state machines. The specification of the transformation rules is based on the concrete syntax of sequence diagrams and state machines. Although sequence diagrams and state machines are used in different phases and are made with different diagram types, there is a great deal of overlap between the two specifications. The behavior defined by the sequence diagrams should also be recognized as behavior by the state machines.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
There has been a lot of efforts to transform from sequence diagram-like specification languages to state-based languages (e.g. [KGSB99, WS00, ZHJ04, Sun07]). None of the previous approaches takes full advantage of the combined fragments that were introduced in UML 2. \uc3 \u8592\'e2\'86\'90 main point why it should be done\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Our approach differs from the traditional model and graph transformation approaches, where transformations are specified in relation to the abstract syntax. We claim that concrete syntax-based rules are more user-friendly since the specifier does not need to have knowledge of the metamodels and the associated abstract syntax. This is particularly useful for sequence diagrams where the abstract syntax is complicated and quite different from the concrete syntax. We introduce a fragment operator that allows us to specify the matching and transformation of combined fragments with an unknown number of operands. Our rules are mapped to traditional graph transformation rules and the transformation takes place in the AGG tool.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this paper we only use sequence diagrams with asynchronous messages, although our transformation apparatus works for both synchronous and asynchronous messages. Asynchronous messages fits nicely with the event-based nature of state machines, unlike sequence diagrams with synchronous messages that have a procedural nature. We omit the optional rectangles to visualize when a lifeline is active, since these are more relevant for synchronous messages. \uc3 \u8592\'e2\'86\'90 tja....\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The set of sequence diagrams describing a system will normally have a non-empty set of inconclusive traces, which we call a partial specification. An actual implementation may choose to implement the inconclusive traces as either positive or negative. A state machine on the other hand, has no inconclusive traces and is thus a complete specification.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Generate State Machine. Our automated generation sd2sm, in step 3, makes a state machine that accepts all positive traces from the sequence diagrams. Inconclusive traces are not implemented, and these traces become negative. Hence, step 3 performs a negative supplementing. We provide the known formal foundation of algebraic graph transformation...[definitions, graph morphisms...injective mappings..]}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Graph transformation rule consists of three graphs: LHS (left hand side), Interface (I) and RHS. And a pair of injective graph morphisms. In the graph transformation rules throughout this paper we only explicitly display the LHS and the RHS graphs, while the interface graph is given by shared identifiers of elements in the LHS and the RHS/NACs. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this section we present the transformation rules, and we show how the rules gradually}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
transform from a sequence diagram into state machines. \uc3 \u8592\'e2\'86\'90 rules gradually transform an SD into a set of process descriptions..\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Each lifeline corresponds to a state machine. When producing a state machine, it is sufficient to look at the single corresponding lifeline with its events and how these events are structured within the combined fragments. A prerequisite to this claim is that each lifeline occurs only in one sequence diagram.. The rule Alt in Figure 10a pops an alt fragment and makes the current state into a composite state by adding internal behavior: an initial state, an Idle state and a final state. For each alt operand we make an inner composite state. We produce a transition from the Idle state to each inner composite state, where the transition guard is equal to the corresponding alt operand guard...When we have mapped and removed all events from a lifeline, then we use a rule called FinalState (Figure 11a). The rule replaces the current state (indicated by the state edge) by a finalnode. We have now reached a state machine corresponding to the GasPump lifeline. It is possible to optimize the produced state machine by flattening some of the composite states. For our example we need three flattening rules which are shown in Figure 12a-c. The FlattenIntoChoice rule flattens the composite state holding all the internal choices corresponding to the alt operands. We are able to flatten the state by introducing a choice node with outgoing branches to the choices and finally a merge node with incoming branches from all the choices. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The Loop rule (Figure 13a) makes the current state into a composite state with an idle state inside. The GasPump lifeline of the loop operand gets a state-labeled edge to the idle state. Furthermore, the composite state has a reflexive transition with the guard condition taken from the looping condition of the loop operator. A transition with a negated loop guard leaves the composite state into a newly created state, which becomes the current state of the remaining sequence diagram. The Par rule (Figure 13b) makes the current state into a composite state with one region state machine for each par operand. These region state machines each have an idle state that becomes the current state of the sequence diagram of the corresponding par operand. \~}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The transformation rules are implemented in the graph transformation tool AGG. The transformation is tested on some examples, including the GasPump example shown in this paper, with success. The AGG tool only supports abstract syntax rules, and we have manually translated from concrete syntax to abstract syntax rules. We have also used multiple collection free rules to simulate each rule with collection operators by following the algorithm defined in [GKMP09]. This paper defines semantics for concrete syntax-based rules of sequence diagrams which can be used to automate the translation to abstract syntax rules, as we have implemented previously for activity models [GMP08]}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Ziadi et al. [ZHJ04] define their transformation by pseudocode operating on algebraic definitions of sequence diagrams and state machines, while our transformation is based on graph transformation. Our support for guards in alt/loop and support for par/opt/neg is new compared to their approach. With our fragment operator and the collection operator, we can define the transformation rules completely by graphical models. Sun, on the other hand, needs to use relatively complicated textual pre- and post-conditions associated with the rules.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We have shown how concrete syntax-based graph transformation rules can be used to specify a transformation from sequence diagrams to state machines. These rules are much more concise than traditional graph transformation rules which are specified in abstract syntax.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
It is a great advantage that the user can specify rules in the well known concrete syntax of sequence diagrams instead of the complicated and less intuitive abstract syntax version. On the other hand, in our approach we need to implement a translation from concrete syntax to abstract syntax-based rules. The extent to which there is a need for sequence diagram transformations in general decides if the implementation effort pays off in practice.}
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Formal Verification of UML Sequence Diagrams in the Embedded Systems Context (2011)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This paper shows a method for translating UML sequence diagrams to Petri nets and verifying deadlock-freeness, reachability, safety and liveness properties by using a model checker. In this proposed method, the user has not to know about temporal logics to describe the property to be}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
verified. Instead, the user may adopt a high-level properties specification interface, which is automatically translated to a suitable temporal logic. We show the application of the proposed method in an embedded control application. The proposed method provides the Petri net in three}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
different formats: APNN (Abstract Petri Net Notation), PNML (Petri Net Markup Language), and SMV (Symbolic Model Verifier). The APNN and SMV formats can be checked using the MCKit1 and SMV2 , respectively. Such translations are the first contribution of this paper. Several types of properties can be checked, e.g., deadlock-freeness, reachability, safety and liveness properties. These properties can be expressed with so-called state formula, which is a propositional logic formula consisting of atomic propositions and logical operators. Another contribution is that the user has not to know about CTL (Computation Tree Logic) to describe reachability, safety, or liveness properties. We propose a high level properties specification interface, which is automatically translated to CTL. Petri net model [6] is a kind of state-oriented model, specifically defined to model systems that comprise interacting concurrent tasks. The Petri net model consists of a set of places, a set of transitions, and a set of tokens. Tokens reside in places, and circulate through the Petri net by being consumed and produced whenever a transition fires. Petri nets are useful because they can effectively model a variety of system characteristics, and may be used to check several useful properties. Petri nets is used in this work because it is a well-consolidated technique for specifying concurrent systems.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Model checkers are capable of finding errors that are not likely to be found by simulation or test. The reason for this is that unlike simulators, which examine a relatively small set of test cases, model checkers consider all possible behaviors or executions of the system. Another feature of the proposed method is that it provides a mechanism for specifying the properties to be verified in the models at high level and using natural language. After this, such specification is automatically translated into a CTL formula, suitable to be run in several model checkers. The modeled system can consider systems distributed across multiple processors, where tasks may communicate via a shared bus. The result of applying the proposed method can be considered as the junction of the best of both worlds: (i) UML, which is considered an industry standard, it is a semi-formal model, and it is comprehensive approach; and (ii) Petri nets, a mathematical model and suitable for formal verification.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The translations rules considered in this work are based on an extended sequence diagram as proposed by Jeng and Lu [5]. The extension has the aim to improve the behavior of the systems, including concurrency, choice, synchronization, and confluence. Fig. 6 shows the concurrency, which is denoted by a solid line with hollow endpoints at the arrows, where all messages are considered as being concurrently executed. \~choice: Fig. 7 shows the choice, which is denoted by a dashed line with hollow endpoints at the arrows, where in each time only one message can be triggered to execute. \uc3 \u8592\'e2\'86\'90 bullshit, ignore paper! In the end it\u8217\'e2\'80\'99s translated to LTL which doesn\u8217\'e2\'80\'99t work for me! horrible English btw.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Supporting elicitation and specification of software properties through patterns and composite propositions}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Prospec is a tool that assists practitioners in the elicitation and specification of system properties. Practitioners are guided by questions, definitions, and graphics. Prospec is built upon the Specification Pattern System. The tool assists the analyst in making informed decisions about aspects of a specification that may have multiple interpretations. The end product of the tool is a formal specification in Future Interval Logic, Linear Temporal Logic, or Meta Event Definition Language. Two recent approaches that assist in the specification of properties are the Specification Pattern System (SPS) [6], [7] and a tool called }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Propel}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
[8]. Prospec, the tool introduced in this paper, extends patterns and asks the practitioner a series of questions to assist him or her in the specification process. The end product is a formal specification. Property patterns are classified based on the following structure of behavior: the occurrence of events or states (universality, absence, and existence) and the order of the events or states (precedence, response, chain of precedence, and chain of response). Universality properties are true in every point of the execution; absence properties are never true during the execution; existence properties are true at some point in the execution; precedence properties require that \~given state or event always occurs before a designated state or event occurs; and response properties require that the occurrence of a given state or event be followed by a designated state}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
or event. In SPS, the abstraction that handles multiple states or events is called chain. Chain precedence and chain response specify properties on sequences of states or events and are generalizations of precedence and response, respectively. SPS provides mappings of the specification patterns with its associated scopes sto formal languages. This is accomplished by defining a pattern and scope and their associated parameters. For instance, universality, absence, and existence patterns have a single parameter that defines the proposition to be considered. The precedence and response patterns have two parameters. With respect to scope, global scope has no parameters; scopes before and after have one parameter; and scopes between and after-until have two parameters. The mappings to formal languages consider only one state or event for each of the patterns or scopes parameters. SPS defines non-consecutive sequences of states or events (referred to as chains in SPS) only for response and precedence patterns. Composite propositions (CP) define relations among multiple propositions. The composite proposition taxonomy (refer to Fig. 7) categorizes and defines the structure of multiple propositions. The CP taxonomy has twelve classes; each class defines a detailed structure for either concurrent or sequential behavior. With the identification of a CP class, Prospec facilitates specification of ordered sequences, non-deterministic sequences, and concurrency. For instance, an ordered sequence may define the left boundary of an after L scope, and multiple events that represent the synchronous start of multiple tasks may define the effect part of a response pattern. Prospec uses guided questions to distinguish the types of scope or relations among propositions when more than one proposition is considered. By answering a series of questions, the analyst is led to consider different aspects of the property. The View Formula button enables the bottom window, which depicts the formal specification in FIL [11], LTL [12], or MEDL of the selected property. \uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Bullshit obviously}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
, some weird property specification formalism Future Interval Logic}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Manna and Pnueli [12] identified response properties as one of the most common in concurrent systems, and a study [7] revealed that the response pattern is the most commonly used pattern. By using composite propositions in either part of the response pattern (the cause or effect), it is possible to represent common behavior associated with concurrent systems, such as synchronized join and fork, concurrency, non-determinism, and sequences.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Prospec also supplements the work of SPS by generating Future Interval Logic (FIL) and Meta-Event Definition Language (MEDL) formulas. FIL provides basic interval constructs that enhance the readability of formulas requiring nested intervals. FIL specifications can be verified by a theorem prover [11]. Prospec generates MEDL formulas from FIL specification [14]. MEDL is the specification language of the runtime monitoring system called Java Mac [15].}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
...some of the formulas for Consecutive CP classes are not expressible in FIL...}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Required Behavior of Sequence Diagrams: Semantics and Refinement (2011)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
An SD is partial in that it describes a number of alternative obligations that an implementation may choose to fulfill. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For instance, the fragment operator par does not mandate that an implementation must be distributed, concurrent or multi-threaded. It rather indicates that the implementation can realize any interleaving of the behaviors of its operands. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
That SD Login2 is a correct reuse of SD Login can be informally checked as follows. SD Login3 may be obtained from SD Login2 by hiding messages key and chkK(replacing them by tau which stands for all unobservable messages), using default value true for kOK and changing the names back. We have shown that verification of SD refinement is important in software development such as in model driven, pattern-based and aspect-based software development. Refinement verification requires a formalization of a refinement relation between SDs which in turn requires a formal trace semantics that captures precisely required behaviors of SDs.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In existing behavioral semantics an SD denotes a set of all possible traces that the specified system may produce and a set of proscribed traces that the specified system must not produce. They are useful as a semantic base for verifying SDs against safety properties. However, they are not useful as a semantic base for defining a refinement relation between SDs since they do not tell which possible traces are required in that the specified system must produce. Semantics of SDs has also been given in terms of translations to these state machines such as statecharts, Buchi automata, labelled transition systems and modal transition systems. Since a state machine accepts one set of positive traces and one set of negative traces in the case of a Buchi automata and a modal transition system, a semantics based on translation to state machines does not capture precisely alternative but incomparable minimal required behaviors specified by an SD. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This paper gives a trace semantics that characterizes required behaviors specified in an SD and formalizes a refinement relationship between SDs. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Refinement is defined in terms of a simulation relation between traces. The notion of one trace simulating another will be made clear later. Roughly speaking, a trace t1 simulates another trace t2 if all events in t2 are simulated in t1 in the order in which they occur and there are no observable events in t1 other than those that simulate events in t2 . An SD D1 refines another D2 if an implementation of D1 is also an implementation of D2 . In other words, D1 preserves the required behaviors of D2 but may specify more required behaviors. These concepts will be made clearer in Section V. The main contributions of this work are as follows.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A novel trace semantics is formulated for a subset of UML SDs. Unlike the trace semantics proposed in literature [11], [32], [50] that capture possible behaviors of SDs, our trace semantics captures precisely required behaviors of SDs and forms a basis for a semantics based refinement relation. While those trace semantics for possible behaviors of SDs ignore guard conditions, our trace semantics encodes guard conditions in SDs as elements of traces.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A refinement relation between SDs is defined based on the semantics. The refinement relation is transitive, implying that the correctness of a multi-step refinement can be checked by verifying the correctness of each individual refinement step. The refinement relation also possesses substitutivity, implying that an SD can be refined compositionally. An SD has also been translated to a Petri net (e.g., [8], [17], [19]) with lifelines translated to processes, actions to transitions and messages to communication places and to abstract state machines. An LTS is a finite state machine with each transition labelled with an action (event) or \uc2 \u964\'cf\'84. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In summary, there does not exist a suitable semantic basis refinement of required behavior of SDs because direct style semantics do not precisely capture required behaviors of SDs and translations to other formalisms disregard essential features of SDs such as guard conditions and critical regions.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In this work, we do not consider interaction operators ignore, consider, assert, neg or break. Since we are concerned with checking if the behaviors described by one model are found in another model, ignore and consider fragments play no role and thus can be removed. Despite prior effort in clarifying assert and neg operators [29], [51], no commonly accepted interpretation for these operators has been established. The UML 2.0 standard states that \uc3 \u8220\'e2\'80\'9ca break fragment is a breaking scenario that is performed instead of the remainder of its enclosing fragment\u8221\'e2\'80\'9d. It is not clear whether the enclosing fragment means the innermost enclosing fragment or the innermost loop fragment. We assume that all references to SDs through interaction operator ref have been eliminated via syntactic unfolding since SDs are non-recursive.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
[...tons of formulas/lemmas/..]}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
User Guidance for Creating Precise and Accessible Property Specifications (follow up on the PROPEL paper)}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Ideally, property specifications should be precise enough to support automated validation techniques and accessible enough to be readily understood by system developers. Automated validation tools typically accept property specifications represented in mathematical formalisms, such as temporal logic. Such formalisms have not been widely adopted by developers, in part because their use requires significant expertise [21]. In practice, developers tend to write requirements and design specification documents in natural language [16]. While natural language may offer accessibility, properties written with such informality are often ambiguous and thus are of limited value when doing rigorous analysis of the system. Additionally, accurately representing a property, even one that focuses on a very limited subset of the system\uc3 \u8217\'e2\'80\'99s behavior, can be surprisingly difficult because of all the subtle details that should be considered. Overlooking these details often leads to inaccuracies that are not revealed until verification or testing, or perhaps even deployment. \u8592\'e2\'86\'90 for future work\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
In previous work, we proposed a property-specification approach [20] that aims to guide users through the process of creating property specifications that are both accessible and mathematically precise. Propel, for \uc3 \u8220\'e2\'80\'9cPROPerty ELucidator,\u8221\'e2\'80\'9d is a tool that supports this approach by providing users with a set of property templates that explicitly indicate the variations that must be considered, thereby ensuring that important subtle details are not overlooked by users. Each template can be represented as a set of natural language phrases or as an extended finite-state automaton (FSA). Users can select the appropriate variation using either or both representations. Users do not need to have expertise in a particular specification formalism to use the natural language representation. The associated FSA specification, however, can be used as the basis for verifying system behaviors and other types of analyses. \u8592\'e2\'86\'90 for future work! \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Our previous work did not attempt to address the issue of how to guide users in selecting the appropriate template. In this paper, we describe the Question Tree (QT) representation, which is designed to provide this additional user guidance. The QT representation is basically a decision tree, a representation that has often been used in requirements engineering. The content of the QT is based on natural language and its hierarchical format guides users through the elaboration of intended properties by asking questions and, for each question, providing a set of alternative answers for users to select from. The QT breaks up the problem of deciding which template is most appropriate by asking users to consider only one differentiating attribute at a time. The hierarchical structure of the QT supports this isolation of concerns, only presenting questions to the users that are relevant in the context of their previous answers.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Dwyer et al. observed that nearly all the properties found in the FSV literature could be classified into a small number of what they described as \uc3 \u8220\'e2\'80\'9chigh-level, formalism-independent, specification abstractions.\u8221\'e2\'80\'9d Each of the specification abstractions, or property patterns, is composed of two parts: a behavior (or \u8220\'e2\'80\'9cintent,\u8221\'e2\'80\'9d as it is called in the property patterns work) and a scope. A behavior describes the restrictions on occurrences of states or events, and a scope describes the parts of the state- or event-sequences within which those restrictions apply. The property pattern work identifies eight behaviors and five scopes that can be combined to create forty different properties. Dwyer et al. recognized, however, that other variations of the behaviors and scopes might be required, and their website [7] includes notes on how to modify the formal specifications associated with the property patterns to obtain some of these variations.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
These property pattern templates are each composed of a scope template, which contains options related to the selected scope, and a behavior template, which contains options related to the selected behavior. By making decisions about these options, users can create 32 possible scopes and 139 possible behaviors, which can be composed into over 4,400 different possible properties. As with the property patterns work, however, the space of properties available is not intended to cover all possibilities, just variations on the most commonly-occurring properties. Like the property patterns, the property pattern templates have up to four predefined placeholders, or parameters, that can be associated with user-defined event names: at most two for the property\uc3 \u8217\'e2\'80\'99s behavior and at most two for the property\u8217\'e2\'80\'99s scope. One representation is a graphical, extended FSA template that resolves to an FSA. The FSA template representation helps developers see the options that need to be considered by representing those choices with optional versions of FSA states, transitions, and transition labels. In addition, since the fully-instantiated form of this representation is an FSA, which is mathematically well-defined, this representation offers the precision necessary for many types of analysis, including FSV. \~second representation is a disciplined natural language (DNL) template that is intended to appeal to those users who prefer a natural language description. The QT is a third representation. As mentioned, this representation was originally designed to help users select which property pattern template to use when elaborating their properties. We soon discovered, however, that this representation was useful not only for helping users to select the appropriate property pattern template, but also for helping them to resolve the options associated with that selected template. In Propel, we break the QT representation into two separate parts, one for the scope templates and another for the behavior templates. \u8592\'e2\'86\'90 for future work, I can build up on this paper! Because they don\u8217\'e2\'80\'99t translate them to any formalism, only structured natural language and FSA(M)? \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Note that the \uc3 \u8220\'e2\'80\'9c\uc2 \u172\'c2\'ac\uc3 \u8221\'e2\'80\'9d shorthand notation in this representation is a set-complement operator for all (i.e., both primary and secondary) events in the alphabet. We have used Propel to represent the properties encountered in four case studies we are undertaking in the medical domain. We have encountered a total of 84 properties thus far and were able to use Propel to express 83% (70 of 84) of them. We found that 63% of the behaviors are some form of Precedence, where one event cannot occur until after another event occurs (e.g., the checks that must be done before a treatment), and 21% of the behaviors are some form of Response (e.g., the necessary response to a patient\u8217\'e2\'80\'99s negative reaction to a treatment). It is interesting to note that the relative prevalence of these two behaviors differs from what was reported in [8]; there, 5% were some form of Precedence and 44% were some form of Response, the most prevalent of the behaviors surveyed in that work. It is likely that this difference is due to the fact that these two collections of properties are drawn from different domains; Of the 14 properties that cannot be handled in Propel, we expect that all but two can be handled by fairly straightforward extensions that we plan to make, such as adding support for chain property patterns, for a pattern where one event blocks another event from occurring, and for disjunction. The tool automatically keeps the DNL, FSA, and QT representations consistent with each other and is thus designed to help users resolve misunderstandings by making it possible to compare the representations. Many property specification approaches aim to provide either accessibility or precision; few approaches try to provide both. For example, structured natural language recommendations (e.g., the NL templates in [5]) provide accessibility but not precision, and formal specification languages (e.g., the temporal logics in [3]) provide the opposite.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
While the NL descriptions in Prospec map to the underlying formal logics that the tool supports, the NL descriptions are not intended to be used as property specifications; they are mainly just expansions on the Dwyer et al. NL descriptions. }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
While creating properties for the case studies, we soon discovered that we needed support for collections of properties. Propel provides two capabilities that support property collections. One is a project directory hierarchy, where users can define projects and subprojects and then associate each property with a project in the hierarchy. As noted previously, there are some other patterns that we plan to support, since these patterns have arisen several times in our case studies. Some of these patterns, such as chains, are included in the property patterns and some are not, such as the concept of one event blocking the subsequent occurrence of another event and the concept of alternation. Properties that involve a conjunction or disjunction of events also merit further scrutiny.}
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
-----------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Pattern-Based Modeling and Analysis of Failsafe Fault-Tolerance in UML}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Furthermore, some existing analysis methods for fault-tolerance assume that a specific fault-tolerance design mechanism (e.g., exception handling, redundancy) will be used and specify analysis requirements within those design constraints, which may overly constrain and preclude useful fault-tolerance solutions. We introduce an object analysis pattern, called the detector pattern, that provides a reusable strategy for eliciting and specifying the requirements of error detection in UML object models for embedded systems.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Our pattern-based method comprises fault modeling, fault-tolerance modeling, and automated analysis of the UML models of fault-tolerant embedded systems. Intuitively, failsafe fault-tolerance requires that nothing bad ever happens even in the presence of faults. The general UML to-Promela formalization approach of Hydra is to map objects to processes in Spin that exchange messages via channels. Nested and concurrent states are also formalized as processes. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
An executable object-oriented semantics and its application to firewall verification}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
This paper presents a formal executable semantics of object-oriented models. We made it possible to conduct both simulation and}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
theorem proving }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
on the semantics by implementing it within the expressive intersection of the functional programming language ML and the theorem prover HOL. In this paper, we present the definition and implementation of the semantics. We also present a prototype verification tool ObjectLogic which supports simulation and theorem proving on the semantics. The internal representation of the semantics is a heap memory structure to store objects. The HOL system is a theorem prover of higher-order logic which is implemented in Moscow ML. In HOL, the semantics is implemented as a theory which is a module containing types, constants, operators, and axioms. (examples resemble the data type definitions in mCRL2). }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Seems that only classes, attributes and their relationships (inheritance etc..) are presented in the semantics...how about behavior? So semantics of the class model is defined.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Figure 4 shows its architecture. OML is the input language which consists of classes, methods, and assertions (method contracts and class invariants). It is input to the OML parser which extracts the class model and abstract syntax trees for methods and assertions. The class model is input to the semantics generator and the semantics is constructed in ML and HOL.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
OML is designed to facilitate the modeling of software applications. It supports classes, attributes, methods, single inheritance. The expressiveness is close to UML sequence diagrams, i.e., it contains conditional branches and finite loops. \~\uc3 \u8592\'e2\'86\'90 still not as expressive as UML fragments from what I can see...\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The advantage of ObjectLogic is that it enables us to perform theorem proving on the level of objects which is close to our intuition. This makes the proof easy to read compared with the proof on the level of primitive theories such as pairs and lists. It also makes it easy for us to debug the model, i.e., as the abstract level is the same as that of the model, we can easily identify which part of the model was wrong when a proof failed. \uc3 \u8592\'e2\'86\'90 close to our intuition for ppt\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ACL2 is well known as the tool to combine a programming language and a theorem prover. It is based on an applicative subset of Common Lisp. It is often used as the semantics for both simulation and theorem proving. We followed the approach of combining a programming language and a theorem prover using ML and HOL. The reason for the use of HOL is to construct the OO semantics conservatively by definitional extension. To derive our semantics from the definitions, it requires the expressiveness of the higher-order logic. Specifically, we need the induction theorem on lists to derive the properties about the heap memory operations. \~Interactive verification tools for OO specification: The KeY tool [1] is a software development system based on UML. It supports construction of the specification in OCL and the implementation in Java Card. It also supports verification of both of them by generating proof obligations in dynamic logic, an extension of Hoare logic. The HOL-OCL tool [6] is an interactive proof environment for UML/OCL.}
\par \pard\plain \s17\sb0\sa120{\rtlch \ltrch\loch
}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
------------------------------}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Tool support for learning Buchi automata and linear temporal logic }{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
\uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
VERY RELEVANT!}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
We introduce a graphical interactive tool, named }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
GOAL}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
, that can assist the user in understand-}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
ing Buchi automata, linear temporal logic, and their relation. B \uc2 \u776\'cc\'88chi automata and linear temporal logic are closely related and have long served as fundamental building blocks of linear-time model checking. \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Understanding their relation is instrumental in discovering algorithmic solutions to model checking problems or simply in using those solutions, e.g., specifying a temporal property directly by an automaton rather than a temporal formula so that the property can be verified by an algorithm that operates on automata. \uc3 \u8592\'e2\'86\'90 for meeting, for future work as well!\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
One main function of the GOAL tool is translation of a temporal formula into an equivalent Buchi automaton that can be further manipulated visually. The user may edit the resulting automaton, attempting to optimize it, or simply run the automaton on some inputs to get a basic understanding of how it operates. GOAL includes a large number of translation algorithms, most of which support past temporal operators. With the option of viewing the intermediate steps of a translation, the user can quickly grasp how a translation algorithm works. The tool also provides various standard operations and tests on Buchi automata, in particular the equivalence test which is essential for checking if a hand-drawn automaton is correct in the sense that it is equivalent to some intended temporal formula or reference automaton. The specification of a behavioral property typically asserts temporal dependency between occurrences of certain events (represented by propositions) and linear temporal logic has thus become a particularly popular class of languages for specification. Temporal dependency between events may also be expressed with }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Buchi automata, which are finite automata operating on infinite words (that correspond to infinite computations)}{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Indeed, Buchi automata and linear temporal logic are closely related. It has been shown that Buchi automata and a variant of linear temporal logic called quantified propositional temporal logic (QPTL) are expressively equivalent, though translation between the two formalisms is highly complex As Buchi automata are also suitable as abstract system models, }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
many researchers have advocated a unified model-checking approach based on automata. In this automata-theoretic approach, the negation of the temporal specification formula is translated into an automaton, representing the bad behaviors. The intersection of the system automaton and the negated-specification automaton is then constructed and checked for emptiness. If the intersection automaton accepts no input, i.e., the system and the negated specification do not have any common behavior, then the system is correct with respect to the original specification formula. \uc3 \u8592\'e2\'86\'90 we advocate the same; for future work, for meeting also!! This is the essence of the approach\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Despite the possibility of mechanical translation, a temporal formula and its equivalent B \uc2 \u776\'cc\'88chi automaton are two very different artifacts and their correspondence is not easy to grasp. Temporal formulae describe temporal dependency without explicit references to time points and are in general more abstract, while Buchi automata \uc3 \u8220\'e2\'80\'9clocalize\u8221\'e2\'80\'9d temporal dependency to relations between states and tend to be of lower level. Understanding their relation is instrumental in discovering algorithmic solutions to model checking problems or simply in using those solutions, e.g., specifying a temporal property directly by an automaton rather than a temporal formula so that the property can be verified by an algorithm that operates on automata.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
There are other tools that provide translation of temporal formulae into Buchi automata, e.g., SPIN [Hol03], LTL2BA [GO01], Wring [SB00], MoDeLLa [ST03], and LTL2Buchi [GL02]. SPIN in particular is an automata-theoretic model checker that has been widely used both in practice and in education. A Buchi automaton accepts those inputs that can drive it through some accepting state infinitely many times. }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Propositional Temporal Logic to refer to the pure propositional version of LTL, for which a state is simply a subset of atomic propositions holding in that state. In the literature there are two versions of PTL. One has past and future temporal operators, while the other contains only future operators (Clarke et al.,referred to as LTL here). }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Every PTL formula can be translated into an equivalent Buchi automaton, but not vice versa! In the sense that each infinite sequence satisfying the formula corresponds to an infinite word accepted by the automaton.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
PTL is strictly less expressive than Buchi automata. The property \uc3 \u8220\'e2\'80\'9cp is true at every even position\u8221\'e2\'80\'9d (an infinite word or sequence starts with position 0), referred to as \u8220\'e2\'80\'9cEven p\u8221\'e2\'80\'9d here, is a typical example for showing the difference. Model Checking Model checking seeks to automatically verify if a given system satisfies its specification [CGP99]. The system is typically modeled as a Kripke structure\u8212\'e2\'80\'94a state-transition graph where each state is labeled with those propositions that hold in the state; fairness may be imposed on how often the states should be visited. When the specification is given by a linear temporal logic formula, the model checking problem is to determine if every computation (sequence of states) generated by the Kripke structure satisfies, or is a model of, the temporal formula.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
The system may also be modeled as a Buchi automaton; in fact, every Kripke structure (with or without the usual fairness conditions) corresponds to some Buchi automaton. As the specification formula can also be translated into a B \uc2 \u776\'cc\'88chi automaton, \uc1 }{\scaps0\caps0\cf1\i0\ul\ulc0\b\rtlch \ltrch\loch\fs22\loch\f5
this results in a uniform treatment of both the system and its specification}{\scaps0\caps0\cf1\strike0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch
 \uc3 \u8592\'e2\'86\'90 \uc1 }{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
for future work, for meeting!}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Let L(A) be the lnaugage of the automaton A - model of the system. Let L(B) be the language of the automaton representing the specification (property). Then the model checking problem translates into language containement: whether L(A) is contained in L(B). if !L(B) is the complement of L(B), and !B is the complement of B, then the problem is equivalent to checking if L(A) intersection !L(B) is empty, i.e. L(A intersection !B) is empty. But complementing Buchi automaton is expensive. It\uc3 \u8217\'e2\'80\'99s better to first negate the specification formula and obtain the automaton for it.\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
Translating QPTL (and PTL) Formulae into Buchi Automata: Nine algorithms have been implemented for temporal formula to B \uc2 \u776\'cc\'88chi automaton translation. Once an automaton has been defined and tested, the user can export it in the Promela (the system modeling language of SPIN) syntax on the screen or as a file. This makes it possible to use GOAL as a graphical specification definition frontend to an automata-theoretic model checker like SPIN. \uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
For a student who has taken a course on the classical theory of computation, the key to understanding Buchi automata is to first comprehend the concept of an infinite word and how a Buchi automaton operates on an infinite word. One obvious thing to do is examining a few examples of how an infinite word drives a Buchi automaton through the different states of the automaton, which can be conveniently carried out with GOAL.}
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b0\animtext0\rtlch \ltrch\loch\fs22\loch\f5
A Buchi automaton for <>[]p (p always holds from some point on) would be a simple enough starting example for illustrating how a B \uc2 \u776\'cc\'88chi automaton operates on infinite words. In GOAL, an infinite word pp\uc3 \u8764\'e2\'88\'bcpppp \uc2 \u183\'c2\'b7 \u183\'c2\'b7 \u183\'c2\'b7 (with p repeating indefinitely) is represented as (p)(p)(\uc3 \u8764\'e2\'88\'bcp)\{(p)\}. Understanding how a temporal formula can be translated into a Buchi automaton is an essential step in learning automata-theoretic model checking Buchi automata are closed under boolean operations and these operations can be done algorithmically. To learn any of the boolean operations, the user can perform the operation by hand and then verify correctness by checking the equivalence between the resulting automaton (hand-drawn using the automaton editing function of GOAL) and the machine-computed one (also by GOAL).\uc1 }
\par \pard\plain \s17\sb0\sa120\sl273\slmult1\qj\sb0\sa0\ltrpar{\scaps0\caps0\cf1\strike0\i0\ulnone\ulc0\b\animtext0\rtlch \ltrch\loch\fs22\loch\f5
GOAL is particularly useful for learning the complementation operation, which is very complex and difficult to understand. It should be a helpful and interesting exercise for the student to go through the typical verification steps: (1) prepare a system Buchi automaton for some small verification problem, e.g., the two-process mutual exclusion problem, (2) write a temporal formula describing the system\uc3 \u8217\'e2\'80\'99s safety property (e.g., mutual exclusion) or liveness property (e.g., starvation freedom), (3) negate the formula and translate it into a Buchi automaton, representing all \u8220\'e2\'80\'9cbad\u8221\'e2\'80\'9d behaviors, (4) compute the intersection of the given system automaton and the translated negative specification automaton, and (5) check the emptiness of the intersection. For example, besides Buchi and generalized B \uc2 \u776\'cc\'88chi automata, we have extended GOAL to support the editing of and a limited set of operations on Muller, Rabin, Streett, and Parity automata. Although these variants of \u969\'cf\'89-automata do not necessarily have a direct impact on the model-checking process, they are powerful intermediaries for the development of automata-based algorithms and will make GOAL complete as a learning and teaching tool.\uc1 }
\par \pard\plain \s17\sb0\sa120\sb0\sa120{\b0\rtlch \ltrch\loch
\line }
\par }