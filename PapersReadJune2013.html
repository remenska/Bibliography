<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="LibreOffice 3.5  (Linux)">
	<META NAME="AUTHOR" CONTENT="Daniela ">
	<META NAME="CREATED" CONTENT="20130616;17351200">
	<META NAME="CHANGEDBY" CONTENT="Daniela Remenska">
	<META NAME="CHANGED" CONTENT="20130701;17192400">
	<STYLE TYPE="text/css">
	<!--
		@page { margin: 0.79in }
		P { margin-bottom: 0.08in }
		A:link { so-language: zxx }
	-->
	</STYLE>
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none"><A NAME="docs-internal-guid-3893ea67-4d92-70d3-dfce-905273d24007"></A>
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Papers
read March 2013:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Mapping
of Structured English Sentences to CCTL Formulae</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">As
computer–based systems design deals with more complex behavior
formal verification be-</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">comes
widely accepted as a complementary approach for system simulation and
testing.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Furthermore,
compared to pure CTL–related formulae,</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">specifications
given in structured English can be easier communicated to a second
user. Each</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">of
our sentence corresponds to a CCTL (Clocked CTL) formula to which it
is translated for the</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">RAVEN
model checker. It is ordered by syntactical criteria of formulae so
that it</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">often
does not match the way of thinking when compiling a specification. A
first extensive</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">systematical
classification of specifications for finite-state verification was
published in [1]. The</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">classification
is based on design patterns that were originally used to capture
recurring solutions</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">to
design and coding problems [3]. That classification presents a
semantically ordered hierarchy</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">of
property patterns and gives detailed information for each identified
pattern with respect to</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">the
requirements for well-defined design patterns. All patterns are
identified by an informal</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">description
of the intent, example mappings to different specification
formalisms, their known</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">application,
and relationships to similar patterns. In a more recent publication,
a slightly</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">different
pattern system is presented based on the investigation of more than
500 examples for</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">property
specifications [2].</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
Testbed project [6] introduces a graphical user interface for busi-</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">ness
process modeling and provides a small set of templates for
verification with the SPIN model</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">checker
[5]. <B>← [6] is called “Model checking for managers” :D</B></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent"><B>In
a more general approach for English language oriented specification,
the PROSPER project</B></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent"><B>aims
at the specification through a natural English language subset [4].
The user specifies the</B></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent"><B>property
in an interactive dialog with the system. Syntactically correct
English sentences are</B></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent"><B>finally
converted after parsing into CTL formulae as input to the SMV model
checker. Major</B></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent"><B>remaining
challenges are the detection of ambiguities, handling of
context-sensitive expressions,</B></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent"><B>and
consideration of domain-specific conventions in sentences.</B></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">CCTL
(Clocked CTL) is a temporal logic in the context of the real-time
system model checker</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">RAVEN.
In RAVEN, the model is specified in terms of so–called I/O-interval
structures. I/O-</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">interval
structures are basically state transition systems with time
annotations. A time anno-</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">tation
is a time constraint which specifies a [min,max]-time interval for a
state transition .</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
A resp. E are run quantifiers. A run is an infinite sequence of pairs
of states and clock</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">values
(called a configuration) of the system. Every pair of states and
clock values may be the</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">start
point of a run. The A-quantifier checks for the actual configuration
if all runs satisfy</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">the
temporal operator. The E-quantifier checks if there exists at least
one run starting in the</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">actual
configuration satisfying the temporal operator. Model checking
examines the properties</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">with
respect to the initial states of the system.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
user compiles a specification by selecting those lists and fragments
and combines</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">them
to meaningful sentences of limited length and complexity. The
fragments are so defined</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">that
they only combine to sentences which directly correspond to CCTL
formulae. In order to</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">provide
a sufficient coverage in application the introduced fragments are
derived from patterns</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">which
are identified as being frequently used.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Towards
a Maude Tool for Model Checking Temporal Graph Properties Visual
temporal logic as a rapid prototyping tool</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
major novelty of our tool is that it provides a model checker for
temporal graph properties based on counterpart semantics for
quantified μ -calculi. Graph transformation systems are specified
with term rewrite rules. In particular, we present first an
implementation of graph rewriting as conditional rewrite rules on
object multisets, which allows us to compositionally specify
concurrent systems in an object-oriented fashion. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Then
we introduce a prototypical model checker that can be used to check
quantified μ -calculus formulae against system specifications. As
far as we know, our tool is one of the few model checkers for a
quantified μ -calculus and one of the few ones based on counterpart
semantics, allowing for a finer analysis of the evolution of
individual components.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Graph
rewrite rules To compositionally specify concurrent systems, we offer
an object oriented language, based on an implementation of the double
pushout approach (DPO) to graph rewriting: our systems can be hence
seen as graph transformation systems specified by an initial state
and a set of term rewrite rules given in DPO style. The main idea is
that each rule has a left-hand side and a right-hand side pattern,
each one composed by a set of objects (nodes) possibly interrelated
by means of relation attributes (edges).  The aim of this section is
to illustrate the use of the tool to verify properties of the
evolution of software systems, focusing on properties of
individuals.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">For
the rest of this section we fix an instance of our running example
with n = 2, where all the people of the same gender have the same
ranking. An interesting property is the one stating that every time
a male becomes single, he will later on become married.  </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">forall
xMale(0). AG((status(xMale(0)) = status: single) -&gt;
(AF(status(xMale(0)) = status: married)))</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Other
interesting properties regard the consistency of marriages. A
meaningful example is “is it possible for two males to claim to be
married with the same female?”, expressed by the formula</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">not(xMale(0)
= xMale(1)) and (marriedWith(xMale(0)) = marriedWith(xMale(1)))</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">This
can seem an erroneous scenario, but actually it happens because of
the asynchronous and distributed fashion of the modelled algorithm:
when a married woman accepts a new marriage proposal, she sends a
divorce notification to the former partner and an accept notification
to the new partner. In the case in which the accept notification is
handled before the divorce one we have two males claiming to be
married with the same woman. The consistency is restored at the next
step, after the handling of the divorce notification. In its current
form, the model checker generates the entire counterpart model for a
given specification and checks formulae on it. That is, our model
checker does not yet verify properties on-the-fly, neither it does
apply optimisation techniques based on symmetry or abstraction
reduction. These issues are subject of current work as they could
push our approach beyond its current bounded model checking form.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent"></SPAN></B><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: transparent">Their
prospects for gaining comprehensibility of even complex
specification are deemed so high that it should be possible to
simultaneously further the level of formality without sacrificing
understandability. However, even with graphical specifications, the
global interaction patterns of complex (for example, distributed)
systems remain complex and, furthermore, it seems that graphical
idioms also tend to hide some of the fine-grain semantics from the
user, at least from the non-expert one. Thus, while being a big step
ahead, graphical specification formalisms are not per se a means for
ensuring that “what you specify is what you mean”.</SPAN></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent"><SPAN STYLE="font-weight: normal">A
traditional remedy is rapid prototyping, where a partially developed
product is brought into executable shape in order to assess its
compliance with expectations. We suggest to take over the paradigm of
“rapid prototyping” to the realm of formal, graphical, and
declarative (i.e., intrinsically non-operational) specifications such
that these become executable, thereby facilitating early evaluation
of specifications on an operational model. If such a prototyping
process is based on an unambiguous semantics of specifications and
applies rigorous rules for deriving executables from specifications
then it can, furthermore, be made sure that the prototype obtained is
in strict correspondence with the specification such that the
evaluation is faithful.</SPAN></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Real-time</SPAN></B><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: transparent">
symbolic timing diagrams (RTSTDs, for short), as introduced in [2],
are a graphical formalism for specifying behavioural requirements on
hard real-time embedded systems. They are a full- edged metric-time
temporal logic, but with a graphical syntax reminiscent of the
informal timing diagrams widely used in electrical engineering.</SPAN></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent"><SPAN STYLE="font-weight: normal">An
activation mode. Initial diagrams describe requirements on the
initial system behaviour whereas</SPAN></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent"><SPAN STYLE="font-weight: normal">an
invariant diagrams expresses requirements which must be satisfied at
any time during system lifetime. Invariant mode corresponds to the
‘always’ modality of linear-time temporal logic. This causes the
timing diagram to be preempted and thus to impose no further
constraints on the temporal behaviour as soon as any weak constraint
arc becomes violated.</SPAN></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent"><SPAN STYLE="font-weight: normal">Being
motivated by the needs of synchronous system design, we slightly
deviate from the usual interpretation of clocks in timed automata
[11] and assume that clocks count transitions rather than an
independent system time. Note that this is in fact equivalent to
assuming that one transition takes place every time instant, which
can be enforced by using an additional clock in the standard model
of timed automata. Our convention merely saves this clock.</SPAN></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent"><SPAN STYLE="font-weight: normal">However,
this construction is extremely expensive due to the double
complementation of Buchi automata involved. This is the reason for
in practice confining ourselves to deterministic timing diagrams.
These yield timed Buchi automata ATD which are extremely simple and
cheap to complement, as they are deterministic and the only kind of
loops occurring in above construction is self-loops, where a state
directly loops back to itself. Under these circumstances,
complementation of ATD can be achieved by simply complementing the
set of accepting states, 4 even though we are dealing with Buchi
acceptance.</SPAN></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent"><SPAN STYLE="font-weight: normal">With
the basic method, game graphs grow exponentially in the number of
timing diagrams due to the automaton product involved in dealing with
conjunction. As this would render application for rapid prototyping
impractical, the ICOS tools o er modified procedures which reduce
the complexity of dealing with large specifications. Obviously, such
extensions cannot deal efficiently with arbitrary RTSTD
specifications, but they are, however, carefully designed to cover
the typical specification patterns.</SPAN></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent"><SPAN STYLE="font-weight: normal">The
first such variant is a compositional extension of the basic
algorithm. Within this approach, which is sketched in Fig. 5, the
specification is first partitioned into a maximal set of groups of
formulae G1 ; : : : ; Gn such that each output is constrained by the
formulae of at most one group.</SPAN></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent"><SPAN STYLE="font-weight: normal">Then
synthesis down to a winning strategy is performed for each group
individually, yielding for each group Gi a Moore automaton Ai that
has just the outputs constrained by Gi as outputs, and all other
ports as inputs. The individual Moore automata are then compiled to
synthesizable VHDL and composed by parallel composition.</SPAN></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent"><SPAN STYLE="font-weight: normal">Completeness
is, however, lost using compositional synthesis. The problem is that
a certain group may not be synthesizable without knowledge about the
behaviour of another group. Such problems are regularly encountered
within compositional methods, and we propose to solve them by just
the same techniques that proved to be helpful in compositional
veriÿcation: the necessary information on the other components can
be formalized via assumptions (for example, through weak constraint
arcs).</SPAN></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent"><SPAN STYLE="font-weight: normal">This
makes dealing with timing constraints of more than a handful time
units hardly affordable—realistic real-time system programming
cannot be done with such code generation methods. Therefore, we are
heading for an algorithm that is of linear complexity in the number
of timing constraints, even though completeness is thereby
necessarily sacriÿced. What is thus needed is a synthesis method
that separates generation of timers controlling the allowable passage
of time from synthesis of an untimed control skeleton. From then on,
synthesis treats the timers similar to environment components, which
means that the behaviour of these components is left untouched
during synthesis. </SPAN></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent"><SPAN STYLE="font-weight: normal">We
have presented a rapid-prototyping framework for requirements
speciÿcations that are for-</SPAN></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent"><SPAN STYLE="font-weight: normal">malised
through real-time symbolic timing diagrams, a metric-time temporal
logic with a graphical</SPAN></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent"><SPAN STYLE="font-weight: normal">syntax
akin to the informal timing diagrams used in electrical engineering</SPAN></SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Events
and Constraints: A Graphical Editor for Capturing Logic Requirements
of Programs </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
stumbling block can be that model checking tools expect the user to
supply a formal statement of the correctness requirements to be
checked in temporal logic. Expressing non-trivial requirements in
logic, however, can be challenging. To address this problem, we
developed a graphical tool, the TimeLine Editor, that simplifies the
formalization of certain kinds of requirements. <B>The TimeLine
editor simplified the task of converting a large body of English
prose requirements into formal, yet readable, logic requirements. </B></SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
the absence of specific requirements to be checked, a model checker
will check for some generally desirable program requirements such as:
absence of deadlock, livelock, and unreachable code. However, if one
wants to check specific requirements, or in other words, check that
the source code satisfies application-specific requirements, then
some requirements must be defined. LTL allows one to describe how a
system’s events and states are related over time, which is exactly
what we need for expressing logic control and communications
requirements. To support the second approach, we built a graphical
TimeLine Editor that can generate formal requirements from a visual
representation of required causal relations. The TimeLine Editor is
well suited for expressing the types of requirements encountered in
the PathStar application. Specifically the TimeLine Editor can
express requirements with a preamble (a sequence of events that act
as a pattern to be matched against execution sequences) and a
response. Other visual notations [1][13] have been developed to
address the expressive needs of different applications, or to express
a broader set of requirements. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">To
be amenable to model checking, a requirement must also specify the
temporal behavior of a system; that is, how the system acts in
response to external stimuli and internal conditions over time. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Spin
uses the formal requirements (expressed in temporal logic or with the
help of the TimeLine Editor tool) to fine-tune the program model with
a slicing technique. <B>The slicing algorithm in Spin uses data
dependency analysis and control flow analysis to automatically
abstract away details of the model that are not relevant to the
requirement being checked, while retaining the parts of the model
that are relevant to the requirement. The abstraction that is
employed here has the important property that it is logically
conservative, which means that if the abstracted model can be shown
to satisfy the correctness requirement, then the original source
program necessarily also satisfies that requirement. Using the
requirements to guide the generation of the abstract model of the
source code helps to ensure that the levels of abstractions in the
requirement and the model match. </B>For instance, if the
requirements are concerned with the fact that a full digit string has
been entered rather than the particular digits in the digit string,
then in the model  extraction step we can automatically abstract away
most of the details of the digit analysis code so that we only retain
the possible outcomes: invalid digits, partial digits or full digit
string. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">In
traditional testing one would drive the system into a particular
state of interest by feeding it a sequence of events, called the
preamble. After the preamble, the tester awaits the expected
response. In model checking the preamble becomes a pattern that is
matched against the executions of the system. The requirement defined
by the highlighted path should pass the check. This means that if the
model checker can find any execution where the initial state and
preamble occur, but the required event does not, this will be
reported as a violation of the requirement. Just as in traditional
testing, in model checking the requirement is not useful if the
preamble is not correct. In model checking an incorrect preamble
could give a vacuously positive result because it might not match any
execution in the system. We can debug the preamble by asking the
model checker to find at least one sequence that matches the
preamble. If the model checker finds a match, then we know that our
preamble is not vacuous. If the model checker does not find such an
execution, the preamble is likely to be incorrect and we can
reconsider its definition. Describing an accurate preamble can be
cumbersome in temporal logic. In LTL, chains of events are most
naturally expressed by a continued functional nesting of Until sub
formulae. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">To
clarify what was meant by a certain LTL requirement, a timeline
diagram would be drawn on the board. Once it was observed that the
timeline diagram could express the requirements of interest to the
application, and that it was possible to automatically convert the
timeline diagrams directly to Büchi automata, a decision was made to
build the TimeLine Editor tool. A timeline is represented by a wide
horizontal bar, as illustrated in Figure 3, <B>with time progressing
from left to right.</B> (← beware!!) Descending from the timeline
bar are vertical bars, called marks, which mark the interesting event
occurrences, ordered in time. The events can be generated anywhere in
the system, by any one of many concurrent processes in the
distributed system. Therefore, no fixed time-interval can be assumed
between subsequent marks (there is no hidden assumption of a “global
clock”). There are three types of system events that can be
indicated on the timeline. <B>Regular</B> events - denoted by the
letter <B>e</B>. These are optional events, that are used to identify
the precise executions of the system that we are interested in. For a
switch, a regular event could be the user going offhook, flashing the
hook, or the arrival of an incoming call. Most regular events are
generated by test harness components, that is, the stubs of
components external to the system under test. <B>Required</B> events
- denoted by the letter <B>r</B>. These are events that are required
to occur if all previous events (regular and required) on the
timeline have occurred, under the applicable constraints (more about
constraints later). It is an error if is possible for a required
event to be absent from an execution under these circumstances. For a
switch, a required event might be the generation of dialtone, or the
forwarding of a call. <B>Fail</B> events - denoted by the letter <B>f
</B>and a red X. These are events that should not occur if all
previous events (regular and required) on the timeline have occurred,
under the applicable constraints. In addition to events, there are
also constraints, which are black horizontal lines positioned beneath
the timeline bar. We can use constraints to specify that we are not
interested in the occurrence of particular events over certain
intervals of the requirement. For instance, if there is a requirement
that the system must respond to an offhook by providing dialtone, we
can specify the constraint !onhook for the interval between the
offhook and the dialtone event. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
addition to events, there are also constraints, which are black
horizontal lines positioned beneath the timeline bar. We can use
constraints to specify that we are not interested in the occurrence
of particular events over certain intervals of the requirement. For
instance, if there is a requirement that the system must respond to
an offhook by providing dialtone, we can specify the constraint
!onhook for the interval between the offhook and the dialtone event.
A constraint begins at one mark and ends at the same or at a
subsequent mark. A constraint can include or exclude the marks where
it begins or ends. If a constraint excludes a mark the end point of
the constraint will not overlap the mark but will terminate with a
short vertical bar near the mark. If a constraint excludes its begin
mark, then the constraint does not apply when the event attached to
this mark occurs (but it still may hold unless expressly stated
otherwise by another constraint) but it applies at the event
immediately following the event attached to the begin mark. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
system constraint can be more complicated condition than a simple
event. The example requirement in Figure 4, for instance, uses the
condition idle in a constraint. Idle is not an event but rather
expresses a condition on the system state, which is defined
separately in terms of, e.g., values of variables at the state. Idle
is a fairly general condition that includes both execution sequences
where the user has never gone offhook and those in which the user has
gone onhook since the last offhook. In general, a timeline must
contain at least one required or fail event. Normally, the final
event on the timeline will be a required or fail event. A timeline
need not contain </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">constraints.
</SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
test automaton produced from the timeline specification is a kind of
automaton called a Büchi automaton, as will be explained shortly.
State s1 is called an accepting state, indicated by the double
circle. If we find an execution where the test automaton can remain
in such an accepting state indefinitely, that execution constitutes a
violation of our timeline requirement, and the model checker will
report it as an error. So, another occurrence of, p2 &amp;&amp; p4 &amp;&amp;
p5, must be observed to avoid an error report from the model checker.
</SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
interpretation of accepting states is what differentiates a Büchi
automaton from a standard finite automaton. A Büchi automaton is
used to trap infinite execution sequences that violate a requirement,
whereas a standard automaton can only trap finite execution
sequences. The Spin model checker uses the Never Claim version of the
automata, also produced by the TimeLine Editor . In general, each
required event will have an associated accepting state where we wait
for that event to occur. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Each
fail event will have an associated accepting state that we transition
to if the fail event occurs in the specified interval. The transition
to the fail state is made from the wait state associated with the
regular or required event directly following the fail event.  The
fail state has a self loop labeled true because once in the fail
state, we remain there for the remainder of the execution. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Timelines
are restricted to have at most one consecutive fail event. To express
that more than one event <B> </B>can cause a transition to the fail
state while waiting for the next regular or required event, the names
of the fail events may be joined via a logical or ( || ) on a single
fail event label. Constraints must be contiguous between non-fail
events. Test automata generated from timeline specifications
constitute a limited fragment of the properties expressible in Linear
Temporal Logic. In particular, timelines without fail events
correspond to certain <B>liveness</B> properties.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent"><B>The
formal definition of liveness [8],[10] requires that any finite
system execution must be extendable into an infinite execution that
satisfies the given requirement (i.e., that does not produce a
violation). </B>When fail events are present, we can express more
than just liveness properties. For example we can express the simple
safely property that a particular (fail) event should never occur. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Timeline
editor is no longer distributed or maintained. :-( </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
pseudocode that follows provides a description of the translation of
a timeline to a Büchi automata. ← use it!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
logic of bugs</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
the telecommunications industry a rather rigorous software
development process was adopted in the seventies and eighties. The
development starts with requirements capture and documentation by
system engineers. That phase is followed by high-level and low-level
design (i.e., programming), followed by various stages of testing,
and  finally customer acceptance. The final phase of the process is
maintenance. In each phase errors can be introduced into the process
and in each phase errors can be intercepted. The common wisdom is
that the earlier a bug is intercepted, the less expensive it will be
to fix it. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
the requirements phase, inconsistencies can be caught with basic
requirements analysis techniques, in the high level design phases
errors are caught by prototyping, simulation, and modeling, in the
low level design phase peer review sessions and targeted unit testing
techniques can be used. In the final testing phase this consists of
integration and customer acceptance testing. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">All
these techniques do in fact combine to intercept the majority of all
errors that are introduced. But these techniques do not bring the
residual error rate down to zero. In all likelihood, not even the
most diligent application of these traditional techniques could even
bring the residual error rate down to zero. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
situation is more interesting still for concurrent, and
non-deterministically executing software. Almost all modern software
falls into this category. This is an ideal place where bugs can
currently hide safely, immune to most of the currently used testing
strategies. This time not just the input data can influence the
computations but also the relative ordering of events that may occur
in different parts of the system is important. The unpredictable ways
in which multiple users can interact with the different parts of a
physically distributed system become a factor, and similarly the
unpredictable way in which schedulers run asynchronous threads of
execution. Two issues complicate our ability to test or debug such
systems: limited observability and limited controllability. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
fundamental non-determinism that is exhibited by distributed systems
makes it virtually impossible to test them thoroughly by traditional
means. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
second, more basic, problem is that the method we sketched above only
helps us to find bugs in high-level system designs, and we may be
more ambitious than that. We may, for instance, also want to use
these methods to find typical bugs in implementation level code: the
purview of classic software testing techniques. We know that in some
cases it is possible to extract verification models from
implementation level code mechanically. Techniques to do so were
developed for Java [3] and for C [6] and [2]. By using a combination
of automated abstraction, model extraction, and logic model checking
we may be able to increase the scope of applications sufficiently to
make this approach to software verification more routine. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
now come to the third and most underestimated problem in applications
of automated tools to software verification: the problem of
accurately capturing the correctness requirements that have to be
verified. <B>Verifiers, and logic model checkers in particular, excel
in their ability to show that specific requirements are either
satisfied or may be violated. It is up to the user to come up with a
comprehensive list of requirements to be checked, and to make sure
that the requirements that are checked make sense. That is a more
difficult task than many realize, as we will try to illustrate below.
</B></SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
standard method to express the correctness requirements for a model
checking application is to use the formalism of temporal logic, as
first proposed for this purpose by Amir Pnueli in [11]. In Linear
Temporal Logic (LTL for short), as used in Spin [5], a small number
of special operators are introduced to allow one to reason about
sequences of events that are claimed to be causally related. We
quickly notice that it is easier to reason about the type of error
scenario that we want to prove to be infeasible, rather than the
property itself. So let us switch to an LTL formula that captures the
error behavior we are interested in. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">We
have made a very common mistake here in confusing logical implication
with causal implication. The arrow operator is not a temporal
operator. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">It
should be noted that even though coming up with an accurate
formulation of this seemingly very simple error-condition is hard, it
is still harder to come up with an accurate version of the positive
system requirement that we started with (i.e., the logical negation
of the last LTL property). </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
automaton structure shown in Figure 2 looks more intuitive than its
equivalent in LTL, but this too can be misleading. It can be
difficult as well to specify complex requirements accurate when
directly coding an Z- automaton structure. In the first few
distributed versions of the Spin model checker this was the primary
means for specifying temporal properties. The addition of support for
LTL syntax in Spin version 2.7 was seen by many users as a notable
improvement. So if automata structures are not an adequate formalism,
and temporal logic is not quite adequate, what alternatives remain? ←
REALLY RELEVANT!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">One
proposal has been to prepare a library of predefined LTL formulae
from which a user can choose, based on short template descriptions of
each basic type of property [4]. This approach is often effective,
but it cannot avoid cases where incomplete intuition leads to the
selection of either an incorrect or an incomplete pattern. We have
pursued an alternative approach, based on the development of an
intuitive graphical editor for the specification of basic temporal
properties [12]. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
types of requirements that can be specified in this way are more
limited than the full use of LTL allows, but this appears not to be a
significant restriction. (There may actually be some benefit in
avoiding the full complexity of LTL.) The correct version of the
dialtone property, for instance, is specified with the TimeLine
editor as illustrated in Figure 3. Of course, also the intuition that
is supported by timeline specifications cannot prevent occasional
mistakes. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
three events of interest in the dialtone property, for instance, can
be assigned in several different ways to constraints underneath the
timeline, or to optional, required, or failure events within the
timeline. Unlike the various forms of LTL formulae, though, each such
variant of a timeline is visually no more complex than any other. The
hope is that this visual simplicity allows the user to co</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">centrate
on the meaning of a property, rather than on the subtleties of its
formalization. To support that intuition, the user can inspect the
precise structure of the Z- automaton that corresponds to the
timeline as specified. The timeline shown in Figure 3 precisely
corresponds to the Z-automaton from Figure 2. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Many
of these mistakes can effectively be intercepted with the help of
traditionally used tools, ranging from compilers to static analyzers
and runtime checkers. We know of only one effective method that can
be used to intercept concurrency related errors though: logic model
checking. But also in applications of logic model checking errors can
creep in. For instance, when the formal models are manually
constructed, bugs can enter the models and hide requirement
violations from view. We can mitigate the effect of this by using
techniques for automated model extraction, e.g., as in [3], [6], and
[2]. With a software verification process based on model extraction
and logic model checking techniques, the one final place where bugs
can comfortably hide is in the property definitions. The formulation
of the requirements for a software artifact is a fundamentally human
task, and as such unavoidably subject to human error. The commonly
used formalism of Linear Temporal Logic can challenge the (human)
verifier’s intuition, which can seriously jeopardize the validity
of verification efforts. As a counter-measure, we have discussed the
use of a simple visual formalism that can support our intuition more
effectively. The lesson learned from these tools is that it can
sometimes be wise to trade generality for confidence. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">CHARMY:
A Framework for Designing and Verifying Architectural Specifications</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
notation used for modeling the software architecture is based on UML;
even if UML is not the most suitable notation for modeling software
architectures, it is widely adopted in industries. However, the
CHARMY notation has a formal semantics, and thus it forces the
software architect to resolve ambiguities that could be present in a
standard UML-based software architecture specification. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
model checker used by CHARMY is SPIN. Therefore, the software
architecture, modeled in terms of CHARMY diagrams, is automatically
translated in Promela that is the specification language of SPIN.
These properties are typically specified as linear-time formulas in
suitable temporal logics. In general, it is a difficult task to
accurately and correctly express properties in these logics. For this
reason, CHARMY temporal properties are specified as Properties
Sequence Charts (PSCs) [4]. PSC is a scenario-based visual language
for describing temporal properties.  </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
tool has a plugin-based architecture, which allows an easy and rapid
integration of new modeling and analysis techniques. A CHARMY
specification of an SA is given in terms of components, connectors,
their internal behavior, and relations among them. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">State
diagrams are described using the State Transition Diagram notation
(close to the Promela syntax) Labels on arcs are structured as
follows: ‘[‘guard’]’ event ‘(‘parameter’)“/’ ‘op1
’ ‘op2 ’ Á Á Á ‘opn ’, where guard is a Boolean
condition that allows the transition activation, i.e., two state
diagrams are synchronized only if the guard condition becomes true.
The elements that can be written into the guard are variables local
to the state diagram. An event can be a message sent or received
(denoted by an exclamation mark “!” or a question mark “?”,
respectively), or an internal operation (#) (i.e., an event that does
not require synchronization among state diagrams). An event </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">can
have a parameter that is the value that will be exchanged between a
pair of components when the transition fires. op1 ; op2 ; . . . ; opn
are the operations to be executed when the transition fires. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">the
parallel operator is the interleaving among the messages contained
into the parallel operands; <B>← not real concurrency </B></SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">State
diagrams do not contain synchronization information among components;
and thus if a message is not contained in any sequence diagram, the
specification is incomplete. Complex communication, i.e., <B>multicast</B>
communication, is modeled by means of connectors that can only send
and receive synchronous messages. ← multicast with UML?</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent"><B>Active</B>
is a Promela statement for proctypes that are initial processes,
i.e., processes that do not need instantiation. A state description
is composed of several parts. It contains a description of the set of
transitions, which defines what happens when a transition from that
state fires. Each transition in the state diagram is translated into
a goto Promela statement to reach the target state of the transition.
</SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Listing
4 that nondeterministically chooses one of the two possible
interleaved behaviors: the dispatching of m2 followed by the
dispatching of m3 or vice versa. ← ach, you must interleave them by
hand (all variations/permuatations)</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Analogously,
the alternative operator allows the definition of alternative
behaviors, and then it is encoded by means of the Promela operator
for nondeterminism. ← how about if the alternative depends on a
local component variable? How is the choice made? Otherwise it's an
overapproximation</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">PSCs
are an extension of a subset of the UML 2.0 Sequence Diagrams
stereotyped so that: each rectangular box represents an architectural
component, each arrow defines a message exchanged among two
components. In order to clearly distinguish between mandatory,
forbidden, and provisional messages, PSC provides three different
types of messages to specify that a message can be mandatory,
forbidden, or provisional ← why not use assert/negate</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Unwanted
message constraints are graphically represented as filled circles
(see Fig. 9). Wanted and unwanted chain constraints are graphically
represented as arrows and crossed arrows, respectively (see Fig. 9).
←how about wanted message constraints? Is this in term of message
exchanges only?</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Informally,
the parallel operator allows a parallel merge of the message sequence
within its operands. The messages posing as arguments of the operands
can be interleaved in any way as long as the ordering imposed by each
operand as such is preserved. ← again, what about true concurrency?
Where is that expressed? You need the notion of OS processes. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
plugin architecture of CHARMY promotes an easy integration of new
features. For instance, in case, we are interested in changing the
model checker engine, and thus we are interested in substituting SPIN
we have only to write a new plugin that, starting from the CHARMY
notation, generates the input (e.g., written in BIR if the selected
model checker is Bogor [33]) of the new model checker. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Fig
10. The two sequence diagrams differ in one message only, they can be
one diagram with [alt]</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
circle labeled b identifies a constraint of the message. It means
that the message withdraw that has associated the constraint is a
valid precondition iff before this message and after the previous one
(i.e., login), T M does not send noconnection to BA .</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">However,
one aspect that should be always considered in modeling systems is
that the right abstraction level is the one that allows us to verify
the properties of interest, i.e., additional details are not useful
and can make the system intractable. Consequently, every nonuseful
detail should be cut off or abstracted. However, CHARMY gives to the
designer instruments for designing very detailed systems, as
sometimes required by the system under analysis, such as internal
transitions, variables, guards, etc. ← right, where are those
variables? And how is data represented?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
usual techniques consist of slicing and abstracting the system, in
limiting (to the minimum necessary for analysis purposes) the number
of instances of a certain component/connector and in </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">making
use of compositional reasoning approaches that aim to reduce the
verification of a system to the verification of a set of small
subsystems. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
slicing and abstraction approach has been proposed in [13]. This
approach exploits the characteristic of the SA model and the
structure of the property of interest and tries to reduce the model
complexity without compromising the verification validity of the
considered property. In the approach that we proposed, the slicing
criterion was the property we want to check on the SA. Due to the
architectural slicing, we are able to extract the parts of the system
that play a role on the behavior implied by the property of
interested. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Even
though UML is widely used and supported by professional tools, its
principal drawback is the absolute lack of formality. The result is
that each designer assumes his own semantics and accordingly designs
the system. However, the CHARMY notation has a formal semantics and
forces the software architect to resolve ambiguities that could be
present in a standard UML-based software architecture specification.
The choice we made in CHARMY is to use diagrams most commonly used by
industries. Since the different diagrams are different views of the
same system, we ensure consistency among these diagrams and we
extract a complete system description from components, state, and
sequence diagrams. ← you get this for free with most UML tools</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Typically,
other approaches that generate a formal description starting from
UML, even if not at the architectural level, consider only one type
of diagram. The solution proposed by CHARMY allows the software
architect to represent each aspect in a natural way, using for each
aspect the most appropriate diagram (e.g., sequence diagrams are the
most used and more appropriate diagrams to explicitly represent
communication among subparts that compose the system). ← well, not
us!</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">CHARMY
aims to bring the gap between formal methods and its applicability in
real contexts by means of notations close to what really used in
industrial contexts. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">We
are currently investigating how to exploit the behavioral information
present in a CHARMY specification for generating the Java code. The
idea is to generate an encoding of the CHARMY state diagrams in order
to force the system implementation to behave accordingly to the state
diagram models . ← state machines for DIRAC</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Formal
Model Driven Engineering for Space Onboard Software </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">From
September 2004 to December 2007, the European Space Agency (ESA) led
the ASSERT project [1] of the FP6, with the objective of defining a
complete system/software engineering process for complex and critical
space systems. The ASSERT development process is now supported by a
set of tools called TASTE [4]. The main scope of the ASSERT project
was the management of non functional requirements, from the capture
of system requirements to the automatic generation of code.
Formalisation of each step of the development by safe and
non-ambiguous languages. &nbsp;The following languages have been
selected: SysML for the system design. SysML is a graphical modelling
language adapted to system engineering and increasingly used in the
industry; SCADE Suite for the software design. SCADE is a graphical
modelling language mixing automata and data flow views; Ada for the
coding. Ada is a programming language targeting the development of
critical real time software.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
SysML standard is not always precise enough and leaves an important
part of its semantics undefined. The FMDE project has thus adapted
the OMEGA profile (previously available for UML) to the SysML
language in order to suppress any ambiguity in the system models and
to allow formal proof. This requires the addition of new modelling
constructs and the definition of a set of rules to clarify some
semantics variation points of SysML (e.g. forbidding of bidirectional
ports, typing of connectors, port behaviours).</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">SPARK
is specifically designed to support the development of software for
systems where the correct operation of the software is essential for
the safety or security of the system. The language is based on a core
subset of Ada and augmented with annotations which describe and</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">support
the programming-by-contract approach. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Automatic
generation of a skeleton of the software model in SCADE Suite from
the system model in SysML. This objective has been achieved by
integrating SCADE Suite and the Papyrus SysML modeller through the
new SCADE System Designer tool. Having two interconnected meta-models
allows consistency to be kept between the system model and the
software model. ← for ppt?</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Automatic
generation of SPARK code from the software model in SCADE Suite by a
tool certifiable to DO178B level A. The static semantics of the
profile is defined by well-formedness rules formalised in OCL. These
rules concern the strong typing principles and the restrictions
relative to the structure of IBDs mentioned in the previous section.
Further details on the formalisation and the rationale can be found
in [7]. One of the first benefits of using the OMEGA profile is the
tool support helping system engineers obtain statically valid and
well-defined models. For the operational semantics, OMEGA relies on
an asynchronous timed execution model. Each basic block with
behaviour is considered as a timed automaton, potentially executing
in parallel with other blocks and communicating via asynchronous
signals or asynchronous operation calls. In order to offer a
mechanism for controlling the granularity of concurrency, the
semantics takes into account the isActive attribute that SysML blocks
inherit from UML classes. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
toolset handles SysML models in XMI 2.1, edited by an editor
compliant with Eclipse EMF such as IBM Rhapsody or Papyrus MDT. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">This
section is about bridging the last two steps of the process: software
design and coding. These steps are coupled through automatic code
generation from a formal (synchronous) model, which allows generating
a fully certifiable code from the software design. This method and
technologies have been used for more than 10 years now and are now
fully </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">accepted
by certification authorities as a safe way to develop code. The added
value of the </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">work
done in FMDE is to generate SPARK / ADA code (instead of C code) that
is amenable to formal proof. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
SPARK Pro Toolset can verify the correctness of programs by using
rigorous mathematical analysis. All types of analysis supported by
the tools — from data flow and information flow analysis, through
proof of absence of run-time exceptions, to formal verification of
correct functionality of the program against a specification — are
fast: they are performed in polynomial time (there is a trade-off
between speed and completeness: the analysis is fast but not every
correct program can be proven).</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
its simplest form, SPARK proof demonstrates the absence of run-time
errors: it shows before the execution of a program that there will be
no errors such as division by zero, buffer overflow or out-of-range
assignments to variables during the execution. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
most complete and exhaustive form of proof is the proof of functional
correctness of a program against a detailed formal specification. ←
for ppt?</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Integrated
Model Checking of Static Structure and Dynamic Behavior using
Temporal Description Logics (2011)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
static structure as described by UML class diagrams is represented
formally by description logics while the dynamic behavior is
represented by linear temporal logic and state transition systems. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">We
integrate these descriptions of static and dynamic aspects into a
single formalism called LTLDL .</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">LTLDL
enables a concise and natural yet precise definition of the behavior
of software w.r.t. UML class diagrams and state transition diagrams.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Further,
we describe how properties of finite LTLDL models can be analyzed
based on bounded model checking and SMT (satisfiability modulo
theory) solving. We implemented a restricted SMT solver for finite
sets and relations. This SMT solver helped to reduce the model
checking runtime significantly as compared to bounded model checking
with existing tools. ← SMT solvers could be the future, pay
attention!</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Description
logics are expressive for representing the static structure of some
application domain. Their expressiveness is closely related to UML
class diagrams [BCG05]. Temporal logics are well-suited to describe
the behavior of processes in a formal yet abstract way. We propose to
combine these formalisms in a family of temporal description logics
called LTLDL , to be able to address both the static and dynamic
aspects of modeled systems. This goes beyond existing approaches such
as Alloy [Jac02] or Spin [Hol04] which focus either on the static
structure or on the dynamic behavior of the modeled system. The state
machine example they show is not even syntactically correct probably!
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">We
aim at representing properties w.r.t. both the static model and the
behavior model of some application domain.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
the case of our sample scenario, the following properties may be
important to meet:P1 Whenever a customer places an order, the
customer will receive some response which may either be the delivery
of the order or a notification that the order is pending because of
insufficient stock; P2 Orders may not be pending forever, i.e.,
orders delayed due to insufficient stock will be delivered
eventually; P3 If orders are pending then repeatedly incoming stock
will eventually cause an order to be delivered; </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">We
propose LTLDL for the formal representation of such criteria. LTLDL
is a modular composition of linear temporal logic LTL [Eme90] and
description logic (DL); </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">This
allows for the representation of properties that address both the
static structure and dynamic behavior since the semantics of UML
class diagrams can be represented well by DL, and properties of state
transition diagrams can be expressed by LTL.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">LTLDL
extends LTL by allowing DL formulae in addition to atomic
propositions at locations where only atomic propositions are </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">allowed
in LTL.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Hence
both LTL and DL are contained in LTLDL. The following are ALC
formulae </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">expressing
properties related to the class diagram of Figure 1: a1 : Delivered
Pending Order (Every delivered or pending thing is an order) etc..</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">However,
the following LTLALC formulae are neither in LTL nor in ALC: la0 :
F(PendingList ¬∃lists.Pending) (The list of pending orders will
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">eventually</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">be
empty) </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">LTLDL
formulae are interpreted w.r.t. finite </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">relational</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">state
transition systems M = (S, R, L, ∆, I)</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
denote I(s0 ) |= d iff some DL formula d holds at a state s0 ∈ S
according to the semantics of DL connectives and the interpretation
I(s0 ) of atomic concepts and roles.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Let
M = (S, R, L, ∆, I) be a finite relational state transition system
and f be a LTLDL formula. Let D = {d1 , ..., dn }, n ∈ N, be the
set of DL formulae in f ….Let </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">f’
=</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">f
[d1 /a1 ][d2 /a2 ]...[dn /an ] </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">be
the formula derived from f by substituting all description logics
formula in f with atomic propositions.... By theorem 1, a model
checking algorithm for LTLDL can be constructed by composing a LTL
model checker and DL model checker as follows: First, using the DL
model checker to calculate the labeling function L in Theorem 1, and
then check for M , x |= f using the LTL model checker. This forward
approach, however, is not efficient in the case of systems with many
states. Hence, we strive for a tighter interaction between the LTL
and DL model checker to avoid calculating the entire reduced model M
. There are two obvious approaches to achieve this: “on-the-fly
model checking” [Hol04] and “bounded model checking” [BCC+ 03].
In this work, we adopted the latter approach because its modular
structure simplified the implementation of a LTLDL model checker
based on existing tools for bounded model checking and SMT solving.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">As
illustrated by Example 3, we transform LTLDL models and formulae into
formulae that contain set-type variables and operations corresponding
to the semantics of DL connectives. These formulae can be interpreted
as SMT formulae with sets and relations as background theory. We
define the language SMT(DL) for the representation for such formulae.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">We
implemented a partial solver for SMT(DL) based on OpenSMT [Bru09]
which is an open source SMT solver implemented in C++.
State-of-the-art model checkers supporting linear temporal logic are
Spin [Hol04], SAL [MOR+ 04], and NuSMV [CCG+ 02].</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">However,
the input languages of these model checkers do not support set and
relation data types and hence are inefficient for representing
properties w.r.t. relational models. (for instance, how do you
represent: eventually/always something is a subset of something else)</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><SPAN STYLE="background: transparent">← <FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">i
have no idea which steps are automated in this work (if any!). How do
you go from UML to these formulas? How is the model expressed? Plus I
think mu-calculus has the same power of expressivity as this combo of
LTL and DL.</SPAN></SPAN></FONT></FONT></SPAN></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Model
checking driven static analysis for the real world: designing and
tuning large scale bug detection (2013)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Working
on the intersection of software model checking and automated static
bug detection for real-life systems, we address a number of issues:
how to scale for real-life systems of 1,000,000 LoC or more, how to
quickly write new checks, and most importantly how to distinguish
between relevant and irrelevant bugs and fine tune the analysis
accordingly. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
advantage of traditional testing is that functional behavior of the
software can be examined for the real implementation on the real
hardware. This stands in contrast to, e.g., purely model-based
approaches. The disadvantage is that testing explores typically only
a limited number of program behaviors. Even if all program paths are
explored, only a limited set of inputs can be examined, and
</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">significant
manual effort is required to find the appropriate test cases. One of
the most </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">significant
disadvantages is that testing does not scale well to large code
bases. There are typically an overwhelming number of test cases to
consider to achieve a satisfactory coverage. ← for ppt?</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
contrast to traditional testing, static program analysis does not
execute the implementation, but analyzes the source code for known
dangerous programming constructs, for combinations of those and their
causal relationships, and the impact of potentially tainted input.
Typical examples in C/C++ are null pointer dereferences, accessing
freed memory, memory leaks, or creating exploits through buffer
overruns. These types of bugs are only found to the extent in that
they affect the functional behavior, and since traditional testing is
focused on checking the functional behavior of the system, finding
these types of bugs is more often a welcome side effect, rather than
intentional. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Static
program analysis cannot always be precise, since it does not execute
the real code, but examines syntactic relations within the source
code. This means, over-approximations are used to estimate the actual
program behavior. This almost inevitably leads to false alarms, i.e.,
warnings which are spurious and do not correlate to any actual
execution. In addition to these false alarms, there are warnings that
pinpoint code where the programmer bends the rules of the C/C++
standard, often to achieve efficiency. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
recent years those techniques have become popular not only for
compiler optimization, but also to find certain patterns in programs
that indicate bugs or, more generally, software deficiencies. In most
circumstances, a static analysis tool is only regarded as useful if
the analysis time is roughly in the same order of magnitude as the
compilation process and not several orders of magnitude higher. While
may-analysis (overapproximation) can turn up significantly more
reported bugs, the bugs may not exist in the actual program behavior
due to infeasible paths or infeasible data dependencies. In this
context, these warnings are called false positives or false alarms).
Must-analysis (underapproximation), however, might miss bugs due to
the nature of under-approximation. We call these false negatives.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
basic idea of our approach is to map a C/C++ program to its
corresponding control flow graph (CFG), and to label the CFG with
occurrences of syntactic constructs of interest. The CFG together
with the labels can easily be mapped to the input language of a model
checker or directly translated into a Kripke structure for model
checking.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">For
p in Fig. 1a, we automatically label the nodes with labels malloc p ,
used p and f r ee p , as shown in Fig. 1b. These labels are computed
based on a library of predefined patterns. In a next step, given this
annotated CFG, checking whether p is used after it is freed then
amounts to checking the property in computation tree logic (CTL). CTL
uses the path quantifiers A and E, and the temporal operators G, F,
X, and U. The (state) formula Aφ means that φ has to hold on all
paths, while Eφ means that φ has to hold on some path. In CTL a
temporal operator is always immediately preceded by a path
quantifier. We implemented the aforementioned framework in our tool
Goanna. The core of the tool is implemented in OCaml, but it makes
used of a third-party C/C++ parser as its front end (roughly 500k LoC
of C code) and has a variant that uses the open source model checker
NuSMV [13] as its generic analysis engine. Goanna handles full C/C++
including compiler-dependent switches for the GNU gcc and Microsoft
Visual C/C++. Moreover, it comes in variants for the integration in
either Eclipse or Microsoft Visual Studio. Under the hood, the main
components are the model checking-based static analysis engine, the
abstract interpretation framework, and the false path elimination
engine. Even for very large projects with millions of lines of code,
the analysis typically runs in the order of compilation time.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">From
the perspective of testing, it matters if a deficiency occurs always
or under certain circumstances only. Bugs that occur predictably in
every run are easy to find. The only penalty for finding them through
testing is that valuable resources have to be spent. In contrast,
deficiencies that are data or configuration dependent are much harder
to find, since it requires a developer to find specific test cases
that expose the bug. Since exhaustive testing is often prohibitive,
these kinds of bugs can go undetected for a long time before they
manifest themselves. &nbsp;← for ppt</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Currently,
our reported defect density is around 3.2 warnings per 1,000 LoC for
the Firefox code base. The best state-of-the art checkers provide a
defect density of around 0.35 for Firefox.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
see two promising areas of research based on our preliminary
findings. Firstly, in the recent years there has been a strong push
with much success to improve SMT solvers both in capabilities as well
as performance, to make them a real alternative for practical program
verification. The advantage of SMT solvers are their rich
domain-specific data structure support and solving capabilities that
enables program analysis on a much more precise level of abstraction.
We envisage the use of SMT solvers, e.g., as a means to improve our
false path elimination approach by moving from intervals as the
underlying abstraction to a more precise model.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">We
believe that our approach of combining model-checking and static
analysis in a close</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">manner
we might be able to make significant improvements, because the very
nature of model checkers is to analyze inherently concurrent systems.
← for ppt (...but ironically most of the model checkers are
sequential)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Automated
formal analysis and verification: an overview (2013)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
most space is devoted to the approach of model checking, including
its basic principles as well as the different techniques that have
been proposed for dealing with the state space explosion problem in
model checking. This paper, however, includes a brief discussion of
theorem proving and static analysis too. All of the discussed
approaches are introduced mostly on an informal level, with an
attempt to provide the reader with their basic ideas and references
to works where more details can be found.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Despite
that these techniques have been in use for a long time, research and
development devoted to their further improvements is still quite
active, producing new methods and methodologies such as search-based
testing, model-based design, agile testing, or extreme programming.
However, these – let us say ‘traditional’ – methods suffer
one important deficiency: they cannot prove a system correct, i.e.
they cannot prove it to be free of errors with respect to some
specification. That is why one can also witness a strong and ever
rising interest in the development and applications of formal
verification methods that can remove this constraint. Moreover, it
turns out that even in cases in which the formal verification process
is not completely finished due to its high cost, or when it is
intentionally restricted in some way (e.g. by restricting the depth
of the state space of the verified system to be traversed or by
intentionally suppressing some generated warnings when it is not sure
whether they correspond to real errors or not), it may still be quite
valuable. This is because even in such cases, it may find a number of
errors that are often different from those found by traditional
methods, which is due to the very different principles on which these
methods work ← for ppt! </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">We
use the term formal verification to denote verification methods based
on formal mathematical roots and (at least potentially) capable of
proving error freeness of systems with respect to some correctness
specification. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
potential to detect all errors with respect to a given specification
is called soundness of a method.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">It
means that if such a method terminates and claims a system correct
with respect to a certain specification, the system is indeed
correct. On the other hand, we call a method complete if it does not
raise false alarms, i.e. if it does not report spurious errors. As we
have already indicated above, sometimes, the potential of a method to
be sound is sacrificed in </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">order
to increase the efficiency of the approach, leading to an error
detection approach with formal </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">verification
roots. ← for ppt</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
lot of effort is, for instance, invested into testing of concurrent
software that is very difficult due to many errors manifest only very
rarely when the concurrently running processes or threads are
scheduled in a very specific way. In order to increase chances to
spot such errors, techniques such as injection of noise into the
scheduling of concurrent processes have been proposed and supported
by tools such as IBM ConTest (Edelstein, Farchi, Nir, Ratsaby, &amp;
Ur, 2002) or ANaConDA (Fiedor &amp; Vojnar, 2012). &nbsp;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Theorem
proving – also called as deductive verification – is usually a
semi-automated approach using some inference system for deducing
various theorems about the examined system from the facts known about
the system and from general theorems of various logical theories.
This approach is quite close to classical mathematical reasoning, but
it is supported by computer-aided tools, the so-called theorem
provers (or proof assistants), such as PVS. These tools take care of
remembering all of the so far deduced facts and of correctly applying
inference rules. The inference process is, however, usually guided by
the user. The approach is very general but often very hard to use.
The approach is sometimes also weak in generating counterexamples
(diagnostic information) to correctness specifications in faulty
systems – one may have troubles to distinguish whether the effort
to prove some property is failing because there is an error in the
system being examined, or because the user of the method is not
bright enough to prove it correct. On the other hand, there has also
been a lot of progress in developing automated decision procedures
(or satisfiability solvers) for different logics and logical
theories. These solvers are used as a building block within various
higher level verification methods. Among the solvers, an important
position belongs to the so-called SAT solvers, such as Glucose
(Audemard &amp; Simon, 2009), deciding satisfiability of
propositional formulae, and hence solving the classical Boolean
satisfiability problem, i.e. the SAT problem. Another important
category of the solvers is then the category of the so-called SMT
solvers,2 such as Z3 (de Moura &amp; Bjørner, 2008), which support
various first-order logical theories with equality (such as linear
arithmetic, linear real arithmetic, uninterpreted functions, theory
of arrays, and so on). &nbsp;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Static
analysis is usually characterized as analysis that collects some
information about the behaviour of a system without actually
executing it under its original semantics. In many cases, static
analyses are not designed for checking correctness of programs but to
be used within compiling, optimization, code generation, etc. Static
analyses are often highly specialized. Compared to model checking,
static analyses have often – though not always – the advantage of
not needing any model of the environment in which the system should
run and of being able to handle very big code bases (even tens of
millions of lines of entire operating system kernels, such as Linux
or Windows). The need to model the environment and usually also parts
of the system being examined (which would otherwise be too big to be
handled) may be quite expensive and may also hide some errors, which
may be ruled out by the manual modelling. &nbsp;more exact
description of the use of data flow analysis in leading commercial
tools is, unfortunately, difficult due to their producers keeping all
details of their tools secret. According to the limited information
available, the use of data flow analysis and bug patterns is often
combined, e.g. with further pruning of infeasible paths using various
logical solvers to check satisfiability of the conditions that appear
on the concerned program paths. Furthermore, the tools also exploit
statistical methods to distinguish common and less common coding
styles used in a program in order to better identify suspicious parts
of the code. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Abstract
interpretation (Cousot &amp; Cousot, 1977) is a theory of a sound
approximation of the semantics of computer programs that, among other
applications, allows for constructing static analyses sound by
construction. Abstract interpretation consists in giving a class of
programs a concrete and abstract semantics defined on suitable
concrete and abstract lattice-based domains. These domains are
usually linked by a pair of monotone functions – the so-called
abstraction and concretization, traditionally denoted a and g,
respectively – that form a Galois connection.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Model
checking (Baier &amp; Katoen, 2008; Clarke, Grumberg, &amp; Peled,
1999) is an approach of automated checking whether a system (or a
model of a system) satisfies a certain &nbsp;specification based on a
systematic exploration of the state space of the system. &nbsp;The
system or model to be verified can be described in a variety of
different languages ranging from real-life hardware description
languages (such as VHDL or Verilog), common programming languages
(like C or Java), and various kinds of Petri nets or process algebras
to specialized modelling languages (such as the Promela language of
the Spin model checker (Holzmann, 1997)). The specification is
typically written in some temporal logic such as linear temporal
logic (LTL; Pnueli, 1977), computation tree logic (CTL; Clarke &amp;
Emerson, 1981), CTL* (Emerson &amp; Halpern, 1986), or m-calculus
(Kozen, 1983), but some simpler specification means such as C-like
assertions or end-state and progress labels known from Promela can
also be used. Model checking has originally been proposed for
verification of finite-state systems. Its roots can be traced back to
the works (Clarke &amp; Emerson, 1981; Queille &amp; Sifakis,
1982).12 Model checking can usually be fully automated and can
generate error traces explaining why a certain property does not hold
in a given system. ← for ppt</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">An
even more complicated situation arises when one wants to apply model
checking to infinite-state systems (such as systems with unrestricted
parameters and/or various unbounded data and control structures such
as communication queues, dynamic linked data structures, stacks,
counters, and so on). Clearly, in this case, one cannot simply
enumerate reachable states to verify a given system. Indeed, most
interesting verification problems over infinite-state systems are
undecidable. &nbsp;Yet another problem – which, however, may arise
with some forms of static analysis too – is the need to model the
environment of the system being verified. This modelling task is
usually quite tedious and may hide some errors if the model of the
environment ignores some behaviour that is possible in practice (on
the other hand, if the model of the environment enables some
behaviours that are not possible in reality, many false alarms</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">may
be obtained). Model checkers for concurrent and distributed systems
include, e.g. Spin (Holzmann, 1997) and DiViNe (Barnat, Brim, Ceska,
&amp; Rockai, 2010) using specialized input languages (Promela, DVE)
for describing models of the verified systems. One of the most
successful software model checkers is the Static Driver Verifier
(Ball, Cook, Levin, &amp; Rajamani, 2004) from Microsoft that is
successfully used for verifying selected critical properties of
Windows drivers. Apart from it, there exist many more experimental
academic software model checkers such as the Java PathFinder from
NASA for model checking Java programs on the byte code level (Visser,
Havelund, Brat, Park, &amp; Lerda, 2003); Blast (Henzinger, Jhala,
Majumdar, &amp; Sutre, 2003), CPAChecker (Beyer &amp; Keremoglu,
2011), SatAbs (Clarke, Kroening, Sharygina, &amp; Yorav, 2005),
Wolverine (Kroening &amp; Weissenbacher, 2011) for model checking C
programs using predicate abstraction (briefly discussed in Section
4.3); or bounded model checkers for the C language such as CBMC
(Clarke, Kroening, &amp; Lerda, 2004) or LLBMC (Merz, Falke, &amp;
Sinz, 2012). Finally, to give some representatives of tools for model
checking of real-time and probabilistic systems too, we can mention
Uppaal (Behrmann, David, &amp; Larsen, 2004) and Prism (Kwiatkowska,
Norman, &amp; Parker, 2011).</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
the previous section, we have introduced model checking as an
automated technique that verifies a system (or its model) against a
property specified in some suitable way through a systematic
exploration of the state space of the system (or its model). We have
said that many different languages can be used for specifying the
properties to be verified. We now concentrate on two of these
languages that belong among the most often used, namely the LTL
(Pnueli, 1977) and the CTL (Clarke &amp; Emerson, 1981). ← for
future work</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">LTL
and CTL differ primarily in the underlying notion of time. LTL
considers time to be linear, and it views the behaviour of a system
as a set of linear executions. On the other hand, CTL considers time
to be branching, and it views the behaviour of a system as a tree of
gradually branching executions. Both of the logics, however, work
with logical time only, which allows one to express requirements on
the order in which certain states (events) should occur in the
system, but unlike physical time, it does not allow one to measure
how much time elapses between two states (events). </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Both
LTL and CTL allow one to express various safety as well as liveness
properties. Intuitively, safety properties state that nothing bad
ever happens (and counterexamples to them are finite executions)
whereas liveness properties state that something good eventually
happens (and counterexamples to them are infinite or at least
complete executions, i.e. executions that cannot be extended any
more). Examples of safety properties can be the following: ‘A
deadlock never happens’ or ‘The length of a certain buffer never
exceeds five elements’. Examples of liveness properties can be:
‘The program eventually terminates’ or ‘Each incoming request
is eventually handled by a server’. ← for meeting!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
order to verify liveness properties, one usually has to provide some
fairness assumptions limiting the non-determinism in the system to be
verified in order to avoid artificial counterexamples that never
happen in practice. This especially concerns the scheduling of
concurrently running processes for which one typically wants to
state, without having to precisely describe the scheduler used, that
a process that is ready to run will not wait for ever. Formulae of
LTL (Pnueli, 1977) are built from atomic propositions allowing one to
refer to relevant aspects of the particular states of the system
being verified,14 Boolean constants and connectives (coming from and
used in the same way as in propositional logic), and, most
importantly, temporal operators that allow one to express logical
timing requirements. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">We
can now formalize the semantics of LTL formulae. Let M be a Kripke
structure...</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">One
of the most common approaches to LTL model checking is the
automata-theoretic approach (Vardi, 2007; Vardi &amp; Wolper, 1986)
whose basic idea we will now describe. Assume that we are given a
Kripke structure M describing the state space of the system to be
verified and an LTL formula w describing a correctness requirement on
the system. We need to check whether any execution path p starting
from any initial state of M satisfies w.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">To
check this using the automata-theoretic framework, one can use Buchi
automata and/or various other finite automata accepting infinite
words as follows.17</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">First,
one constructs a non-deterministic Buchi automaton A:w that accepts
infinite kwords corresponding exactly to those execution paths that
do not satisfy w. Second, the Kripke structure is converted to a
non-deterministic Buchi automaton AM accepting infinite words
corresponding exactly to all the execution paths of M. Third, the
product automaton AM ^ A:w , which accepts the intersection of the
languages of AM and A:w, is constructed. Finally, emptiness of the
language of AM ^ A:w is checked. If the language of the product
automaton is empty, the system modelled by M satisfies w. Otherwise,
the language of the product automaton consists of words corresponding
exactly to those executions of M that break the specification w. ←
monitoring process</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
translation from a Kripke structure to a non-deterministic Buchi
automaton is easy. Essentially, </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">the
Kripke structure M is converted to a non-deterministic Buchi
automaton AM by using 2AP as the alphabet, adding a new initial state
with outgoing transitions leading to all initial states of M, moving
the labelling of the states of M to their incoming transitions, and
making all states accepting. On the other hand, the construction of
the non-deterministic Buchi automaton A:w is far beyond the scope of
this article. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">We
just note that its size may be exponential in the size of the
formula: indeed, LTL model checking is linear in the size of M but
PSPACE-complete in the size of w. However, various heuristics for
keeping the size of A:w as small as possible have been proposed and
implemented in freely available translators from LTL to Buchi
automata, such as the LTL2BA tool implementing the translation
proposed in Gastin and Oddoux (2001). ← for future work </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Note
also that the non-deterministic Buchi automaton is constructed for
the negation of w. A construction of the automaton for w, followed by
complementing the automaton, is possible, but it is typically avoided
since complementation of non-deterministic Buchi automata is quite
complicated and costly. ← for meeting: complementing the formula is
easier than complementing the automaton itself Finally, let us note
that despite LTL model checking is linear in the size of the Kripke
structure and exponential in the size of the formula being checked,
it is usually the size of the Kripke structure that is problematic.
This comes from that the formulae of interest are often very small,
but the Kripke structures tend to be very large. Indeed, they
represent the state space of the system being verified, which is
often exponentially larger than the system itself. To cope with this
situation, various heuristics are used. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">First
of all, one can use the so-called on-the-fly model checking
(Holzmann, 1996) in which the Kripke structure is not generated first
and only then explored. Instead, the property Buchi automaton is
composed with the Kripke structure during the generation of the
latter. This has two advantages. First, one can stop the state space
generation as soon as an error is found, possibly avoiding generation
of many further states (which can be quite useful since erroneous
systems tend to have more states because they do not observe various
invariants they should otherwise observe). Moreover, one can avoid
generation of parts of the state space for which it is clear that
they do not compose with the property automaton (and hence cannot
lead to any error). The state space generation is thus property
driven. ← for future work</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Formulae
of CTL (Clarke &amp; Emerson, 1981) are built from atomic
propositions, Boolean constants and connectives, temporal operators,
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">and
universal and existential path quantifiers A and E. Compared to LTL,
the path quantifiers are added, which is consistent</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">with
CTL being a branching time logic. The use of the path quantifiers is,
however, restricted in CTL in that the temporal operators and path
quantifiers must regularly interleave, leading to 10
non-propositional connectives: AX, EX, AF, EF, AG, EG, AU, EU, AR,
and ER.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
satisfaction relation of CTL formulae is defined for each state of a
Kripke structure, taking into account all execution paths that
originate from that state. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">As
in the case of LTL, the above-introduced set of connectives is not
minimal. In particular, to preserve the expressive power of CTL, it
is enough to use atomic propositions, negation, disjunction, and the
following three non-propositional connectives: EX, EG, and EU. The
meaning of the other non-propositional connectives can be obtained...</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">For
a given Kripke structure M and a CTL formula F, we can now define the
so-called satisfaction set SatðFÞ 1⁄4 {s [ Sj s o F}, i.e. the
set of all the states of M that satisfy F. ← it is state-based</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Let
M 1⁄4 ðS; S0 ; R; LÞ be a Kripke structure over a non-empty
finite set of atomic propositions AP, and let F be a CTL formula over
AP. The basic algorithm of CTL model checking (i.e. checking whether
M o F holds) is rather straightforward. It consists in computing the
satisfaction sets for all sub-formulae of F, followed by checking
that the set S0 of initial states of M is included in Sat (F).</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Although
many relevant properties of systems to be verified can be specified
both in LTL</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">and
CTL, the expressive power of these logics is, in fact, incomparable.
Some properties</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">expressible
in LTL (e.g. FG p) cannot be expressed in CTL while some properties
expressible in CTL (e.g. AG EF p) cannot be expressed in LTL. The
CTL* logic proposed in Emerson and Halpern (1986) combines features
of both LTL and CTL and is more expressive than any of them. The
syntax of CTL* is easy to obtain from that of CTL by lifting the
restriction on the regular interleaving of path quantifiers and
temporal connectives. A commonly used temporal logic that is even
more expressive than CTL* is then the modal m-calculus (Kozen, 1983),
which is based on allowing one to explicitly use least/greatest
fixpoint operators on sets of states (thus essentially allowing one
to define new specialized modalities) ← for future work, also
meeting!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
state explosion stems from a huge number of possible interleavings of
concurrently running processes (a system with n processes, each
having k states, may have up to k n reachable states) and/or from a
huge number of possible data values that may be handled by the system
to be verified (indeed, a single 32-bit-wide integer variable can
have 232 possible values, n of such variables then have 232.n
possible values). The first possible approach to cope with the state
space explosion problem is to store state spaces as compactly as
possible. One way to achieve compactness is to store state spaces in
a hierarchical way.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Another
approach is to use the so-called symbolic verification that, instead
of exploring individual states one by one, works with sets of states
at the same time. These sets must, of course, be encoded in a way
allowing for an efficient manipulation with them. The most famous
symbolic verification method is probably the one based on binary
decision diagrams (Bryant, 1986; Burch, Clarke, McMillan, Dill, &amp;
Hwang, 1992), commonly abbreviated as BDDs. The use of BDDs is behind
many successes of model checking, especially in hardware. When using
BDDs for symbolic model checking, one needs to use BDDs not only to
represent sets of reachable states but also the transition relation
of the system being examined. Moreover, one needs to be able to
compute satisfaction sets of temporal formulae purely on the level of
BDDs (and hence, equivalently, propositional formulae).</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">For
that, fixpoint characterizations of temporal operators, such as those
used in Section 3.4, are useful since they can be easily written as
(quantified) propositional formulae. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Sometimes,
the compact representation of state spaces may disregard some
information in which case soundness of model checking is deliberately
sacrificed in order to achieve efficiency. This way, an error
detection method with formal verification roots is obtained. An
example of such an approach is the bit-state hashing method ← error
detection method with formal verification roots</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
goal of state space reduction techniques is to avoid generation and
exploration of states for which it is clear that their properties are
not important with respect to the specification being checked, or
their properties are covered by the properties of other explored
states. We are by far, of course, not able to describe all the
numerous state space reduction techniques studied in the literature,
and so we will briefly present just three of them that are quite
commonly used. One of the commonly used ways to reduce the generated
and explored portion of the state space of a system being verified is
the on-the-fly model checking (Holzmann, 1996) when the property to
be examined is checked in parallel with the state space generation.
As we have already mentioned in Section 3.2, this approach builds on
the fact that the state space generation can sometimes be driven by
the property being checked. For instance, when using an
automata-theoretic approach to model checking, one can avoid
generation and exploration of certain paths in the state space once
it is clear from their already generated prefixes that they cannot be
accepted by the automaton describing undesirable behaviours. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Another
commonly used state space reduction is the so-called symmetry
reduction. Intuitively, this approach builds on identifying sets of
the so-called symmetrical states that can be made identical by
exchanging the roles of some of their components. Out of the sets of
symmetrical states, it is then enough to explore just one
representative state. One can, e.g. rotate the philosophers in the
well-known dining philosophers problem since it is not really
important whether the first one is eating and the others are
thinking, or the third one is eating and the others are thinking, and
so on (cf. Figure 2). Clearly, similar situations are likely to arise
in many practical scenarios when dealing with replicated components,
objects, processes, and the like. The use of symmetries is especially
important in the context of verification of systems with dynamically
instantiated processes or objects. where the use of fresh identifiers
of processes or objects being regularly destroyed and created may
cause a very significant state explosion. Of course, a problem that
must be addressed when applying symmetries is how to detect
symmetrical states efficiently or, even better, how to transform
states into a canonical form in order not to loose too much time by
testing whether some states are or are not symmetrical (which is to
be performed every time a potentially new state is generated).</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Another
very important state space reduction, particularly successful in
model checking of concurrent systems, is the so-called partial-order
reduction or commutativity-based reduction. This reduction aims at
reducing the amount of interleaving of concurrently enabled actions.
In particular, if some concurrently enabled actions are independent
(i.e. they do not mutually influence the enabledness and the effect
of each other) and, moreover, the order of executing the actions is
not visible through the property being checked (i.e. the order of
executing the actions is not important for the validity of the
property), the actions are fired in one of the possible orders only.
The main practical issue with partial-order reduction is how to
efficiently decide which actions are independent in order for the
overhead of the reduction not to be higher than what it brings.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">When
abstraction is combined with model checking (Clarke, Grumberg, &amp;
Long, 1994), only some selected aspects of states are tracked,
hopefully yielding a smaller abstract state space to be explored. For
instance, instead of remembering that a state in which the variable x
has value 100 and the variable y has value 10 is reachable, they may
remember that a state where</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">x&gt;y
is reachable only. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
further way to cope with the state space explosion problem is to
bound the state space exploration in some way. As in the case of the
above-mentioned bit-state hashing, this usually results in an unsound
technique which can, however, be still very well used as a systematic
testing approach. One natural way how the state space exploration can
be bounded is to restrict the depth of the state space exploration,
leading to the classical notion of bounded model checking (Biere,
Cimatti, Clarke, Strichman, &amp; Zhu, 2003). In this case, the
behaviour of the system is unfolded some given number of steps. An
important observation is that the unfolded behaviour can easily be
captured by a formula that can subsequently be conjoined with another
formula describing undesirable behaviours, and the constantly
increasing power of various SAT or SMT solvers can then be utilized
to check satisfiability of the resulting formula. Yet another
approach is to use more computational power in the form of
distributed computing environments, external storage (instead of
RAM), multiprocessor systems, graphics processing units, and so on.
For examples of such approaches, see, e.g. Barnat...However, dealing
with infinite-state systems is common in practice due to using
various unbounded data and control structures (such as queues,
stacks, counters, dynamic linked data structures, or unrestricted
dynamic creation of processes, objects, and so on) or due to using
parameterized designs. That is why techniques for model checking of
such systems are also highly needed and studied. In their case,
however, one clearly cannot use a systematic enumeration of all
individual reachable</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">states.
One possibility of verifying infinite-state systems via model
checking is to use the so-called cut-offs. Despite the immense amount
of work that has been invested into the development of the different
techniques of formal analysis and verification, </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">there
is still a lot of space for improving their generality, efficiency,
and degree of automation</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">.
← for ppt: my focus is on automation</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Works
going in these directions are constantly appearing and are likely to
appear in the future too since the interest in all forms of automated
verification is currently very high, and it is likely that the
interest will further grow due to the ever increasing impact of
computer systems on human lives.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Expressing
Property Specification Patterns with OCL</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
textual Object Constraint Language (OCL) is an official part of the
Unified Modeling Language (UML). OCL is primarily used to formulate
restrictions over UML modsels, in particular, invariants and
operation pre- and post-conditions in the context of class diagrams.
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">However,
OCL is missing means to specify constraints over the dynamic behavior
of a UML model. We have therefore developed a temporal extension of
OCL that enables modelers to specify behavioral state-oriented
constraints.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">That
work provides an alternative to the rather cryptic temporal logic
formulae that are commonly used to specify behavioral system
properties. OCL is a declarative language, not a programming
language, i.e., evaluation of OCL expressions does not have side
effects on the corresponding UML model. To integrate constraints into
the visual modeling approach of UML, invariants, pre- and
postconditions are modeled as comments and are attached to the
respective graphical model elements in class diagrams. However, OCL
constraints can become quite complex, such that they are often
specified separately. We briefly explain how to read that OCL
invariant. The class name that follows the keyword ’context’
specifies the class for which the following expression should hold.
The keyword ’inv’ indicates that this is an invariant
specification, i.e., for each object of the context class the
following expression must evaluate to true at all times. But note
that it is possible that an invariant is violated during execution of
an operation. More precisely, an invariant therefore has to hold only
for an object when none of its operations is currently executed.
However, it is not formally defined in the official UML 1.5
specification when invariants are exactly to be checked, but it is
commonly agreed that each time after the object’s status has
changed, its invariants have to hold (e.g., immediately after
completion of an operation).</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Though
UML has received increasing attention to model software systems in
recent years, it is missing sufficient means to specify constraints
over the dynamic behavior of a UML model. However, it is essential to
be able to for &nbsp;mulate such temporal constraints already in
early phases of development in order to specify correct system
behavior, in particular in the domain of time-dependent systems.
W</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">hile
other research approaches focus on UML Collaboration and Sequence
Diagrams and consider temporal OCL constraints for event
communication (e.g., [2, 9]), we here investigate &nbsp;consecutiveness
of states and state transitions in UML Statecharts. </SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
this article, we now show that the chosen approach is powerful enough
to express system properties that frequently appear in practical
systems development. We take the property specification patterns
identified by Dwyer et al. [3, 4] and demonstrate that it is possible
to formulate according temporal OCL expressions in each case. Note
that beyond those general patterns, our OCL extension also covers
explicit timing aspects, i.e., additional timing intervals can be
attached to temporal OCL expressions to further delimit pattern
scopes. Due to space limitations, we can only provide an informal
semantics description of the temporal OCL expressions. ← for ppt:
this is so far only an informal semantics description...</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Experiences
in the domain of formal specification have shown that the full power
of temporal logics, which allow for arbitrarily nested formulae, is
not needed in practice. In this context, Dwyer et al. have developed
a pattern system based upon more than 500 property specifications
from different projects in the area of finite-state verification.
That pattern system provides a structured set of commonly occurring
property specifications and examples of how to translate these into
different formal specification languages, such as Linear Temporal
Logic (LTL), Computation Tree Logic (CTL), or Graphical Interval
Logic (GIL). These formulae can be directly applied in different
verification tools, &nbsp;e.g., the model checking tools SPIN
(accepts LTL) or SMV (accepts CTL).1 As such verification tools
require rather cryptic temporal logic formulae as one part of the
input for the verification task, the pattern approach aims to support
developers in a way that abstracts from the formal syntax of temporal
logics. ← for meeting</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Dwyer
et al. have identified different scopes applicable to a pattern. A
scope is the part of the system execution path over which a pattern
has to hold. ← for meeting</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
patterns themselves are hierarchically ordered as shown in Figure 3.
In an online repository, for each pattern, each scope, and each
formalism an according formal description is provided. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">In
this section, we demonstrate how to express patterns of the pattern
system presented in Section 2 by means of our temporal state-oriented
OCL extension</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">.
UML Statecharts are for modeling the reactive object behavior of
objects. Basically, they are an object-oriented version of Harel
Statecharts [8]. In a UML Statechart, the term ’current state’
cannot be applied without causing confusion, as it can have composite
(i.e., nested and orthogonal) states and thus may reside in more than
one state at the same time. The following concepts and operations
have been newly introduced to OCL to be able to express the
specification patterns. Note that we keep compliant with the existing
standard OCL syntax and reuse as often as possible existing
collection operations like forAll(), exists(), includes(), and
excludes(). The only state-related operation of the current OCL
standard as well as the new OCL 2.0 proposal is called
oclInState(s:OclState). It is defined over objects of user-defined
classes that have an associated State-chart. Operation
oclInState(s:OclState) returns true if state s is currently active.
In addition to OCL invariants declared by the keyword inv, we
introduce a new clause called init. In contrast to an invariant over
an object obj that has to hold each time after obj’s status has
changed, the expression of an init-clause has to hold only at the
starting point of execution. Nevertheless, note that the expression
of the init-clause may be a temporal OCL expression. Temporal OCL
expressions are a new concept introduced to enable specification of
dynamic, behavioral constraints. In our approach, temporal OCL
expressions make use of a special temporal operation with signature
post(a:Integer,b:OclAny).</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
newly introduce the boolean operation startsWith(g:Sequence(T)),
which can be applied to sequences of objects of some type T. That
operation checks whether a given sequence starts with a sequence
specified by parameter g.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">example
ocl property:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-left: 1in; margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">context
Machine</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-left: 1in; margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">inv:
self.oclInConf(Loading) implies</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-left: 1in; margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">self@post(1,100)-&gt;forAll(
g |</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-left: 1in; margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">g-&gt;includes(Sequence{Working,Unloading,Idle}))</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">bljak?
This kind of property is heavily related to what is called chained
precedence and response in the original pattern system. But note that
we additionally can make use of time limitations. We think that this
work can help to increase the acceptance of formal specification in
the domain of object-oriented modeling with UML. Developers familiar
with the UML standard should easily understand our OCL extension, as
– in contrast to other approaches – it keeps compliant with
current OCL syntax and language concepts. ← also a problem is to
what extent are developers familiar with a declarative lanugage such
as OCL, even though it’s part of UML? ← for meeting? future work?</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">All
1999 article patterns are described in OCL expressions which is cool.
But state machines are necessary as design artifact.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">A
Library of OCL Specification Patterns for Behavioral Specification of
Software Components (2006)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">One
current problem in component specifications comes from the fact that
editing OCL constraints manually is time consuming and error-prone.
To simplify constraint definition we propose to use specification
patterns for which OCL constraints can be generated automatically. In
this paper we outline this solution proposal and present a library of
reusable OCL specification patterns.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
behavioral specification of a component is based on its interface
specification and on its specification data model and consists of OCL
expressions that constrain the components operations. It guarantees
that different sales orders always differ in the value of their id –
that is the attribute id is a semantic key for sales orders. By
defining an invariant this constraint needs only to be formulated
once and does not need to be repeated in several pre-and
postconditions. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
disadvantages of earlier formal methods are reduced by UML OCL [18]:
The notation of OCL has a comparatively simple structure and is
oriented towards the syntax of object-oriented programming languages.
Software developers can therefore handle OCL much easier than earlier
formal methods that were based on set theory and predicate logic.
This is one reason why OCL is recommended by many authors for the
specification of software components. Despite its advantages OCL can
not solve all problems associated with the use of formal methods: One
result of two case studies specifying business components [1,2] was
the insight that editing OCL constraints manually is nevertheless
time consuming and error-prone. Similar experiences were made by
other authors that use OCL constraints in specifications (outside the
component area), e.g. [12,15]. They conclude that it takes a
considerable effort to master OCL and use it effectively. Solution
strategies to simplify OCL specifications include better tool support
(to reduce errors) and an automation of constraint editing (to reduce
effort) – the latter can e.g. be based on use cases or on
predefined specification patterns. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Under
(OCL) specification pattern we understand an abstraction of OCL
constraints that are similar in intention and structure but differ in
the UML model elements used. Each pattern has one or more pattern
parameters (typed by elements of the UML metamodel) that act as
placeholder for the actual model elements. With pattern instantiation
we denote a specific OCL constraint that results from binding the
pattern parameters with actual UML model elements. ← for future
work!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">If
such OCL specification patterns are collected, formally described and
integrated into a specification tool the specification can be
simplified. Note that the tool can be built in such a way that it
restricts the input to those model elements that are allowed for a
pattern – in section 3 of Fig. 4 for instance you can see that the
tool only offers the attributes of class SalesOrder for selection. In
this section we introduce a list of OCL specification patterns that
are useful for behavioral specification of software components. To
obtain this list we first studied several case studies (dealing with
business components) and publications about component specifications
and identified </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">frequently
occurring patterns [3]. In a second step we analyzed the preliminary
list and identified </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">additional
patterns that are useful but could not be found in the first step.
(Reasons to include additional patterns were for instance extending
patterns to other relevant UML metamodel elements or symmetry
considerations like including a constraint for deleted instances if
there is one for created instances.) As result we obtained a library
of altogether 18 OCL specification patterns which are subdivided into
four categories. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
behavioral specification of software components refers to the
interface specification (cf. Fig. 1) and the specification data model
(cf. Fig. 2). ← but these are really static views :( :(</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Using
this pattern one can e.g. demand that the field must be greater than
zero or contain a specific element of an enumeration. The second
category (cf. Table 2) features patterns that only concern the
specification data model. They are independent from operation calls
and thus all invariants. The third pattern category (cf. Table 3)
contains patterns that deal with the exis-</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">tence
of specific class instances for an operation call. The fourth pattern
category (cf. Table 4) collects further patterns that allow
specifying prerequisites from model instances for an operation call
and consequences of operation calls for model instances. Pattern 15
(Postcondition for an Instance Attribute) describes a postcondition
that can be used to assure that an attribute of a given class
instance has a certain value (or value range) at the end of an
operation call. The specification patterns identified in Sect. 5 need
to be described precisely in order to be reusable for component
specifications. For that we propose to use on one hand a description
scheme and on the other hand a formal specification. The formal
specification is done by using OCL itself and addresses OCL experts
and tool builders who wish to implement constraint generators. The
description scheme addresses users of specification patterns – for
this it contains all relevant specification details in a more
informal way. To confront a pattern user with the full OCL
specification would contradict the goal to support specifications by
non-OCL experts as well. In this section we present both description
approaches.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
first characteristic is the pattern name that identifies the pattern
and serves as a short semantic explanation. The characteristic
pattern intent contains a short statement about intention and
rationale of the pattern. The characteristic pattern parameter lists
the parameters of the pattern together with their type. Parameters
can be of elementary type (like String) or are elements from the UML
metamodel (layer M2 in the four-layer metamodel hierarchy of UML
[17]). Parameters of pattern 7 are the class cl (of type Class) and
the list of key attributes keyList (of type ordered set of Property).
The characteristic restrictions denotes what conditions the pattern
parameters must fulfill. In our case it is required that all elements
of keyList are attributes of cl. The remaining three characteristics
describe the OCL constraint the pattern represents. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">With
constraint type we denote if the constraint is an invariant, pre- or
postcondition. ← these are the only constraint types that the paper
tackles</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Note
that the chosen notation for the characteristic constraint body is
sufficient to give an idea of the generated OCL expression but has
its limitations if patterns are variable. The basic idea how to
formally describe the specification patterns is as follows: For each
OCL specification pattern a specific function (called OCL pattern
function) is defined. The pattern parameters are the input of the
pattern function. Result of the pattern function is a generated OCL
constraint which is returned and (if integrated with the
specification tool) automatically added to the corresponding UML
model element. The OCL pattern functions themselves are specified by
OCL. All pattern functions are assigned as operations to a new class
OclPattern which logically belongs to the layer of the UML metamodel.
By defining OCL pattern functions for the specification patterns it
became possible to formally specify the patterns completely and quite
elegantly: the pattern parameters can be found as function parameters
and the function specification (which uses again OCL) describes the
prerequisites to apply the pattern and the properties of the
constraint to be generated. One big advantage is that this approach
only uses known specification techniques and does not require the
invention of new ones. There is only one new class OclPattern that
encapsulates the definition of all patterns. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><SPAN STYLE="background: transparent">← <FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">but
this paper does not yet introduce temporal properties? Like
before/until etc...</SPAN></SPAN></FONT></FONT></SPAN></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">STAIRS
towards formal design with sequence diagrams (2005)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">STAIRS
has been designed to facilitate the use of interactions for
requirement capture as well as test specification. STAIRS assigns a
precise interpretation to the various steps in incremental system
development based on an approach to refinement known from the field
of formal methods and provides thereby a foundation for compositional
analysis. An interaction may characterize three main kinds of traces.
A trace may be (1) positive in the sense that it is valid, legal or
desirable, (2) negative meaning that it is invalid, illegal or
undesirable, or (3) inconclusive meaning that it is considered
irrelevant for the interaction in question. The basic increments in
system development proposed by STAIRS, are structured into three main
kinds referred to as supplementing, narrowing and detailing.
Supplementing categorizes inconclusive traces as either positive or
negative. Narrowing reduces the set of positive traces to capture new
design decisions or to match the problem more adequately. Detailing
involves introducing a more detailed description without
significantly altering the externally observable behavior.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
UML interaction is a specification of how messages are sent between
objects or other instances to perform a task. Interactions are used
in a number of different situations. They are used to get a better
grip of a communication scenario for an individual designer or for a
group that needs to achieve a common understanding of the situation.
Interactions are also used during the more detailed design phase
where the precise inter-process communication must be set up
according to formal protocols. When testing is performed, the
behavior of the system can be described as interactions and compared
with those of the earlier phases. ← for ppt</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Interactions
seem to have the ability to be understood and produced by
professionals of computer systems design as well as potential
end-users and stakeholders of the (future) systems. ← for ppt</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Interactions
will typically not tell the complete story. There are normally other
legal and possible behaviors that are not contained within the
described interactions. Some people find this disturbing and some
project leaders have even tried to request that all possible
behaviors of a system should be documented through interactions in
the form of e.g. sequence diagrams or similar notations. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Our
position is that UML interactions are expressed through notations
that lend themselves well to conveying important information about
the interplay between objects, but interactions are not so well
suited to define the complete behavior. ← for ppt: I beg to differ:
just like a procedural programming should describe the
entire/complete intended behavior of a system, in the same manner
sequence diagrams should be able to tell the whole story</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">STAIRS
views the process of developing the interactions as a process of
learning through describing. From a fuzzy, rough sketch, the aim is
to reach a precise and detailed description applicable for formal
handling. To come from the rough and fuzzy to the precise and
detailed, STAIRS distinguishes between three main sub-activities: (1)
supplementing, (2) narrowing and (3) detailing. Supplementing
categorizes (to this point) inconclusive behavior as either positive
or negative recognizing that early descriptions normally lack
completeness. The initial requirements concentrate on the most
obvious normal situations and the most obvious exceptional ones.
Supplementing supports this by allowing less obvious situations to be
treated later. Narrowing means reducing the allowed behavior to match
the problem better. Detailing involves introducing a more detailed
description without significantly altering the externally observable
behavior. Under-specification as described in the previous paragraph
gives rise to non-determinism in the specification.
Under-specification allows the system developer to choose between
several potential behaviors. Sometimes, however, it is essential to
retain non-determinism in the implementation reflecting choice. &nbsp;It
is quite different, however, to reduce nondeterminism if each
alternative represents a distinct and intended behavior. As a
consequence, we need to distinguish explicit non-determinism
capturing mandatory behavior from non-determinism expressing
potential behavior. Should allow specification of negative behavior
in addition to positive behavior. Interactions are not only suited to
capture system requirements. They may just as well describe illegal
or undesirable behavior. Should support compositional analysis,
verification and testing. Models are of little help if they cannot be
used</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">as
a basis for analysis, verification and testing. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
most visible aspects of a UML interaction are the messages between
the lifelines. The sequence of the messages is considered important
for the understanding of the situation. The data that the messages
convey may also be very important, but the interactions do not focus
on the manipulation of data even though data can be used to decorate
the diagrams. ← for ppt: we also don’t focus on data manipulation
here, though it’s not less relevant for the purpose of model
checking. We do however include the data in the model.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Interactions
focus on the interplay between objects. In the tradition of
telecommunications these objects are independent and themselves
active as stand-alone processes. Therefore, when a message is sent
from one lifeline to another, what happens on the sending lifeline is
independent</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">from
what happens on the receiving side. The only invariant is that the
sending of a message must occur before the reception of that very
message. Most people find this obvious. ← </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">FOR
PPT! This misconception seems to continue from the telecommunications
history. Nowadays these are not processes but are objects! </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
sending of a message and the reception of a message are examples of
what we call events. An event is something that happens on a lifeline
at one point in time. An event has no duration/. ← for ppt!!!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
trace is a sequence of events ordered by time. A trace describes the
history of message-exchange corresponding to a system run. A trace
may be partial or total. Interactions</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">may
be timed in the sense that they contain explicit time constraints. ←
we do not treat time in this context because we don’t deal with
realtime systems ← for ppt</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
this section we will give a very brief introduction to the trace
semantics of UML 2.0 interactions expressed in sequence diagrams and
interaction overview diagrams</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
ppt:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
interaction of Fig. 2 shows two messages both originating from L1 and
targeting L2. The order of the events on each lifeline is given by
their vertical positions, but the two lifelines are independent. Each
of the messages has the semantics given for the message in Fig. 1,
and they are combined with what is called weak sequencing. Weak
sequencing takes into account that L1 and L2 are independent. The
weak sequencing operator on two interactions as operands is defined
by the following invariants:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">1.
The ordering of events within each of the operands is maintained in
the result. 2. Events on different lifelines from different operands
may come in any order. 3. Events on the same lifeline from different
operands are ordered such that an event of the first operand comes
before that of the second operand.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Thus,
if we denote the weak sequencing operator by seq</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">according
to UML 2.0, we get:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">W
= !x, ?x seq !y, ?y</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">=
{ !x, ?x, !y, ?y , !x, !y, ?x, ?y }</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
sending of x must be the first event to happen, but after that either
L1 may send y or L2 may receive x. Intuitively, an interaction
occurrence is merely shorthand for the contents of the referenced
interaction. ← they mean interaction reference probably</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
Fig. 4 we introduce another construct called combined fragment.
Combined fragments are expressions of interactions combined
differently according to which operator is used. In fact, also weak
sequencing is such an operator. In Fig. 4 we have an alternative
combined fragment. In Fig. 9 we show a more elaborated scenario where
this negative scenario has been included through a combined fragment
with the operator neg. This indicates that all traces in this
fragment are “negative” or undesirable. In combination with other
traces this negative fragment gives negative traces for every trace
leading up to it. In our example the intuition is simple; any trace
that gives no money back when the receipt says it should have, is a
negative scenario. The subtraces that will follow the negative
fragment, the return of the card, certainly does not make</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">the
scenario less negative. Still we have not defined all possible
scenarios of withdrawing money in an ATM. At this stage it is up to
our imagination and the scope of our specification what cases we care
to describe. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Semantically,
each negative behavior is represented by a trace. Ignoring mandatory
behavior that is the issue for the next section, but considering both
positive and negative behavior, the semantics of an interaction may
be represented by a pair of sets ( p, n) where n contains the
negative traces and p contains the positive traces. The same trace
should not be both positive and negative. Traces that are neither
negative nor positive are inconclusive, i.e. considered irrelevant
for the specification. On the other hand, we would like to convey
that every ATM should offer withdrawal of native money. We specify
that this is a mandatory requirement. We need a way to say that it is
provisional whether both euros and US dollars are offered, but there
is no choice not to offer withdrawal of native money. The latter
distinction cannot be expressed directly by the operators of UML 2.0,
but we have introduced a small extension and called this choice
between alternatives that are mandatory as xalt. ← this is what
“mandatory” behavior is based on in their approach. story ends.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Supplementing
means reducing the set of inconclusive traces by defining more traces
as either positive or negative. Any originally positive trace remains
positive, and any originally negative trace remains negative.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">When
the designers have reached a description that they consider
sufficiently complete, they will focus on making the descriptions
suitable for implementation. Typically an implementation may decline
to produce every positive potential trace. We define narrowing to
mean reducing underspecification by eliminating positive traces
without really changing the effect of the system.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
our context of interactions, reducing the
variability/under-specification means to move traces from the sets of
positive traces to the set of negative. The semantics of sequence
diagrams is defined by a function [[ ]] that for any sequence diagram
d yields a set [[d]] of interaction obligations. As explained in
Sect. 3.4, an interaction obligation is a pair ( p, n) of sets of
traces where the first set is interpreted as the set of positive
traces and the second set is the set of negative traces. The term
obligation is used to explicitly convey that any implementation of a
specification is obliged to fulfill each specified alternative. More
complex sequence diagrams are constructed through the application of
various operators. We focus on the operators that we find most
essential, namely negation (neg), potential choice (alt), mandatory
choice (xalt), paral-</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">lel
execution (par), and weak sequencing (seq)...</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Notice
that a negative trace cannot be made positive by reapplying neg.
Negative traces remain negative. Negation is an operation that
characterizes traces absolutely and not relatively. The intuition is
that the focus of the neg construct is on characterizing the positive
traces in the operand as negative. Negative traces will always
propagate as negative to the outermost level. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
alt construct defines potential traces. The semantics is the union of
the trace sets for both positive and negative. The xalt construct
defines mandatory choices. All implemen tations must be able to
handle every interaction obligation. &nbsp;</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Weak
sequencing is the implicit composition mechanism combining constructs
of a sequence diagram. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Refinement
means to add information to a specification such that the
specification becomes closer to an implementation. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">This
may also be characterized as a two-layer approach </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">as
it takes the basic message sequence charts as starting point and add
modal characteristics upon those. The modal expressiveness is strong
in LSC since charts, locations, messages and conditions are
orthogonally characterized as either mandatory or provisional. Since
LSC also includes a notion of subchart, the combinatory complexity
can be quite high.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Mandatory
as in LSC should not be confused with mandatory as in STAIRS, since
the latter only specifies traces that must be present in an
implementation while the first specifies all allowed traces. Hence,
mandatory as in STAIRS does not distinguish between universal or
existential interpretation, but rather gives a restriction on what
behaviors that must be kept during a refinement. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Refining
UML interactions with underspecification and nondeterminism (I have a
similar one!)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Formal
verification of UML state diagrams: a petri net based approach</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">From
scenarios to code: An air traffic control case study”.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">They
define a mapping algorithm that produces statecharts from sequence
diagrams, and they show how code can be generated from the models. ←
perhaps useful?</SPAN></FONT></FONT></FONT></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------s</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Extracting
Models from Source Code in Software Modernization</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">TEPE:
A SysML Language for Time-Constrained Property Modeling and Formal
Verification ← really, for realtime systems</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
property expression language, a formal semantics, and a tool. The
paper introduces TEPE, a graphical TEmporal Property Expression
language based on SysML parametric diagrams. TEPE enriches the
expressiveness of other common property languages in particular with
the notion of physical time and unordered signal reception. TEPE is
further instantiated in the AVATAR real-time UML profile. TTool, an
open-source toolkit, implements a press-button approach for the
formal verification of AVATAR-TEPE properties with UPPAAL. The
strength of the AVATAR-TEPE combination is that requirement capture,
analysis, design, property description and verification tasks can
seamlessly be accomplished in the same language, namely UML, and in
the same environment [ASS09]. The designer is merely required to have
minor UML skills and does not need to familiarize with formal
languages like CTL or UPPAAL. As the objective is to verify
sequential behaviors - and their timing -, the property descriptions
could surely rely on state machines. However, overusing UML
Statecharts both for modeling and property purposes is probably not a
good idea. Indeed, if property description does not rely on a
different formalism, it runs the risk of being hampered by the same
errors in reasoning as the model.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Apart
from Statecharts, formally defined descriptions for sequential
behavior fall short in UML. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">For
example, scenario-based models like Sequence Diagrams fail to
describe relations between attributes of various instances (e.g.,
attribute x of instance I0 is equal to attribute y of instance I1 ),</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">and
they might be inadequate for describing complex situations, in
particular to reference past events. Additionally, the integration of
equations that have to be fulfilled as a function of the system
behavior is not straightforward in UML and requires the usage of OCL,
thereby circumventing the graphical notation.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
specification in TEPE represents functional and nonfunctional
properties in a formal way, using Parametric Diagrams. As opposed to
informal SysML PDs, TEPE PDs are amenable to automated verification.
A small set of operators can be leveraged to make up complex
properties.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
TEPE, </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">each
property is expressed as a graph of Signals, Attributes, Constraints
(Equations, Logical Constraints, Temporal Constraints) and
Properties.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
AVATAR profile reuses eight of the SysML diagrams (Package diagrams
are not supported). It further structures Sequence Diagrams using an
Interaction Overview Diagram (a diagram supported by UML2, not by
SysML). The AVATAR profile is syntactically and semantically defined
by a meta-model. Besides a syntax, a semantics and a tool support, a
profile is also characterized by a methodology.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">For
each property defined in a Parametric Diagram, a corresponding
observer automata [FSsA08] is derived. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
latter makes states and transitions related to verification explicit
in the UPPAAL model. In so doing, proving the satisfiability of a
given TEPE property is reduced to searching for the accessibility or
liveness of a given observer state, using the UPPAAL verifier. TTool
is interfaced to verification tools that implement reachability
analysis and model-checking. For example, to decide whether some UML
action is reachable or not, it suffices to right click on the
corresponding action’s symbol: The UPPAAL verifier is invoked with
corresponding CTL formula, and the result is displayed on UML
diagrams.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Diagrams
can automatically be formally checked out only when they target the
reachability or liveness of one specific state of an AVATAR State
Machine. Otherwise, they must be translated by hand. Their full
translation is under development.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">After
having structured the system in terms of blocks, attributes and
signals, the developer may proceed with the formal model of the
properties to be verified (</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">see
Figure 6),</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">corresponding
to requirements (Req1 to Req4 ). &nbsp;← the “blocks” are like
classes; See figure 6, seems again blocks and signals, not exactly a
scenario of sort...</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
case study demonstrates the applicability of TEPE language for the
verification of system properties. While sharing the most important
semantics with other temporal logics like CTL, TEPE enriches their
expressiveness with the notion of physical time and an operator
matching a set of unordered signals. The granularity and the
abstraction level of diagrams is in line with the system model;
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">system
transitions are referred to using signals and state variable
modifications. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">These
elements are familiar to the designer as he/she introduced them
during the design phase. </SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">By
combining static equations and sequential operators, a temporal scope
is attached to the former. &nbsp;← this is really good, for future
work, also meeting! (introduced during design: objects, methods,async
calls, variable changes etc)</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">A
formal definition however opens the door for an automatic
verification on the fly during simulation </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">or
by transformation into an UPPAAL model enhanced with observers.
A</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">lthough
nothing prevents from using the textual from of TEPE, the graphical
representation based on Parametric Diagrams far outreaches the latter
in terms of readability.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Moreover,
an adequate coloring of operators facilitates the clear distinction
between timed (signals) and untimed parts (properties) of the
diagram. Properties are built up upon logical and temporal relations
between block attributes and signals.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">A
graphical interval logic for specifying concurrent systems (1994!!) ←
bullshit</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Experience
has shown that most software engineers find standard temporal logics
difficult to understand and use. The objective of this article is to
enable software engineers to specify and reason about temporal
properties of concurrent systems more easily by providing them with a
logic that has an intuitive graphical representation and with tools
that support its use. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
most critical real applications often involve concurrency, which
increases the dificulty of system development and validation. Modern
methods of structured programming, which are quite effective for
sequential programs, are notoriously inadequate for concurrent ones.
Moreover, the nondeterminism inherent in applications that involve
concurrency and the reactive character of those applications makes
them hard to test. Aggravating these problems is the need to explore
large spaces of possible executions, which grow exponentially with
the number of independent threads of control. ← for ppt</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
practice, however, system developers seldom make significant use of
formal specification and verification methods. We believe that this
is due, in large part, to the reliance of those methods on
mathematical formalisms that are difficult to understand and to use.
Formal speci cation and analysis methods must be made accessible to
system designers and software engineers if they are to be used in the
development of real world systems. Users must be able to express the
properties of the systems about which they wish to reason as
naturally as possible and to conform mechanically that the
specifications, designs, testing criteria and sample executions have
the required properties. Temporal logics 2, 19, 21, 32] are
well-suited for specifying temporal properties of concurrent systems.
Experience has shown, however, that specifications of even
moderate-sized systems are too complex to be readily understood. This
complexity stems chie y from the need to establish the temporal
context within which properties, such as bounded liveness and
invariance, must hold. Interval logics 11, 31] address this problem
by defining temporal intervals to represent such contexts.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Stylized
pictures often show complex timing relationships and dependencies
more clearly than linear textual representations of the same
information. Such diagrams correspond more closely to common
conceptualizations than does linear text. Software engineers often
draw timing diagrams, like those used to denote signal levels in
hardware designs, when describing and reasoning about properties of
systems. Even logicians who are fluent in temporal logic find timing
diagrams helpful to explain the meanings of temporal logic formulas
and to motivate lines of reasoning (see for example 6]). However,
because timing diagrams often lack a formal semantics, they cannot be
used for rigorous analysis of system properties. Pictorial
documentation is all too often ad hoc and liable to ambiguous
interpretation. ← for future work</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Graphical
Interval Logic (GIL) has a formal model-theoretic semantics and is
more expressive than propositional temporal logic with Until and
without Next 27]. It thus provides an intuitive and natural visual
notation in which to express system speci cations without sacri cing
the bene ts of a formal </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">notation.
A visual editor allows GIL speci cations to be easily constructed and
to be stored in and </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">retrieved
from les. The editor also provides a visual interface to a proof
checker and model generator, which permit veri cation of temporal
inferences. When reasoning about temporal properties exhibited by a
concurrent system during a computation, it is convenient to regard
the system as passing through a sequence of states. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">GIL
specifications for a system describe properties of legal state
sequences. &nbsp;← so not events/actions but states?</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
GIL formula is evaluated at a state in an infinite sequence of
states. Infinite state sequences, therefore, provide the contexts
within which formulas are evaluated. Intervals permit the speci
cation of contexts within which properties hold. As suggested by the
representation, every interval has an initial point (state). However,
since contexts are infinite, we do not regard an interval as having a
final point. The logic provides two search primitives for use in
specifying intervals. Search to a target formula f , and Search to
the right end of the context. Searches can be composed sequentially,
with each successive search starting from the point, if any, located
by the previous search. GIL provides a special syntax for expressing
invariants and eventualities. To assert that a formula holds at every
point in an interval, the formula is drawn indented directly below
the interval. To assert that a formula holds at some point within an
interval, the formula is drawn left justified directly below a
diamond 3 drawn on the interval ←bullshit</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
major advantage of using a visual logic, such as GIL, is that
pictures (of the implications) representing the inferences used in
the proof of a requirement can show the temporal ow of the argument.
The graphical representation of the timeline allows one to align
appropriate points in the picture. &nbsp;← wtf proofs are graphical</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">A
general framework for formalizing UML with formal languages</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Safety-Liveness
Semantics for UML 2.0 Sequence Diagrams (2005)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
provide an automata-theoretic solution to one of the main open
questions about the UML standard, namely how to assign a formal
semantics to a set of sequence diagrams without compromising
refinement? Our solution relies on a rather obvious idea, but to our
knowledge has not been used before in this context: that bad and good
sequence diagrams in the UML standard should be regarded as safety
and liveness properties, respectively. Proceeding in this manner, we
obtain a semantics that essentially complements the set of behaviors
associated with the set of sequence diagrams, thereby allowing us to
use the standard notion of refinement as language inclusion. We show
that refinement in this setting is compositional with respect to
sequential composition, alternative composition, parallel
composition, and star+ composition.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Various
researchers have realized the importance of equipping SDs with a
formal semantics, thereby providing SDs with a precise and
unambiguous intention, and forming the basis for powerful analysis
algorithms and tools. In spite of these successes, there is still no
unanimous agreement on one of the main questions about SDs, namely
how can one assign a formal meaning to a set of SDs without
compromising refinement? The standard notion of refinement via
simulation or language inclusion requires that each observable
behavior of an implementation is also an observable behavior of the
specification. An SD, however, may be composed with other SDs via
sequential composition, alternative composition, parallel composition
and star+ composition (looping), and a direct translation of SDs to
automata (or partial orders) leads to implementations with a larger
number of behaviors than their corresponding specifications.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Our
semantic treatment of SDs proceeds roughly as follows: (i) Given a
set of SDs, we translate each SD to a hierarchic automaton that may
contain negative states. (ii) We separate the negative </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">states
from the positive ones by defining a construction that extracts a
negative hierarchic </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">automaton
and a positive hierarchic automaton from the original hierarchic
automaton. (iii) </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">We
construct a safety Buchi automaton from the negative hierarchic
automaton and a liveness Buchi automaton from the positive one. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
safety and liveness automata ensure that a trace that may either lead
to the completion of a bad scenario or prevent the completion of a
good scenario is rejected. (iv) We take the product of these two
automata as the operational semantics of the original set of SDs and
the corresponding language as the denotational semantics. (v) We
define refinement in terms of language inclusion; there is no need to
consider finer (more behavioral) notions of refinement as our
automata are input enabled. (vi) We show that refinement is
compositional with respect to sequential composition, alternative
composition, parallel composition and star+ composition. High-level
sSDs are referred to as “interaction overview diagrams” in the
UML 2.0 standard.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">A
basic SD focuses on the message interchange among a set of processes.
Each process is represented by a life-line drawn as a (dashed)
vertical line beneath a box containing the name of the process, and
each message is represented by an arrow drawn from the sender to the
receiver and decorated with a message identifier. ←</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">dafuq?
It’s not a process!! it’s an object!</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">A
high-level SD is intended to serve as an overview of the flow of
control among its constituent SDs, and is essentially a flowchart
whose nodes are either initial, final or decision/merge points, or
non-recursive references to basic or high-level SDs. To increase
readability, high-level SDs may also contain fork and join points
which allow one to compose SDs in parallel.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
main UML 2.0 interaction operators include sequencing, alternation,</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">option
(representing a choice between the enclosed operand and an invisible
empty operand ← exactly, for NFM rebuttal</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">),
parallel, looping, and </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">negative,
which designates an invalid execution sequence.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Since
most interaction operators, with the notable exception of negative,
can be captured by high-level SDs, we assume for simplicity that
basic SDs are flat (non-nested), but allow the negative operator
(denoted neg) to be applied to SDs. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
formal semantics of SDs is traditionally given in terms of a process
algebra </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">or
partial orders. If, however, SDs are bounded (see Section 4.3), </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">one
can equivalently use nondeterministic finite automata as a semantic
framework</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">.
Such semantics are closed-world in the sense that given a set of SDs,
no new SDs may be added to it without compromising refinement. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Definition
1 (NFA) A nondeterministic finite automaton (NFA) A = Σ, S, δ, S0 ,
F over an input alphabet Σ is a 5-tuple such that:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><SPAN STYLE="background: transparent">• <FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">Σ
is the input alphabet. • S is a finite set of states. • δ ⊆ S
× Σ ∪ { } × S is the transition relation.</SPAN></SPAN></FONT></FONT></SPAN></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><SPAN STYLE="background: transparent">• <FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">S0
⊆ S is a set of initial states. • F ⊆ S is a set of accepting
states.</SPAN></SPAN></FONT></FONT></SPAN></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">An
input sequence σ = σ1 . . .σn is accepted by A if there is a state
sequence s = s0 . . .sn such that s0 ∈S0 , sn ∈F and for each i,
the tuple (si , σi+1 , si+1 ) is in δ. L(A), th</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">e
set of all accepted input sequences, is called the language of A
(nondeterministic finate automaton A)</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">.
← for future work and meeting </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
UML 2.0 semantics for SDs is based on an asynchronous interpretation
of communication, where the sending and receiving of a message are
considered to be distinct events. A natural way of capturing this
semantics is to associate a partial order (PO) with each basic SD,
where events are ordered from top to bottom along process lifelines
and where the sending event at the tail of a message arrow is
uniquely related to and precedes the receiving event at the head of
the message arrow. Given the PO, one can obtain an NFA from it by
applying the classical PO-to-NFA translation scheme of [7]: (1) The
states of the automaton correspond to cuts, which are sets closed
w.r.t. the partial order; the empty cut is the initial state and the
cut with all events</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">is
the accepting state. (2) If cut d equals cut c plus a single event e,
then there is an edge from c to d labeled with l(e). The labeling
function l is given with respect to an input alphabet Σ, which is
partitioned into sending tuples m:n!a and receiving tuples n:m?a. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">UML
2.0 SDs are intended to capture the behavior of reactive systems:
those whose role is to maintain an ongoing interaction with their
environment rather than produce some final value upon termination.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">NFAs
are therefore not an appropriate formal model for reactive systems,
since termination should be viewed as an error rather than a
desirable outcome. A more suitable formal model for SDs are
ω-automata: automata over infinite words. In particular, Buchi
automata are ω-automata requiring an accepting state to be visited
infinitely often for every accepted input sequence. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">In
the rest of this section, we show how to construct a B ̈ chi
automaton for a given SD. ←! </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
standard way of avoiding (premature) termination within a finite
automaton is to allow the automaton to loop forever in each accepting
state. To be more specific about the fact that processes may operate
at different speeds, but not too specific, we add a τ self-loop to
every state. Interaction fragments (and, thus, SDs) can be positive
or negative, with the latter indicated by the interaction operator
neg. Positive and negative SDs, however, are intended to capture
orthogonal properties, namely liveness and safety. The negative NFA
is obtained by turning all negative nodes into accepting sink nodes
(without outgoing transitions), and all other nodes non-accepting.
The positive NFA is obtained by removing all negative nodes and all
their associated transitions. ← wtf?</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">According
to the UML 2.0 standard [24], a negative fragment describes traces
that are invalid and should therefore never happen in an execution of
the system. In other words, a negative fragment is intended to
capture a safety property. An automaton is limit-closed if all its
infinite behaviors are completely characterized by its finite
behaviors. According to the UML 2.0 standard [24], the positive
fragments describe traces that are valid and should be possible. As a
consequence, each finite execution should be extendible to an
execution where the positive trace eventually happens. In other
words, the positive fragments are intended to capture liveness
properties. We now present a transformation that leads to an
automaton that is open to new behaviors, but rejects the ones
preventing positive traces from happening, by infinitely stuttering
in a non-accepting state</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Given
a reduced Buchi automaton A representing the positive high-level NFA
P , define Live(A) to be the Buchi automaton derived from A as
follows: (i) Construct the automaton</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Uns(A)=¬Safe(A).
(ii) Take the union A ∪ Uns(A). ← for future work, how you
construct liveness automaton.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Given
a reduced Buchi automaton B = ¬N , define Safe(B) to be the version
of B in which every state has been transformed into an accepting
state. ← for future work, how to construct safety automaton. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Taking
the product (conjunction) of the safety automaton of Figure 6(b) and
the liveness automaton of Figure 7(b), one obtains the desired
automaton for the SD of Figure 1(b). ← really??</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">An
interesting trace-based approach is advocated in STAIRS [16], where
SD behaviors are classified into positive, negative and inconclusive.
While intuitively appealing, the formal treatment is essentially
restricted to a closed-world view of the positive behaviors.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">More
formally, given a set of UML SDs, for each SD in the set, we
construct two B ̈ chi automata, one expressing safety and one
expressing liveness, and take their product as the SD’s semantics. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Checking
the validity of scenarios in UML models (2005) ← </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">definitely
important for future work, </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">as
it shows how to define monitoring processes for cases of
negation/universal/existential scenarios</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">In
the UML, sequence diagrams are used to state scenarios, i.e.,
examples of interactions between objects. As such, sequence diagrams
are being developed in the early design phases where requirements on
the system are being captured. Their intuitively appealing character
and conceptual simplicity makes them an ideal tool for formulating
simple properties on a system, even for non-experts. Besides guiding
the development of a UML model, sequence diagrams can thus
furthermore be used as a starting point for the verification of the
UML model. ← for future work! </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">In
this paper, we show how the requirements on the system as stated in
sequence diagrams can be (semi-automatically) validated for UML
models consisting of class diagrams, state machines and structure
diagrams. The sequence diagrams that we consider can be universally
or existentially quantified or negated, i.e., state scenarios that
should always, sometimes or never occur. ← this is good, really
good!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">For
validating them in a UML model, we translate both model and sequence
diagrams into a formal specification language (the process algebra
CSP), and develop procedures for employing the standard CSP model
checker (FDR) for checking their validity.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
UML is a modelling language which supports modelling with different
views. Its various diagram types allow for the description of
different though not necessarily disjoint aspects of a system: Class
diagrams model the static behaviour (data and operations), state
machines the dynamic behaviour (protocols), structure diagrams the
architectural composition and sequence diagrams typical application
scenarios (plus possibly further diagrams for other aspects).
Together they model the system to be built. Such a complex model
composition immediately poses the question of consistency: is the
architectural composition consistent with the interface description
of the components, are static and dynamic behaviour
non-contradictory, is the scenario as stated in the sequence diagrams
actually allowed in the model, etc.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
starting point for our study are UML 1.5 sequence diagrams [24] which
we extend with features for stating negation and universal and
existential quantification (partially coming from UML 2.0 sequence
diagrams1 ). ← nooooooo!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">To
achieve the necessary precision in the model (which is mandatory for
a verification) we additionally use the Z notation [21, 13] for
writing attributes and methods in class diagrams. The question is
then whether the sequence diagrams are consistent with the UML model
in that the restrictions on the overall behaviour (as laid down in
the diagrams) do not prevent desired or allow forbidden scenarios. We
develop a technique which allows to automatically check for this kind
of consistency. To this end, we translate both sequence diagrams and
the rest of the UML model into a formal specification language. The
translation of class diagrams, state machines and structure diagrams
follows a technique proposed in [16], the translation of the sequence
diagrams is inspired by [10] and given in this paper. ← checkout
paper [10] == “An algebraic semantics for message sequence chart
documents.” 1998?!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">You
need license for this FDR shit, plus last update 2010! CSP algebra
</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">from
website “Datatypes may not be parameterised (T may not have
arguments). The datatype corresponds to the variant-record construct
of languages like Pascal. At the simplest level it can be used to
define a number of atomic constants” ← tja..</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">For
the modelling we use a UML profile for reactive systems as being
built out of processes (active objects) working concurrently and
communicating with each other. &nbsp;The reactive system itself is
modelled by a structure diagram. Structure diagrams describe the
architecture of systems, i.e., their components and their
interconnection. A capsule in a structure diagram is drawn as a
rectangle with ports (white or black ) indicating their protocols.
Two ports (and thus two capsules) can be connected if they refer to
the same protocol. A port residing on the border of the outermost
capsule (capsule System) describes the interface of the system
towards its environment. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">For
this purpose the specification formalism Z [21, 13] is employed. If
such a specification is supplied for all methods and attributes a
precise and unambigious meaning can be given to the UML model. This
is the prerequisite for formally checking the validity of scenarios.
For our example, we only show the signatures of methods in interface
since we will refer to them when translating sequence diagrams. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">We
always assume to have one class (here called User ) which models the
environment of our system. The interface of this class can be
determined from the structure diagram: all protocols of ports
residing on the borders of the outermost capsule System are also
protocols of the environment class (complementing methods and
channels, inputs and outputs). The behaviour of the environment
remains unspecified, thus we assume it to behave chaotically (all
behaviour allowed). ← for ppt?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Here,
we use a very simple form of sequence diagrams since our main focus
is not on giving a semantics but on checking their validity (for
semantics for message sequence charts, the precursors of sequence
diagrams, see for instance [10, 14, 15]; for a semantics for UML 2.0
interactions diagrams see [22]). For the banking system we might for
instance like to specify that a user never gets money when the ATMs
question for enough credit is answered with ”no”</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Given
a UML model of a system and a number of sequence diagrams specifying
allowed or forbidden scenarios we are interested in knowing whether
these scenarios are actually possible (or not possible) in the model.
We refer to this as the validity of the scenario in the model.
Checking the validity of scenarios should at the best be fully
automatic; here we propose a technique which is partially automatic.
&nbsp;← this is what it’s all about </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
translation of models in our specific UML profile to CSP can be found
in [16]. Roughly, the translation proceeds as follows: The class
diagram together with the Z formalisation of interfaces, attributes
and methods is translated to Object-Z [20]. The Object-Z classes of
capsules are then augmented with CSP process descriptions which are
derived from the state machines. A specific CSP process is computed
for the outermost capsule System. This process describes the
architecture of the system and consists of the parallel composition
of the capsules in the system. Together, these</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">classes
form a CSP-OZ [8] specification. CSP-OZ is a combination of Object-Z
and CSP and has a semantics in terms of the semantic model of CSP.
Thus we hereby end with a CSP semantics for our UML model. &nbsp;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">In
the next step we equip the sequence diagrams with a CSP semantics as
well. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">As
a language for formalising the diagrams we again employ Z. As we have
already explained, all channels must have two special parameters
which are used for adressing the partners in a communication. CSP
processes are built over events. An event consists of a channel name
together with values for parameters, e.g. answer .b.a1.true is an
event consisting of the name answer plus values b (for parameter
from), a1 (for to) and true (for ok ). The notation? denotes that any
value can be accepted for a parameter. A partial event is one in
which some of the values for parameters are missing, e.g. answer
.b.a1 is only a partial event. &nbsp;← </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">partial
events with any-value-for-</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">parameter,
useful for future work! meeting also!</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
sequence diagrams events will appear as labels of arrows between
objects. Whenever values for parameters are left out (which is most
often the case) we assume the value to be ?_</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">To
distinguish two arrows with the same label connecting the same lines
we attach a unique identifier to each arrow. The values for
parameters to and from of an event attached to an arrow have to agree
with the objects connected by the arrow.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Additionally,
every sequence diagram is equipped with an occurrence condition
stating whether the specified scenario should never/sometimes or
always happen.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Condition
::= negative | existential | universal</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Here
we employ alphabetised parallel composition: for every process in a
parallel composition its alphabet of events is given, and
synchronisation has to take place on events in the intersection of
alphabets. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
translation proceeds in two steps. The CSP process of the sequence
diagram is the parallel composition of the CSP processes belonging to
every lifeline of an object. These processes synchronise on shared
events. Due to the parameters to and from in events, an event belongs
to the alphabet of exactly two objects (and thus to exactly two CSP
processes). </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">←
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">process
per lifeline. Also:</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
CSP processes of the lifelines are simply the sequential composition
of the events on their arrows. Having defined the CSP semantics of
simple sequence diagrams and UML models, it is now possible to check
the validity of the scenario in the UML model. ← but it’s not in
temporal logic, strange, how can it be checked as a property then?
see below..(it’s a tester/monitoring process run in parallel with
the system)</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">For
the simple sequence diagrams defined in this paper, there are of
course only finite runs; &nbsp;← can this be a problem in future
work? How do I define infinite runs with SDs?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">below:
&nbsp;“To establish these occurrence conditions, it is sufficient
to verify the following assertions” … [formulas]</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Since
this is neither a refinement check in one of CSP’s semantic models
nor a check for deadlock- or divergence-freedom, </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">we
cannot directly use FDR but first have to reformulate the problem in
a way tractable by FDR. The general idea is to use an auxiliary
process (‘tester’), which performs pattern matching for the
sequence s on the stream of events it is offered. This process is
then put in parallel to the process P for the system to be analysed,
synchronizing on the whole alphabet of the system. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><U><SPAN STYLE="background: transparent">So,
for negative and existential conditions (assertions) in SDs:</SPAN></U></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">In
order to perform this check for some specific sequence of events s, a
process S_match is constructed from s, which always accepts all
events in E until it has performed s; in that case it performs an
event match ∈ E and stops (deadlocks)</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Next
we put P and S_match in parallel, synchronising on the whole alphabet
E of P and hide all of E , since we are only interested in the
occurrence of match. ← for ppt! </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Thus,
for checking validity of sequence diagrams with negative conditions
we use FDR to check (∗), if this fails the sequence diagram is
valid in the UML model; for sequence diagrams with existential
conditions we use (∗) as well and validity holds if the test is
successful.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><U><SPAN STYLE="background: transparent">Universal
assertion:</SPAN></U></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">This
task is a little more complicated, because of the universal
quantification. We cannot use the simple traces model here, but need
to take deadlock and divergence into account: if s is to occur on all
runs of P , then P must neither be able to deadlock nor to diverge
until it has performed s. Furthermore, each (non diverging) infinite
run of P has to contain s. Therefore we split this task into two
checks. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">For
the first one a process Sdiv is constructed from s, which differs
from Smatch only in the definition Ss = div</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">that
is, it diverges immediately after performing s instead of performing
an additional event and stopping. The second test requires an
auxiliary process Snot , which always accepts any event in E , except
when it has already performed all but the last event of s, in which
case Snot refuses exactly that event, but no other. Summarising, we
have:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><SPAN STYLE="background: transparent">– <FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">P
cannot deadlock until it has performed s and</SPAN></SPAN></FONT></FONT></SPAN></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><SPAN STYLE="background: transparent">– <FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">P
cannot diverge until it has performed s and</SPAN></SPAN></FONT></FONT></SPAN></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><SPAN STYLE="background: transparent">– <FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">P
has no infinite trace (non-diverging) which does not contain s,</SPAN></SPAN></FONT></FONT></SPAN></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">i.e.,
any finite or (non-diverging) infinite run of P contains s</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Validity
of sequence diagrams with universal condition can hence be checked
using the above two tests. Besides single words the language of a
sequence diagram can also contain more than one word. This is the
case if the sequence diagram specifies certain interactions to be
concurrent. The corresponding CSP process will then contain all
possible interleavings in its set of runs. The simplest, yet slightly
inefficient way to perform the necessary tests for a set L, is to
construct the respective processes for all the s ∈ L and to use
them all at once, i.e., to put them in parallel, synchronising on E .
Using labelled trasition systems, [4] defines behavioural consistency
for combinations of UML behavioural diagrams (including statecharts
and sequence diagrams) as deadlock freedom. They use the SPIN model
checker for analysis, </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">but
do not give a formal translation from UML to SPIN’s input language.
← for ppt: I will not give a formal translation, just to make it
clear. This needs to be done, probably things need to be polished as
well. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
work most closest to us is that carried out in the context of life
sequence charts (LSCs) [6]. LSCs are an extension of sequence
diagrams with special features for modelling liveness requirements.
The work [3] proposes validity checking for LSCs</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">by
translating them to the temporal logic LTL and checking them against
Statemate models. Based on LSCs, the play in play out approach [11]
uses a collection of ‘played in’ examples to specify a whole
system, instead of using them only as requirements for an explicit
model.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">A
Pattern-Based Approach to Formal Specification Construction (2011,
see related work why previous approaches are not good?) ← lousy
paper in fact</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Difficulty
in the construction of formal specifications is one of the great
gulfs that separate formal methods from industry. Though more and
more practitioners become interested in formal methods as a potential
technique for software quality assurance, they have also found it
hard to express ideas properly in formal notations. This paper
proposes a pattern-based approach to tackling this problem where a
set of patterns are defined in advance. Each pattern provides an
expression in informal notation to describe a type of functions and
the method to transform the informal expression into a formal
expression, which enables the development of a supporting tool to
automatically guide one to gradually formalize the specification. &nbsp;In
this paper, we put forward a pattern-based approach to dealing with
this challenge. It adopts the three-step approach in SOFL (Structured
Object-oriented Formal Language) [3], which builds specification
through informal, semiformal and formal stages. Based on a set of
inter-related patterns, guidance will be generated for specifying
functions in terms of pre- and post-conditions step by step from
semi-formal to formal stage, which enables developers to work only on
the semantic level without struggling with complicated formal
notations. These patterns are pre-defined, each providing an informal
expression to describe certain function and the formalization method
of such expression. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Although
</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">researchers
proposed many patterns to help handle commonly occurred problems on
</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">specification
constructions, such as the well-known design patterns [4], developers
have to understand the provided solutions before they can apply</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">them
to specific problems. By contrast, our patterns are hidden from
developers; it is the understandable guidance that interacts with
developers, which is produced based on patterns in our approach.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Such
process is not expected to be fully automatic due to the need for
human decisions, but it is expected to help the developer clarify
ambiguities in the informal expression and select appropriate formal
expressions. &nbsp;Konrad et al. [10] created real-time specification
patterns in terms of three commonly used real-time temporal logics
based on an analysis of timing-based requirements of several
industrial embedded system applications and offered a structured
English grammar to facilitate the understanding of the meaning of a
specification. This work is complementary to the notable Dwyer et
al.’s patterns here it is: </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">In
spite of enthusiasm in academics, specification patterns are not yet
widely utilized in industry mainly because of the difficulties in
applying them. As can be seen from the related work, the patterns
they established force their users to make a full understanding of
them before selecting and applying appropriate ones. Statistical data
shows that large amount of patterns have been developed, whereas
users may not fully understand how to leverage them in practice Our
approach treats patterns as knowledge that can be automatically
analyzed</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">by
machines to generate comprehensible guidance for users. Thus,
developers need neither to be educated on the patterns nor to be
trapped in tedious and sophisticated formal notations; they can only
focus on function design and make critical decisions on the semantic
level. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">To
avoid potential errors in specifications, each designated value v is
required to be legal, which means v is a combination of constants and
variables that can be found in the data definition part of the
specification. After all the elements are legally specified, a
concrete constituents is obtained where each element is bounded with
a concrete value. If the user is not familiar with the pattern
notation, he will only be required to provide a general intention
first by selecting patterns. This task is easy because: (1) pattern
names are written in natural language and allows the selection to be
easily done on semantic level, (2) the unique meaning of each pattern
name differentiates itself from others and therefore avoids wrong
selection, (3) the</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">explanation
items can help confirm the decision. Once the semi-formal elements of
p have been specified, a corresponding informal expression is
generated automatically on the basis of the syntax item of p and
added to the corresponding pre- or post-condition. Advanced users can
choose to directly write expressions in pattern notation for pre- and
post-conditions. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">according
to the formalization result it maps to, alter( ̃account store) is
formalized into:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">let
x inset &nbsp;̃obj and x.accountN o = inf</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">in
union(dif f ( ̃obj, {x}), alter(x, f alse, N ull, N ull,
originBased(alter)))</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">nonsense
paper</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Integrating
UML and Formal Methods</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">UML
is a widespread language used in both industry and academia, despite
the fact that its semantics is still informal and allows ambiguities.
On the other hand, OhCircus is a formal specification language which
unifies Z, CSP, the refinement calculus of Morgan and object-oriented
theories. In this work we integrate UML class diagrams and OhCircus
by written UML elements in terms of OhCircus constructs. However,
instead of a simply syntactical mapping, we also propose the concept
of a class model to capture associations and global constraints.
Finally, we use this integration to prove the refinement of
associations as attributes, a result that relates analysis to design
to implementation and which is very common in industry. As informal
notation, UML [18,20] deserves special attention. UML has become a de
facto standard; nevertheless it can also express ambiguities and is
insufficient to represent even simpler properties, as pointed out in
[19].</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">OhCircus
[4] was chosen as our formal language because it has an intuitive
representation of constructions like classes and inheritance and is
based on a refinement theory. Furthermore, OhCircus is a language
which integrates well-established concepts on the formal community:
the model-based language Z, the process algebra CSP [22], the
refinement calculus, and object-orientation, providing an unified
language of classes and processes.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Our
goal in this work is the translation of UML class diagrams elements
into OhCircus constructs. &nbsp;← oh darn, only static structure</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Class
diagrams are the most common diagrams used in software development
projects. They model concepts from the domain of the application and
the structural aspects of the system using classifiers and
relationships as their building blocks. They are also named static
view, representing information that never changes.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
particular, the attempts of integration between Z and process
algebras (CSP-Z, CSP-OZ [8]) consider state and communicating aspects
of concurrent systems in an unified language, taking advantage of the
existing theories and tools. A similar formalism is Circus [31],
which proposes a refinement calculus to that integration. Moreover,
it is familiar to those who knows Z and CSP and enables the reuse of
existing and well-established tools, like FDR [10] and Z/EVES [24].
OhCircus is an extension of Circus which adds classes, inheritance,
dynamic binding and other features from the object-oriented paradigm.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">[...static
parts transformation bullshit...]</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
direct consequence of the mapping we have proposed is the ability to
explore UML refinement in formal ways: refinement of UML models can
be assured by data refinement in OhCircus. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">bullshit
the rest really..</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Specification
and Formal Verification Of Temporal Properties of Production
Automation Systems (2004)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
focus on the graphical MFERT notation and RT-OCL (Real-Time Object
Constraint Language) for the specification of state-oriented
real-time properties. RT-OCL is an extension of the Object Constraint
Language (OCL) that is part of the Unified Modeling Language (UML).
We introduce the formal semantics of RT-OCL based on a formal model
of UML Class and State Diagrams and provide a mapping to temporal
logics. The applicability of our approach is demonstrated by the case
study of a manufacturing system with automated guided vehicles.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">However,
due to the complexity of those systems, simulation can never provide
coverage for complete verification for those systems. &nbsp;The model
checker returns either ‘true’ or generates a counter example in
cases when the model does not satisfy the property. The counter
example demonstrates an execution of the model that leads to a
situation which falsifies the property. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
most remarkable advantage of model checking is that the task of
verifying is fully automated. However, model checking has two main
obstacles in practical application. The first one is the state
explosion problem in dependence to the number of possible inputs. The
second one is due to the specification of properties in temporal
logics, since it often turns out that designers and programmers are
not familiar with formal methods and regard it as a task too
cumbersome to specify and understand properties in temporal logics.
For production automation systems, the correct time-critical behavior
of required properties is of particular interest. This is already
important in early phases of development to avoid expensive and
time-consuming changes to the system under development at later
stages. Though classical model checking is mainly for the
verification of cycle-accurate behavior without timing properties,
there are a few tools like the RAVEN model checker [36] that support
the formal verification of time-annotated system models and
additionally provide basic timing analysis.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
main idea was that in a first step the designer specifies a model in
a graphical specification language, namely MFERT. The model, i.e.,
the MFERT description, is then translated into an annotated state
machine-based formalism (i.e., I/O-Interval Structures [38]) for
model checking. Additionally, properties are specified and translated
into temporal logics (i.e., Clocked Computation Tree Logic, CCTL
[37]) for formal verification with the RAVEN model checker</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">OCL
was introduced as a language for the specification of constraints in
the context of the Unified Modeling Language (UML) de-facto standard
[29], focusing on Class Diagrams and on guards in behavioral
diagrams. The syntax of OCL comes in a ‘programmer-friendly’
style using dot-notation and operation calls as known from
object-oriented languages. With the wide acceptance of UML, OCL has
also received a considerable visibility. However, OCL currently lacks
sufficient means to specify constraints over the temporal behavior,
i.e., the evolution of state activations and state transitions as
well as timing constraints. Since it is essential to be able to
specify such timing constraints for time-dependent systems to
guarantee correct system behavior, we developed an OCL extension,
i.e., RT-OCL, that overcomes this limitation and at the same time
keeps compliant with the syntax and semantics of the latest version
of OCL, i.e., Version 2.0. To seamlessly integrate RT-OCL with the
domain-specific language MFERT, we defined UML Profiles for both
MFERT and RT-OCL and defined mappings to the formal means of
I/O-Interval Structures and CCTL, respectively. CCTL was introduced
by Ruf and Kropf in [37] for the specification of properties over I/O
Interval Structures. CCTL formulae are composed from propositions
denoting predicates in combination with Boolean connectives and
time-annotated temporal operators. The temporal CCTL operators build
upon the common CTL operators and are annotated by timing intervals,
such as AF[a,b]. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Several
approaches to support property specification have been developed. In
the following subsections, we distinguish the areas of (a)
pattern-based specification, (b) graphical property languages, and
(c) temporal extensions of OCL. ← for future work and meeting!
Basicalyl these are the different types of support for property
specification. Except for (c) </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">To
support temporal logic property specification, some approaches
identify patterns which provide the user with structured application
of formulae. First attempts in pattern classification led to
taxonomies that coarsely distinguish between safety and liveness
properties. A detailed pattern-based classification is published by
Dwyer et al. in [14]. That pattern system is based on the
investigation of more than 500 examples for property specification
and presents a semantically ordered hierarchy of property patterns.
For instance, absence, eventual existence, and global existence of
states/events are combined as so-called occurrence patterns.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
idea of patterns was adopted not just to classify but also to
construct specifications for finite state verification. In a more
general approach of natural language oriented specification, the
PROSPER project aims at the specification through an English language
subset In the early phases of the GRASP project, we developed an
interactive visual framework that employs structured English
sentences [23] as given in Figure 2. Compared to other pattern-based
approaches, we provide a richer set of specifications, in particular,
as we additionally cover explicit timing annotations.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
contrast to temporal logic formulae-based approaches, non-experts can
more easily capture the </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">final
sentence in structured English than just by CTL or LTL. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">However,
it turned out that this </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">approach
leads to quite long sentences and remains too cumbersome for more
complex applications, so that we started to investigate alternative
approaches.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Regarding
property specification by visual means we can distinguish two
different kinds of approaches. The first ones are still syntactically
based on CTL or LTL specifications. Those frameworks provide support
to visually compose segments of specifications, e.g., by enabling and
disabling parts of specifications during the development process. To
create specifications with this approach, the user must know how to
apply and to control temporal logic formulae. Other approaches have
an abstract graphical notation, which is translated to temporal logic
formulae before checking. Examples are Symbolic Timing Diagrams
(STDs) [15] and Life Sequence Charts (LSCs). Ramakrishnan et al. [30]
extend the OCL syntax by additional grammar srules with unary and
binary future-oriented temporal operators (e.g., always and never) to
specify safety and liveness properties.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Distefano
et al. [13] define Object-Based Temporal Logic (BOTL) to facilitate
the specification of static and dynamic properties. BOTL is not
directly an extension of OCL. It rather maps a subset of OCL into
object-oriented CTL. Bradfield et al. [2] extend OCL by useful
causality-based templates for dynamic constraints. A template
consists of two clauses, i.e., the cause and the consequence. The
cause clause starts with the keyword after followed by a Boolean
expression, while the consequence is an OCL expression prefaced by
eventually, immediately, infinitely, etc. The templates are formally
defined by a mapping to observational μ-calculus, a two-level
temporal logic with OCL on the lower level.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">An
MFERT model is based on production elements and production processes.
Production elements represent objects whose properties are changed by
processes and transformations. Properties of production elements are
described by attributes. A production element obtains its own
identity, composed out of the description and the element’s
correlative status. In that context, recall that the model checker
RAVEN is able to verify whether a model (a set of I/O-Interval
Structures) satisfies a given property (a CCTL formula)</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
Object Constraint Language is an integral part of UML [29, Chapter
6]. OCL constraints are defined over a given UML model to restrict
the values of object properties. OCL is mainly applied to define
invariants for classes and pre- and postcondition of operations. As
OCL is a declarative expression-based language, evaluation of OCL
expressions does not have side effects on the corresponding UML
model. ← for future work?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Standard
OCL currently lacks means to specify constraints over the dynamic
behavior of a UML model. Constraints covering the consecutiveness of
states and state transitions as well as time-bounded constraints
cannot be defined. &nbsp;← for future work? </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">More
recently, in reply to the OMG’s OCL 2.0 Request for Proposals, the
extensive OCL 2.0 language proposal by Ivner et al. [25] became
available, which addresses a seamless integration of OCL to relevant
parts of UML. In October 2003, this proposal has been adopted by the
OMG as the official OCL 2.0 Specification [28]. Based on the
metamodel provided in these documents, we developed a more
lightweight approach by defining a UML Profile for our temporal OCL
extension [22].</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">While
the syntactic integration of the temporal OCL extension is
straightforward, the definition of the semantics needs more
investigation. The OCL 2.0 specification provides extensive semantic
descriptions by both a metamodel-based as well as a formal
mathematical approach, but unfortunately, those are currently neither
consistent nor complete [18]. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">However,
this information is not sufficient to evaluate OCL expressions, as
system states do not comprise currently activated states and messages
that have been sent. We therefore have to extend the formal model and
system states accordingly, such that the resulting extended object
model M. The final formal semantics for our temporal OCL expressions
is given in [22, 17]. While those articles also provide a general
mapping to CCTL formulae, we here give some typical specification
examples in the next section.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Further
examples of time-bounded state-oriented OCL constraints in the
context of other UML and MFERT models can be found in [20, 4, 17]. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">In
[21], we additionally demonstrated that it is possible to express the
property specification patterns of Dwyer et al</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">.
[14]</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
approach demonstrates that an OCL extension by means of a UML Profile
towards temporal real-time constraints can be seamlessly applied on
the M2 layer of UML, i.e., the OCL metamodel. Nevertheless, some
extensions have to be made also on the user model level (i.e., M1
layer) in order to enable modelers to use our temporal OCL
extensions. The presented extensions are based on a future-oriented
temporal logic.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">A
Formal Semantic for Scenario - Based Model Using Algebraic Semantics
Framework for MOF (January 2013!) ← WTF is this work!?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">However,
these concepts, especially within MOF standard, are not yet formally
define which will be difficult to check the consistency between
metamodel and models. Therefore, defining a formal semantic for
MOF-based metamodel is essential for discovering the meaning of the
model and to ensure a structural and behavioral conformance between
metamodel and its model. In this paper, we define a formal semantic
for a scenario-based model called Performability Failure Behavior
Awareness Metamodel (PerFAM) by applying algebraic semantics for MOF
framework which provides a formal stage: metamodel, model and model
conformance. For this purpose, a formal consistency checking can be
applied as to ensure the accuracy of the produced model towards its
metamodel. ← bad english</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">However,
the MOF framework does not provide a standard notion for formally
defining the metamodel semantics in a systematic way However, when
the metamodel is not formally defined in the syntax and semantic
definition, problems such as misinterpretation of models among
developers cannot be avoided [4]. This problem could cause some
metamodel derivation problems when interpreting from a metamodel to
its model. Therefore, it is important to have a formal semantic for
metamodel and models so as to ensure the consistency for models
production from its metamodel and the correctness of system design.
The PerFAM model [5] is an intermediate model, between the UML
sequence diagram and analysis model (DTMC, Petri Nets, etc.). This
model provides a modeling view for performance and reliability
aspects, particularly for outlining failure behavior of timing
requirements. The idea is underlying in model-driven development
where the UML sequence diagram with performance annotation from MARTE
profile is then transformed into a PerFAM model for performance and
reliability viewing models. The PerFAM model is then transformed into
analysis model for in depth analysis. Figure 1 shows the PerFAM
metamodel and its model in Figure 2.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
formal semantic for both PerFAM metamodel and model is needed to
ensure that the consistency of model inheritance conforms to its
metamodel. The formal semantic can also provide the accuracy of the
model and provide for the development of a tool support. MOF is a
semiformal approach to define a modeling language. Generally, this
framework consists of three levels of notions, namely, metamodel,
model and model conformance. The metamodel is usually described as a
data or theory. However, at present, the MOF based metamodel lack of
mathematical representations as to provide the accuracy of the
metamodel towards its model. Therefore, this framework provides two
additional notions of metamodels called metamodel realization and
model type. A metamodel realization enables a precise mathematical
representation for metamodel using MEL theory to describe its model
types. The formal semantics for the PerFAM metamodel are defined
within the context of its metamodel elements, action, data types,
attributes and associations. Thus, from this metamodel, we can define
the formal semantics for its correspondence model contributing to
concrete syntax, system and configuration state.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">[...afterwards
the rest is “what the fucking fuck”...]</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
main contribution of the paper is a systematic approach for defining
the PerFAM formal semantics by partitioning the PerFAM metamodel, the
PerFAM model and its model conformance. In this respect, we use the
algebraic semantics for MOF framework to define a formal semantic for
PerFAM where this framework is established within three semantic
notions, namely, metamodel, model and model conformance. In order to
ensure the consistency of model generation from its corresponding
metamodel, a model conformance is defined as checking the consistency
of its syntax and semantic. The main advantages of our contributions
are the formal semantics that we proposed which can be used to check
the correctness of the developed model, as well as its model
conformance. In particular, these formal semantics open up a wide
opportunity for model-driven development in terms of tools support
for model development. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">No
tool support yet, planned in future work (systematically check the
consistency between a PerFAM metamodel and models during the system
design process.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Semantics
of UML models for dynamic behavior: a survey of different approaches</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">I
should pick one in which my approach fits? When choosing a modeling
language and accompanying semantics, a number of things need to be
taken into consideration, such as who are the users of the models,
what is the purpose of the models, what kind of application is being
modeled, and what are the essential features that must be captured
When modeling embedded systems, an essential aspect is the
interaction between hardware and software. Hence, we need to capture
the behavior of the hardware and software components. For capturing
the dynamic behavior of components, modeling languages like UML
sequence diagrams, state machines and similar notations are often
used. This paper surveys different approaches to formally capturing
the semantics of models expressed using languages of this kind. Some
models are intended to be processed automatically, for example by
code generators or model checkers, while other models are used as an
aid in communication between for example system developers and client
representatives. The semantics given for the languages range from
natural language explanations of modeling language constructs and
examples to highly formal mathematical or logical definitions.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Another
question is: What is the purpose of the models? If the models are to
be used for giving formal proofs of system properties, then the
language must be supported by a formal semantics defined in clear
mathematical or logical terms. If the models will be used for code
generation or automatic model checking then we need to ensure that
the semantics can also be processed by a computer. On the other hand,
if the models are intended for communicating with client
representatives then a natural language explanation of the language
features may be appropriate.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">A
third question is: What kind of system is being modeled, and what are
the essential features or properties that need to be captured by the
models? For example, capturing real-time requirements may be
essential when modeling an emergency communication network, but of
little importance when designing a chocolate automaton. ← for ppt</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">For
capturing dynamic component behavior, modeling languages like UML [1]
sequence diagrams and state machines are currently the most highly
profiled. ← for ppt</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">This
paper surveys approaches to giving formal semantics to models
expressed in UML sequence diagrams, state machines or similar
notations, such as MSC [2], LSC [3], the Statecharts language [4],
SDL [5], etc. An overview is given of different types of semantics
and their strong and weak points. The survey is not exhaustive, but
covers the most common variants. The survey does not address
semantics for hybrid models which is a field in its own</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">A
model is a description of a system in some modeling language, such as
the UML. The semantics of a model explains what the model means. More
exactly, the semantics of a model is a function mapping the
syntactically well-formed models of the modeling language into
syntactically well-formed expressions in a language that is well
understood. What is a well-understood language depends on the
intended users of the semantics. It often makes sense to define
several equivalent semantics for the same modeling language; for
example, an axiomatic semantics for logical deduction, a denotational
semantics for mathematical reasoning, an operational semantics for
building tools, and a natural language semantics to explain the
language to its end-users. ← for ppt! ZAPAMTI!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Finally,
there is the issue of the kinds of features or properties that can be
captured by the modeling language. Properties can be categorized
according to the basis on which they are falsified: Properties that
can be falsified on the basis of a single trace are called trace
properties, while properties that are falsified on the basis of a set
of traces are called trace-set properties [8].4 Examples of trace
properties are safety and liveness [9, 10], while permissions often
used in relation to policies and many information flow properties are
examples of trace set properties. Most modeling languages are
well-suited to capture trace properties, but only some allow us to
specify trace-set properties as something distinguishable from
underspecification. Distinguishing trace-set properties from
underspecification is necessary since trace-set properties should be
preserved</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">under
refinement while this is not the case for underspecification. ← for
future work!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Hence,
a formal semantics is needed for the development process. There are,
however, different styles of formalizing semantics, each with their
strong and weak points. For the graphical modeling languages we are
concerned with in this paper, denotational and operational semantics
are the most relevant styles. The </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">denotational</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">semantics</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">method
maps a program directly to its meaning, called its denotation. The
denotation is usually a mathematical value, such as a number or
function. No interpreters are used; a valuation function maps a
program directly to its meaning. The basic idea is to give a
denotation to every element of the language. This means to map the
syntactical expressions of the language to a well-known domain.
Denotational semantics typically allows a fairly abstract system
description. As they also build on known domains, they are well
suited for mathematical reasoning and formal proof of properties. On
the negative side, a denotational semantics provides little guidance
for tool developers and will typically be too complex for users.
Expressing states and operations is usually difficult with a
denotational semantics. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
operational semantics method uses an interpreter to define a
language. The meaning of a program in the language is the evaluation
history that the interpreter produces when it interprets the program.
The evaluation history is a sequence of internal configurations. As a
methodology for language development he suggests that “a
denotational semantics is defined to give the meaning of the
language” and that “the denotational definition is implemented
using an operational definition”.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">An
operational semantics of a programming language is one that defines
not the observable overall effect of a program but rather suggests a
complete set of possible individual steps which may be taken in its
execution. The observable effect can then be obtained by embedding
the steps into an iterative loop.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Major
advantages of operational semantics is that such semantics provides
good formalization of implementation and is well suited for building
tools. It is also typically well suited for state-based languages. On
the other hand, operational semantics tends to be very detailed, and
it is often difficult to derive formal proof from operational
semantics. Besides, an operational semantics relies on the underlying
semantics of the abstract computer on which the interpreter is
assumed to run</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
1996, a new MSC standard was defined, called MSC-96 [20]. In this
standard, high-level constructs and high-level MSCs were introduced,
a kind of diagrams that show how control flows between basic MSCs.
Further an event-centric textual syntax7 and a new semantics were
defined [21]. This semantics is also a kind of process algebra, but
holds substantial differences from the MSC-92 semantics. Finally, the
MSC-96 standard was revised in 1999 and became MSC-2000 [2], but kept
the MSC-96 semantics.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
UML standard defines the semantics of sequence diagrams informally.
Most notably, this is a trace-based semantics: Basic trace model: The
semantics of an Interaction8 is given by a pair [P, I] where P is the
set of valid traces and I is the set of invalid traces. P ∪ I need
not be the whole universe of traces.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">A
trace is a sequence of event occurrences denoted {e1, e2, ..., en}</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
the following we present briefly different denotational (like trace
semantics?) and operational semantics of sequence diagrams and
similar notations. The STAIRS semantics [28, 29] is a trace based
formalization of sequence diagrams based on an extension of the
semantic model of the UML standard, and hence distinguishes between
positive, negative and inconclusive traces. But instead of a single
pair (p, n) of positive and negative traces the semantic model of
STAIRS is a set of pairs {(p1 , n1 ), . . . , (pm , nm )}. Such a
pair of sets of traces (pi , ni ) is referred to as an interaction
obligation. The word “obligation” is used in order to emphasize
that an implementation of a specification is required to fulfill
every pair captured by the specification. This semantic model makes
it possible to define trace-set properties. Refinement is defined as
refinement of each interaction obligation, and refinement of
interaction obligations is defined as reducing the set of positive
traces by making them negative and reducing the set of inconclusive
traces by making them positive or negative. In [27], Kruger defines a
variant of Message Sequence Charts that is supported by formal
definitions of the semantics, as well as refinement relations. The
semantics is defined in terms of streams, which consist of a sequence
of system channel valuations and a sequence of state valuations. A
system is represented semantically by a set of streams, and the
existence of more than one stream indicates nondeterminism.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Storrle
[30, 31, 32] defines a denotational trace based semantics for UML 2.x
sequence diagrams that is quite similar to the STAIRS semantics.
Among the notable differences are that St ̈rrle does not treat
choices as underspecification. Further, S ̈rrle gives a different
treatment of negative behavior where sequence diagrams are not
allowed to be inconsistent and the negative operator can indirectly
specify positive traces. Refinement is defined, but are more
restricted as there is no treatment of underspecification in the
semantics. Cengarle and Knapp [33] defines denotational semantics for
UML 2.x sequence diagrams. Their denotational semantics is trace
based and similar to STAIRS and the semantics of St ̈rrle with
respect to the positive parts of sequence diagrams. In difference
from STAIRS and St ̈rrle, they make a prefix closure of negative
traces, but does not allow inconsistent sequence diagrams. Their
refinement relation differs from STAIRS in that the set of
inconclusive traces may be increased, something which is a problem
with respect to the monotonicity of the composition operators.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
[34], K ̈ ster-Filipe gives an LSC inspired denotational semantics
of UML 2.x sequence diagrams based on partially ordered sets. The
partially ordered sets of sequence diagrams is used to build event
structures, and modal logic constraints over these event structures
are used to express negative behavior, as well as must and may
behavior.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">[
Denotational Semantics with Time... ← don’t care much, skipping]</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Performance
Message Sequence Chart (PMSC) [41, 42] extends MSC with syntactic
constructs for expressing performance requirements. The aim is to
integrate performance characteristics, such as response time and
throughput, in functional specifications. &nbsp;Sets of acceptable
probabilities, rather than a single probability, can be assigned to
alternatives. Hence, it is possible to express requirements such as
“the probability of receiving a reply within 5 seconds after
sending a request should be at least 0.9” or, for a machine
simulating a coin toss, “the probability of getting a heads outcome
should be between 0.4 and 0.6”</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Operational
Semantics:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">MSC-92
has a lifeline-centric syntax and its semantics is based on
characterizing each lifeline as a sequence (total order) of events.
These sequences are composed in parallel and a set of algebraic rules
transforms the parallel composition into a structure of (strict)
sequential composition and choice. The causality of messages is
obtained by a special function that removes from the structure all
paths that violate the invariant. In a way this semantics is not a
proper operational semantics since a diagram first has to be
transformed into the event structure before runs can be obtained.
This transformation replaces parallel composition with choice and
hence creates an explosion in the size of the representation of the
diagram. In addition, the lifeline-centric syntax is not suitable for
defining nested high-level constructs. Compared to UML semantics, the
most notable thing about this semantics is that it has no notion of
negative behavior, and therefore also makes no distinction between
negative behavior and inconclusive behavior (behavior that is neither
positive nor negative). This is no surprise since MSC does not have
the negative operator of UML 2.x. The only available meta-level is a
flat transition graph, and this does not give sufficient strength to
extend the semantics with negative behavior. Nor is it possible to
define trace-set properties over this transition graph. The semantics
has no explicit communication medium; the communication model is
“hard-coded” in the semantics by the “generalized operators”
and does not allow for variation.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">However,
the semantics is heavily based on synchronization of lifelines on the
entry of referenced diagrams and combined fragments and diverges in
this respect from the intended semantics of MSCs and UML sequence
diagrams. Further, the same strategy as for the MSC-92 semantics is
applied; interleaving is defined by means of choice, and the message
invariants obtained by removing deadlocks. This results in an
unnecessary amount of computation, especially in the cases where we
do not want to produce all traces but rather a selection of the
traces that a diagram defines. ← for ppt?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Realizability
of MSCs is the focus of both [36, 52] and [53]. They define synthesis
of MSC to concurrent automata and parallel composition of labeled
transition systems (LTS), respectively. (Each lifeline is represented
as an automaton or LTS; the lifelines are then composed in parallel.)
Further they define high-level MSCs as graphs where the nodes are
basic MSCs. In addition, [53] defines both syntax and semantics for
negative behavior. In both approaches the translation of high-level
MSCs to concurrent automata/LTSs </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">removes
the semi-global nature of choices in a specification (YES)</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">,
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">and
the high-level MSC graphs are nonhierarchical, disallowing nesting of
high-level operators (NOO)</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">.
In [53] communication sis synchronous ← for ppt? Ne valja ova a?</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Petri
Net semantics: one approach does not allow for nesting of high-level
operators; another one:translation of the choice operator is
sketched, but no loop defined; yet another one: semantics </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">for
UML 1.x sequence diagrams is presented, but as with the Petri-net
semantics of basic MSCs it </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">has
major limitations </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">How
about this? sounds a bot like my approach ppt:</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Jonsson
and Padilla [59] present a semantics for MSC which is based on
syntactic expansion and projection of diagram fragments during
execution. Each lifeline is represented by a thread of labels where
the labels refer to events or diagram fragments. The threads are
executed in parallel and when a label referring to a fragment is
reached the fragment is projected and expanded into the threads.
Expansions may happen at arbitrary points since there are no rules in
the semantics itself for when to expand. This creates a need for
execution strategies, and the approach may be seen as having an
informal meta-level where</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">ad
hoc strategies are described. However, if completeness is to be
ensured, or if the semantics is to be extended with negative behavior
or trace-set properties, this meta-level must be formalized. The
semantics requires explicit naming of all diagram fragments and this
yields an unnecessary complicated syntax. It sdoes not have an
explicit communication medium; the communication model is
“hard-coded” into the semantics and does not allow for variation
In [62, 63] an operational semantics for UML 2.x sequence diagrams
that is equivalent to the denotational semantics defined in [33] (see
above) is given.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">This
operational semantics has some similarities to the operational
semantics of [60, 61]</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">;
for every execution step an event is produced and at the same time
the syntactical representation of the diagram is reduced by the
removal of the event produced. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">Contrary
to [60, 61], their semantics treats sequence diagrams as complete
specifications (with no inconclusive behavior)</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">.
The rules are defined so that a given diagram produces a set of
positive and negative traces that together exhaust the trace
universe. The negative operator is replaced by a “not” operator.
This operator is defined so that the sets of positive and negative
traces are swapped, with the result that specifying some behavior as
negative means also specifying the complement of this behavior as
positive. ← for ppt!!! (this is the paper “Operational Semantics
of UML 2.0 Interactions” from Alex. Knapp ← I already have a
paper from this author, maybe for ppt mention that your underlying
semantics shares similarities)</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
[64], Cavarra and K ̈ster-Filipe present an operational semantics
for UML 2.x sequence diagrams inspired by Live Sequence Charts (LSC)
(see below). The arguments of choices have guards and there is
nothing to prevent the guards of more arguments in a choice to
evaluate to true. In this case the uppermost operand will be chosen,
which means that the choices essentially are treated as nested
if-then-else statements and may not be used for underspecification.
Each lifeline is executed separately which means that synchronization
at the entry of choices is necessary to ensure that all lifelines
choose the same operand. They also make the same assumption about
negative behavior as in LSCs, that if a negative fragment is
executed, then execution aborts. Grosu and Smolka [“Safety-Liveness
Semantics for UML 2.0 Sequence Diagrams”] provide a semantics for
UML 2.x sequence diagrams based on translating the diagrams to Buchi
automata. The approach is based on composing simple sequence diagrams
(no high-level operators) in high-level sequence diagrams
(interaction overview diagrams), where a simple diagram may be a
positive or a negative fragment of the high-level diagram it belongs
to. Positive behavior is interpreted as liveness properties and
negative behavior as safety properties. Hence, for a high-level
diagram two B ̈chi automata are derived; a liveness automaton
characterizing the positive behavior of the diagram and a safety
automaton characterizing the negative behavior. The diagrams are
composed by strict sequencing rather than weak sequencing, and hence
has implicit synchronization of lifelines when entering or leaving a
simple diagram.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
this section we present some of the approaches that have been taken
for assigning formal semantics to models expressed in UML state
machines and similar languages. An example of an approach that uses
abstract state machines is [85], which employs multi-agent abstract
state machines to model the dynamic semantics of UML state machines.
Their model is intended to define rigorously the UML event handling
scheme so that semantic variation points become explicit, while
reflecting the original structure of UML state machines. Furthermore,
object interaction is formalized by combining control and data flow.
This work is further extended by the authors in [86] to cover
concurrent states, while [84] surveys their previous work in order to
further discuss semantic variation points and unclarities of UML
state machines from a formal point of view.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
[87], J ̈rjens extends the semantics given in [85, 86] by modeling
actions, internal activities, and their operations and parameters
explicitly, as well as providing message passing between different
diagrams. This constitutes a further step toward formal modeling of
complete UML specifications and the goal of executable UML
specifications. A thorough presentation of J ̈rjens’ work on
formalization of UML is given in [88], which provides a formal
semantics for UML state machines (as well as other UML languages such
as sequence diagrams and static structure diagrams) in terms of
so-called UML Machines and UML Machine Systems. UML Machines are
inspired by abstract state machines; they are transition systems
whose states are algebraic structures. In addition, UML Machines have
built-in communication mechanisms similar to the corresponding
mechanisms in UML. UML Machines interact by exchanging messages which
are dispatched from (or received in) multi-set buffers called output
queues (or input queues). Based on UML Machines, [88] defines
refinement relations, as well as security properties such as
integrity and authenticity, and provides proofs of preservation of
security properties under refinement.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Table
4.2 (important, print!)</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">,
we see that most of the approaches are evaluated to support
underspecification. The general rule is that an approach providing an
explicit mechanism for specifying nondeterministic choice supports
underspecification, unless such choices are interpreted as must
behavior, </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
final evaluation criteria we want to comment upon is the support for
incomplete models. This is difficult to assess, as we can always
choose to interpret a sequence diagram as an incomplete model. The
evaluation was therefore based on the approaches’ treatment of
negative behavior, their support for existential behavior, and their
definitions of refinement. ← for ppt!</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">A
few comments to Table 4.3 are also needed. First, we notice that none
of the approaches capture incomplete models. The reason is that state
machines, unlike sequence diagrams, focus on describing a single
component rather than an interaction scenario. All state machine
variants we are aware of describe only the behavior that the
component may exhibit; behavior not explicitly described is negative
in the sense that it should not occur. There is, therefore, no
explicit operator for expressing negative behavior, and all behavior
is either positive or negative – there is no inconclusive behavior.
</SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">As
the evaluation reveals there is no lack of approaches to formal
semantics for UML sequence diagrams and state machines, and many of
these have desirable properties. We do not proclaim a winner, but we
have established that formal semantics of relevant modeling languages
are readily available for the developers of embedded systems. We have
not evaluated to what degree the approaches presented in this paper
are supported by suitable tools, nor to what degree they have been
put to practical application. Still, judging from our evaluation,
there should be a large potential for applying UML models supported
by formal semantics in the development of embedded systems. It is up
to developers to choose a suitable approach based on the nature of
the system to be developed, and the background and experience of the
development team. ← for ppt!!!!!!!!!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">UML
2 Interaction Overview Diagram Validation</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">UML
2 interaction overview diagram, IOD for short, is a variant of UML
activity diagrams where the nodes may be interaction diagrams.
Introduced on the UML 2 version, this diagram gathers benefits
related to specific and global behaviors. When the nodes are sequence
diagrams, it allows a valuated control flow specification. ← for
ppt? or future work?</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">We
propose in this paper an approach to validate the IOD notation. The
validation is made by model checking using the hierarchical Petri
nets derived from the IOD diagrams. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Even
though the lack of semantics is even advocated as a beneficial
ingredient for the usefulness of the UML, checking the model
correctness requires a formal semantics for the notation. UML 2.0
[11] brought more precision on UML 1.x. but it remains informal and
lacks tools for automatic analysis and validation ← for ppt!</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Many
works have already dealt with the semantics of UML 2 activity and
sequence diagrams [1], [3], [4], [5], [9], [15]. However, only few
works results are communicated on the formalization of the overview
interaction diagram which may be used to combine interactions into a
kind of dataflow reminiscent of activity diagrams, where the places
of activity states are taken by interactions. We aim at formalizing
the IOD by mapping it into a formalism which complies on one hand
with its nature and on the other hand with its structure.
Hierarchical Colored Petri nets (HCPNs) seem to be convenient to this
purpose. The derived HCPNs are analyzed by means of PROD [13], a
model checker tool for predicate/ transition nets.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
stronger side of the IOD is the fact that it can show dependence
between the important sequences of a system, which can be presented
by an activity diagram. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
used notation incorporates constructs from sequence diagrams with
fork, join, decision and merge nodes from activity diagrams. IODs are
special kinds of activity diagrams where the activity nodes are
actions or interactions and the activity edges denote control flow
only.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
idea behind HCPNs theory is to allow the construction of a large
model by using a number of small Petri nets, called pages, which are
related to each other in a well-defined way. In a HCPN, the Petri net
framework is represented by means of a net called prime page where
some transitions called substitution transitions abstract subnets
called pages. Each substitution transition is surrounded by places
called In/Out-port places. The latter constitute the interface
through which the page communicates with its surroundings. The idea
is analogous to the hierarchy constructs found in many graphical
languages such as IODs. At one level, a simple description of the
modeled activity is given without having to consider internal details
about how it is carried out. At another level, the more detailed
behaviour is specified. Moreover, the detailed specification is
integrated with the more crude description and this integration is
done in such a way that it becomes meaningful to speak about the
behaviour of the combined system</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">For
formalizing the IOD by mapping it into a formal semantic domain, it
is convenient to opt for a language that supports hierarchical
modeling. HCPNs appear to be suitable for this purpose. Thus, we
propose to liken the IOD to a HCPN prime page and the interaction
nodes to HCPN pages abstracted by means of substitution transitions.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Table
1 shows the transformation of the IOD constructs into HCPNs. For each
IOD construct, it yields the equivalent HCPN construct expressed by
an intuitive transformation as well as a more formal transformation.
← for future work, how I should formalize?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">For
a more precise validation, specific properties of the system can be
written by the designer in Linear temporal Logic (LTL) or
Computational Tree Logic (CTL) and then, verified by PROD. Since the
main motivation of this work is that the UML designer may reach a
valid modeling without needs for knowledge of formal techniques, it
is only reasonable that the properties are expressed by the modeler
in the OCL language [12] and afterwards, are automatically translated
in LTL and CTL logics.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">OCL
which is a part of UML for the expression of constraints over UML
models, in particular invariants, is appropriate to data value
handling. The IOD data is extracted from the interaction nodes
described by sequence diagrams. This data provides the HCPH initial
marking. However, OCL does not support the expression of temporal
properties. So, to deal with an appropriate translation of OCL into
the temporal logic supported by the model checker PROD, we first
propose to extend OCL with temporal operators and then to translate
it into LTL and CTL logics. This work is presented in [2].</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">To
test the derivation approach, we built a translator whose semantic
functions are drawn from the conversion rules we have set. We also
developed a graphic interface for the construction of the IOD
diagram. This diagram constitutes the input of the translator whose
outputs result into predicate/transition nets specified in PROD
syntax, see figure 3. Afterwards, PROD was executed to verify the
Petri net specification. The basic properties defined above, were
first checked and then, some system’s invariants were expressed in
OCL, translated into LTL properties and then verified on the HCPNs.
Many works tackled the formalization of the sequence and activity
diagrams separately.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
first and more important research papers on the UML 2 activity
diagrams are those of Störrle. He analyzed in minute detail the
semantics of these diagrams and proposed an approach to their
formalization</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">[15].
More recent studies carried out by Staines [14] states that UML 2
activity diagrams are based on Petri nets. &nbsp;In spite of the
research extent on the activity diagrams, no investigation is
undertaken on the interaction overview diagram. The only work we
encountered is the one of Kloul and Küster-Filipe [8] who show how
to model mobility using IODs and propose a formal semantics to the
latter by translating them to the stochastic process algebra PEPA
nets. The translation abstracts the object behavior inside an IOD
node - a sequence diagram in occurrence - reducing it to a typed
token. Therefore, the hierarchical modeling of the whole of the
system dynamics is missing. This mapping rests on the hierarchical
feature of the two notations. A convenient colored marking is also
proposed to achieve the HCPN dynamics based on valuated objects. This
proposal has never been tackled by previous research works. The
derived HCPNs have been validated by model checking. The verification
concerned both the model correctness and faithfulness.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Graphical
scenarios for specifying temporal properties: an automated approach
(2007!)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">(a
journal version of “</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">A
Scenario Based Notation for Specifying Temporal Properties”))</SPAN></I></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
← </SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><B><SPAN STYLE="background: transparent">very
important for inspiration</SPAN></B></I></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">These
properties are typically specified as linear-time formulae in
temporal logics. Unfortunately, the level of inherent sophistication
required by these formalisms too often represents an impediment to
move these techniques from “research theory” to “industry
practice”. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
objective of this work is to facilitate the non trivial and error
prone task of specifying, correctly and without expertise in temporal
logic, temporal properties.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Then
we present a scenario-based visual language called Property Sequence
Chart (PSC) that, in our opinion, fixes the highlighted lacks of
these notations by extending a subset of UML 2.0 Interaction Sequence
Diagrams</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">.
We also provide PSC with both denotational and </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">operational
semantics. The operational semantics is obtained via translation into
B ̈chi automata </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">and
the translation algorithm is implemented as a plugin of our Charmy
tool. Expressiveness of PSC has been validated with respect to well
known property specification patterns.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">In
other words, there is a substantial gap between natural language and
the LTL language. Holzmann in (Holzmann, 2002) states, for example,
that one of the “most underestimated problems in applications of
automated tools to software verification” is “the problem of
accurately capturing the correctness requirements that have to be
verified”. In the same paper Holzmann shows that writing LTL
formulae is an error prone task. ← for ppt!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
(Smith et al., 2002) the authors notice that these problems are not
only related to the chosen notation, in fact “no matter what
notation is used, however, there are often subtle, but important,
details that need to be considered”. For this reason, the
introduction of temporal logic-based techniques in an industrial
software life-cycle requires specific skills and good tool support.
As a matter of fact, industries are not willing to use the above
mentioned techniques and this slows down the transition of software
verification tools from “research theory” to “industry
practice”. In order to mitigate this problem, in (Smith et al.,
2002) the authors propose PROPEL that, by building upon property
patterns previously identified, introduces pattern templates which
are represented using both disciplined natural language and finite
state automata. Many other works in the last years propose solutions
to overcome this problem. While one proposal is to construct a
library of predefined LTL formulae from which a user can choose
(Dwyer et al., 1999), other works propose the specification of
temporal properties through graphical formalisms (Smith et al.,
2001), (Dillon et al., 1994), (Zanolin et al., 2003), (Alfonso et
al., 2004; Braberman et al., 2005), and (Kugler et al., 2005). Any of
these solutions have advantages and disadvantages.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Based
on these considerations, we believe that an accurate analysis is
necessary in order to understand what is required in a formalism to
express a “useful set” of temporal properties while keeping in
mind that easy use and simplicity are mandatory requirements to make
a formalism adopted by industries. Thus, in our opinion, the
“perfect” language should find the “right” balance between
expressive power and simplicity of use. ← for future work! meeting
also!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Within
the PSC language, a property is seen as a relation on a set of
exchanged system messages, with zero or more constraints. Our
language may be used to describe both positive scenarios (i.e., the
“desired” ones) and negative scenarios (i.e., the “unwanted”
ones) for specifying interactions among the components of a system.
For positive scenarios, we can specify both mandatory and provisional
behaviors. In other words, it is possible to specify that the run of
the system must or may continue to complete the described
interaction. In order to unambiguously determine which execution
sequences are allowed or not, we formally define a trace-based
denotational semantics of PSC by associating to each PSC the set of
all the invalid traces.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">It
is well known that an LTL formula can be translated into a Buchi
automaton (Buchi, 1960) that can be used by model checkers (Holzmann,
2003) or component assemblers (M.Tivoli and M.Autili, 2004). Although
this representation looks more intuitive, it can be very difficult to
correctly and directly represent a property as a Buchi automaton.
Therefore, in order to overcome this problem and to provide PSC also
with an operational semantics, we propose an algorithm, called
Psc2Ba, to translate PSC specifications into Buchi automata. The
algorithm has been implemented as a plugin of our tool Charmy (Charmy
Project, 2004) which is a framework (based on the model checker Spin
(Holzmann, 2003)) for software architecture design and verification
with respect to temporal properties. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">We
measured the expressiveness of our language with respect to the set
of property specification patterns proposed </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">in
(Dwyer et al., 1999) that captures recurring solutions to design and
coding problems. ← for </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">meeting,
for future work!</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Even
though PSC is yet another properties specification language, it aims
at proposing a language that, building on results and experience of
already existent and valuable works in the Literature, aims at
balancing expressive power and simplicity of use.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">To
this purpose, we analyzed existing solutions in order to figure out
graphical notations and associated semantics that might be
appropriate to facilitate the introduction of our language in an
industrial software life-cycle while retaining enough power to
express the targeted useful set of temporal properties, i.e., the one
identified by the properties specification patterns (Dwyer et al.,
1999) (in the middle of Figure 1). The properties that we want to
specify express temporal relations between messages exchanged among
parts of the system. For this reason the starting point of our
analysis has been the tools that are commonly used in industries for
specifying component-based systems that interact by message passing.
Visual formalisms for scenario-based modeling that are commonly and
extensively used within industrial software development practice are
Message Sequence Charts (MSCs) (ITU-T Recommendation Z.120., 1999)
and UML 2.0 Sequence Diagrams.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Concerning
the features that had to be added, if other languages in the
Literature (different from UML and MSC) already had one of these
features we inherit it from them. For instance, our notion of
constraints (that we will introduce in Section 5) has been inspired
by Timeedit (Smith et al., 2001) and we have directly inherited part
of its graphical notation. Thus, one way to propose a new language is
to extend an existing one retaining its original semantics. In the
case of UML and MSC it is not possible to completely follow this way
since these languages have neither a native formal semantics nor a
widely accepted one despite the several attempts to define formal
semantics for these two languages. Thus, we inherit graphical
elements from UML sequence diagrams and MSC only when these elements
have a native informal semantics that is consistent with the formal
semantics we define, substituting those graphical elements having an
ambiguous semantics. This is for instance the case of message types
for which we used Timeedit graphical elements instead of UML assert,
optional, and neg frames. However, for the purpose of using MSC to
describe temporal properties, the MSC language lacks in expressive
power as discussed and itemized in the following: In other words it
is not possible to clearly distinguish between mandatory messages and
provisional ones. Alternative: it is useful to be able to specify two
or more different sequences of messages that can be unconditionally
chosen. The MSC language deals with alternatives by means of
high-level MSCs; Loop: sometimes a sequence of messages has to be
repeated several times. MSC deals with repetitions by also using hMSC
but it is not possible to specify a lower and upper bound to the
number of repetitions.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Many
of the previously identified features have been added in the UML 2.0
Interaction Sequence Diagrams. The authors propose that either MSC
should be retired or should become a profile of UML 2.0</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">assert
is used to specify mandatory messages; neg is used to describe
forbidden scenarios. Both of them are defined as operators (i.e.,
InteractionOperators), they support nesting and they can be applied
to a set of messages. These operators are graphically represented as
a frame box with a compartment displaying the name. If an operator
has two or more operands, they are divided by dashed lines. This
graphical notation can be very expressive when dealing with more than
one message and with nesting, but UML 2.0 has yet again not provided
a formal semantics. Specifically, it is unclear what happens if there
are several neg/assert operators nested or intermixed with other
operators</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Thus,
as noticed in (St ̈rrle, 2003), neg and assert should be modeled as
attributes of a single message rather than operators. &nbsp;In
accordance with this idea, as we will see later on, the graphical
notation we use for neg and assert is different from the one used by
UML 2.0. This has been done in order to be closer to the notion of
attribute and to make the notation more clear and intuitive;</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Graphical
Interval Logic (GIL) (Dillon et al., 1994) is sufficiently expressive
but its formulae become potentially difficult to understand. This
difficulty comes from the fact that its graphical notation is very
close to temporal logic syntax. On the contrary, Timeedit (Smith et
al., 2001) (also called TimeLine Editor ) has a more intuitive
notation but it was specifically developed to capture long running on
complex chains of dependent events (the specification patterns people
(Dwyer et al., 1999) call them “chain patterns”). LSCs are an
extension of MSCs with the aim of dealing with liveness. This is done
by introducing the difference between mandatory and provisional
messages that have the same meaning of our Regular and Required
messages respectively. LSC is a project started before UML 2.0 and it
played an important role in suggesting features of UML 2.0
Interaction Diagrams. In fact, many LSC features are today parts of
UML 2.0 Interaction Diagrams. For this reason we have developed the
translation algorithm defining PSC as a conservative extension of
this language.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
main advantage of PSC with respect to LSC is its ability to specify
intraMsg and especially chain constraints. In fact a constraint
allows the specification of what can be performed before and after a
message exchange. This is very useful to describe causes, effects and
precedence and response relations. The translation algorithm proposed
by Ghezzi et al. (Zanolin et al., 2003) gets as input a LSC and
produces an automaton and a LTL formula, both necessary to express
the correct temporal properties.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
also assume components to communicate by synchronous communication
channels and hence, send and receive events of the same message are
considered to occur simultaneously. Thus, we can restrict to
sendevents only and, hereafter, we uniquely associate a message (and
hence its label) to its send-event.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">It
is worthwhile noticing that, PSC can also be used to specify
properties for asynchronous component-based systems since, as pointed
out in (Uchitel et al., 2004), “a bounded asynchronous
communication can be modeled by introducing buffer abstraction to
decouple message passing”. Of course, this could lead to ugly and
cluttered specification of both the system models and the properties
themselves.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Since
we are interested in expressing properties for specifying execution
sequences of a system in terms of message passing, we define an
ordering relation among the system messages by abstracting with
respect to the absolute time. This abstraction is acceptable since,
at the moment, we are not interested in real-time systems for which
modeling time becomes relevant. ← for ppt same!</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Crucial
for ppt: </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Within
a PSC scenario we identify a set of horizontal dotted lines t0 , . .
. , tn+1 (see Figures 2 and 3). These lines are called structural
time-lines (or simply time-lines) and identify a point in time. For
each time-line only one arrowMSG is allowed, except for time-line t0
and tn+1 that cannot have associated messages. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">Time-lines
are totally ordered from top to bottom and the pair time-line and its
associated arrowMSG uniquely identifies the sender and the receiver
(and hence the corresponding send-event). Note that, the use of
time-lines is only a means for structuring the lifelines. In fact,
time-lines are totally ordered but this ordering is only
(graphical-)structural.</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">That
is a designer can also specify a partial ordering of messages by
using constraints and operators that we shall define later.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
order to identify the sender and the receiver components, the
intraMSG labels are prefixed by the </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">name
of the sender component and postfixed by the name of the receiver
component. For example, the label Ci .l.Cj denotes the message
labeled by l sent from the component Ci to the component Cj. ← have
this already in the other paper below.. The filled circles are two
constraints that (by the identifier b) ref- erence the message label
UserInterface.logout.ATM. The constraint associated to wReq states
that the pair of messages login and wReq is a valid precondition for
the uDB request iff the intra-message logout is not exchanged after
login and before wReq. It is useful to note that, while the messages
login, wReq and uDB create the main structure of the property, the
constraint </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">b
</SPAN></I></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">over
the unwanted message logout is used to refine the main structure by
imposing restrictions on what can happen over the time intervals
between login and wReq, and between wReq and uDB. &nbsp;{ b=
UserInterface.logout.ATM } PSC distinguishes among three different
types of arrowMSGs:</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">-
message types:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Regular
messages: the labels of such messages are prefixed by &nbsp;“e:”.
They denote messages that constitute the precondition for a desired
(or an undesired) behavior. It is not mandatory for the system to
exchange a Regular message (or a set of sequential Regular messages),
however, if it (or they all) happens the precondition for the
continuations has been verified. This kind of messages can be mapped
into UML 2.0 &nbsp;and MSC provisional messages</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">-
Required messages: are identified by the “r:” label prefix. It is
mandatory for the system to exchange this type of messages provided
that their (possible) precondition is met. By means of these messages
we can specify liveness properties. Required messages have the same
meaning of UML 2.0 assert messages that are used to identify the only
valid continuations. Fail messages: their label is prefixed by “f:”.
They identify messages that should never be exchanged. Fail messages
are used to express undesired behaviors and hence safety properties.
UML 2.0 neg operator expresses the same notion. In fact, the operator
neg is used to represent unwanted traces. - Strict ordering: in order
to explicitly choose a strict ordering between a pair of messages, we
define the strict operator. A loose ordering is assumed otherwise.
Within a lifeline, between a pair of messages m and m on time-lines
ti and ti+1 respectively, the strict operator specifies that no other
messages can be exchanged. Graphically, the strict operator is a
thick line that links the pair of messages </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">For
this operator UML 2.0 uses the same graphical notation (i.e., a named
frame box) as the one used for the neg and assert operators described
in Section 3. Differently from us, in UML 2.0 it is also permitted to
specify strict ordering within more than one lifeline.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">We
think that the strict operator is well defined as a relation between
two contiguous messages within a single lifeline (see Figure 4). In
fact, by referring to Figure 5.a, it does not make sense to state
that the message m between C1 and C2 must be strictly followed by the
message m between C3 and C4. On the contrary, as it showed in Figure
5.b a loose ordering of two messages m and m exchanged between
independent pairs of components is allowed.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">-
constraints: constraints of an arrowMSG m impose “restrictions”
on intraMSGs of m. Restrictions specify either a chain of intraMSGs
(chain constraints) or a set of intraMSGs that the system must not
exchange (unwanted messages constraints). Informally, an unwanted
messages constraint is satisfied iff all the set of intraMSGs
specified as unwanted messages are not exchanged. As noticed in
(Dwyer et al., 1999) chains are very useful for describing a
relationship between a single arrowMSG m and a sequence of intraMSGs
m1 , . . . , mn .</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">As
will be clear later, both wanted and unwanted chains are different
from sequences of required, regular, or fail messages since chains
consider the sequence of messages as a whole.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">timelines
vs lifelines, notice!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
this section we give the PSC operational semantics in terms of Buchi
automata that can be seen </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">as
operational representations of PSC scenarios. In fact, it is
well-known (Gerth et al., 1995; Clarke </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">et
al., 2001) that all LTL formulas, and hence also all the PSC
scenarios, can be translated into a Buchi automaton. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">A
well known method for describing sets of acceptable or unacceptable
behaviors of a system is by using automata over infinite words and
Buchi automata represent a popular formulation of infinite word
automata. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">An
accepting state is graphically represented with a double-circled
state. The problem of ̄model checking using automata assumes that
both the system model and the property are specified by automata. Let
us suppose that we want to model check the system M. Let A be the
automaton representing the system M such that the behavior of M is
the language L(A). Let S be an automaton such that L(S), the
corresponding language, contains the set of allowed behaviors. The
system A satisfies S when L(A) ⊆ L(S). That is, if the intersection
L(A) L(S) contains behaviors, each of them corresponds to a
counterexample. Therefore the model checker requires to have the
negation of S to perform the analysis. Since to negate a B ̈chi
automaton is</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">an
expensive task, and we use B ̈chi automata to give semantics to PSC,
the translation algorithm from PSC to B ̈chi automata directly
derives the B ̈chi automaton corresponding to the negation of the
desired temporal property. That is, when an execution of the automata
is accepting then the property is violated.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">In
the following, we present the translation rules and the pseudo-code
of the algorithms used to translate a PSC into its corresponding
Buchi automaton. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Figures
8, 9 and 10 ← rather important!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Before
giving a detailed description of the chain constraints, which are
used to express relationships between chains of intraMSGs and
arrowMSGs, we recall that we distinguish between wanted and unwanted
chains (Section 5.1). Informally, a wanted chain constraint (either
in the past or in the future) related to an arrowMSG a represents a
sequence of intraMSGs (m1 , . . . , mn ) of a and it is satisfied if
the messages are exchanged following the loose ordering imposed by
the chain itself. Focusing on the rule e future unwanted chain
constr, we note that the valid continuation is in every state after a
has been exchanged and the chain is not completely performed. In
fact, since we do not want the messages (m1 , . . . , mn ) to be
exchanged in the order of the corresponding wanted chain, before that
the corresponding wanted chain has been completely accomplished, each
state is a final state (and hence, a valid continuation). In e past
unwanted chain constr we have a valid continuation only if a happens
before the chain has been completely accomplished. Conversely, in the
case of e future wanted chain constr, after a happens, the valid
continuation is reached when the chain has been completely
accomplished. Complementarily, in the rule e past wanted chain
constr, the valid continuation is obtained when a happens after the
chain.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Figures
11, 12 and 13 ← rather important!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Fail
messages have only two chain constraint rules since the system has no
future after a fail message has been exchanged. In this section we
present subroutines used for composing B ̈chi automata and special
composition rules for PSC operators: parallel, loop and alternative.
These rules are meta-rules because they are used for translating the
mentioned operators that do not have a prefixed number of messages as
arguments. For this reason there is no direct mapping into B ̈chi
automata but they require a dedicated translation algorithm.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Parallel:
the next function permits to derive the B ̈chi automaton
corresponding to the parallel operator. The parallel operator par(ω
h,k ,sp(h, k)) with sp(h, k)={(h, q), (q + 1, z), . . . , (t + 1, k)}
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">interleaves</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">the
linearizations ω h,q , ω q+1,z , . . . , ω t+1,k </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">in
any way as long as the ordering imposed by each linearization as such
is preserved</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">.
…. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
continuation: plenty of message semantics + operator semantics
formulas!</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">And
a theorem that operational and denotational semantics are equivalent.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">ok;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">As
already discussed, since scenario specifications are less informative
with respect to LTL formulae, the set of properties that can be
specified in this way is just a subset of LTL properties. However,
this does not appear to be a significant restriction since the subset
of specifiable properties, as confirmed by several case studies we
have considered so far, appears sufficiently expressive for a
software designer. ← for future work! meeting?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">More
precisely, Psc2Ba can graphically express a useful set of both
liveness and safety properties: Liveness: by means of required
messages we are able to express that a message is mandatory. Safety:
by means of fail messages we can express that a message should not
happen. By means of constraints we can raise an error when a message
in a constraint happens before the message containing the constraint.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">We
are able to represent in PSC all the defined patterns (PSC Project,
2005). Since PSC is an event-based formalism in terms of exchanged
messages among components, and since in event-based formalisms the
underlying model does not allow two events to coincide (Dwyer et al.,
1999), we disallow the specification of simultaneous events. ← VERY
IMPORTANT!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">page
50: “Similary to what done..”</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">(seems
like between q and r scope is not very naturally presented with the
PSC, see fig.16!)</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Focusing
on the Precedence Chain 1 cause-2 effects within the between q and r
scope, the “after q” notion is represented as a regular message.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
the other example, Precedence Chain 2 causes-1 effect within the
after q scope, the two causes are s and t and the effect is p. The
“after q” scope is represented as a regular message. There is an
error if we have the effect without having the chain of causes. Thus,
the error is represented as a fail message p with a past unwanted
chain constraint of s and t. Note that the PSC formula is scalable,
in fact, if we want to write a 3 causes-1 effect, we have to add the
third cause, z, as a third element in the tuple g.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Case
Study: are the buchi automata automatically generated? Yes:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
Psc2Ba algorithm has been implemented as a plugin for Charmy. The
plugin permits to design the PSC scenarios and to produce the
corresponding B ̈chi automata. The current implementation produces a
B ̈chi automaton in the form of never claim, which is </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">the
syntactical textual representation of B ̈chi automata.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 114%"><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">(</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><A HREF="http://www.di.univaq.it/charmy"><SPAN STYLE="font-variant: normal"><FONT COLOR="#1155cc"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">http://www.di.univaq.it/charmy</SPAN></B></U></SPAN></FONT></FONT></SPAN></FONT></SPAN></A><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: transparent">
</SPAN></SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">last
update 2006!!!)</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">In
this paper we proposed a formalism for specifying temporal properties
aimed at being simple, (sufficiently) powerful and user-friendly.
After having examined Message Sequence Charts (ITU-T Recommendation
Z.120., 1999), and UML 2.0 Interaction Sequence Diagrams (Object
Management Group (OMG), 2004), we presented a scenario-based
graphical language that is an extended notation of a selected subset
of the UML 2.0 Interaction Sequence Diagrams. We called this language
Property Sequence Chart (PSC). ← duh, for future work! criteria!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Within
PSC a property is seen as a relation on a set of exchanged system
messages, with zero or more constraints. More precisely, our language
is used to describe both positive scenarios (i.e., the “desired”
ones) and negative scenarios (i.e., the “unwanted” ones) for
describing interactions among the components of a system. PSC can
graphically express a useful set of both liveness and safety
properties.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">USE:
A UML-based specification environment for validating UML and OCL
(2007)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Here,
we concentrate on model validation, i.e., on checking that a model
meets informal </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">requirements
a developer has in mind. Checking also involves that the model
satisfies particular properties, for example, that certain
consequences can be proved or at least certified by a model
inspection process. USE basically is an interpreter for a sub-set of
UML and OCL. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">An
OCL constraint is either an invariant or a pre- or post-condition. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
USE system supports developers in analyzing the model structure
(classes, associations, attributes, and invariants) and the model
behavior (operations and pre- and post-conditions) by generating
typical snapshots (system states) and by executing typical operation
sequences (scenarios). Structural restrictions (invariants) which
determine the allowed object diagrams and behavioral restrictions
(pre- and post-conditions) which narrow the allowed operation calls
and operation returns are present in the model browser, but are not
shown in the class diagram.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Class
extent: The extent of class Person after the last operation has been
executed indicates the current object identities (ada, bob, etc.) and
the values the attributes (name, civstat, etc.) currently take. In
this situation, the class extent uniquely determines a UML object
diagram (with no links) characterizing the current system state. The
theoretical work in connection with USE proposing an OCL metamodel
and defining the formal semantics of OCL found its way into the OCL
2.0 OMG standard. USE is the only system allowing snapshots to be
generated automatically. ← probably that’s why so many citations </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
syntax of UML and OCL is defined with a metamodel using UML (MOF).
The semantics of OCL and the needed class diagram features of UML is
expressed in terms of plain set theory in [11] which has been
implemented in the USE system hand in hand with the formal semantics.
This set-theoretic semantics of OCL is part of the OMG standard and
additionally expressed in that standard in terms of a metamodel. We
have described the tool USE which allows UML models with OCL
constraints (invariants and pre- and post-conditions) to be validated
against developer’s assumptions. &nbsp;← the problem is that
temporal properties still cannot be validated</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">USE
allows to a certain extent the checking of formal properties. USE
permits us to review the consistency of UML models and the
independence of constraints. USE makes it possible to certify
properties. It can be shown that under particular assumptions certain
constraints are logical consequences of a given UML model.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Thus,
USE supports developers in analyzing the model structure and behavior
and in exploring properties of models. USE (as all other OCL systems
we are aware of) does not allow full automatic formal verification of
arbitrary properties formulated in OCL.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Roles
at the Basis of UML Validation (2007, Algeria?)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">we
first present a technique for transforming UML statecharts into Petri
nets. We develop afterwards, an approach based on the movement of the
objects throughout the roles they play. This approach allows
validation of the temporal logic properties translated from the OCL
invariants, on the Petri nets derived from the UML models. The Petri
nets resulting from the derivation process are analyzed by means of
PROD [22], a model checker tool for predicate/transition nets. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">To
avoid the high learning cost of the model checker, we suggest that
the designer specifies the system properties in OCL, the Object
Constraint Language [20] which is part of UML. OCL permits the
formulation of restrictions over UML models, in particular,
invariants. We automate the translation of these invariants to
temporal logic properties so that they can be verified by PROD during
the Petri net analysis. ← translate OCL into temporal logic
properties? but invariants are meant to hold “everywhere, all the
time”, so it’s a really small subset of the possible patterns!</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
invariants are specified on class diagrams which model the static
structure of a system, </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">in
terms of classes and relationships between classes. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">A
class describes a set of objects encapsulating attributes and
methods. An association abstracts the links between the class
instances. It has at least two ends, named association ends, each one
representing a set of objects playing a given role at a given time.
However, a simple translation of OCL invariants</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">into
Linear Temporal Logic (LTL) and Computation Tree Logic (CTL)
properties is not sufficient for realizing a property checking.
Indeed, OCL invariants refer to association ends to evaluate their
expressions. So, in case the designer specifies OCL invariants for
his models, we attract his attention on the necessity of modeling the
actions treating the association ends so that the invariants can be
adequately verified by PROD. In other words, he is called on to
specify the association end update using the link actions.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">We
summarize in this section the work that we present in [6] to
transform UML statecharts into coloured Petri nets. This work
supports the approach that we develop in the present paper. ← for
future work, this is how you say it, to glue previous work</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
derivation process is based on an object-oriented approach. Each
statechart modeling an interactive class behaviour is transformed
into an object subnet called Dynamic Model or DM (see Figure 2). To
construct the DM, each state is converted to a place p ∈ P and each
transition is converted to a transition t ∈ T.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Figure
3 summarizes the translation of the statechart constructs into their
counterparts in Petri nets. &nbsp;← for future work, how I should
summarize probably</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
formalize an interaction on a sequence diagram by the 5 tuple (ev,
srce, targ, xobj/op, attrib). The component ev identifies the event
(“send” class(), “call” operation()). Srce and targ are
respectively the source and the target object’s identity. The
component xobj gives the exchanged object’s identity (object:class)
if a send event or the called operation op if a call event. As for
attrib, it designates the set {a1 , . . . , ak } of the exchanged
object attributes or the operation attributes.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
verification tackles the good construction of the model, using
generic properties as deadlock, livelock, reject states,
quasi-liveness, boundedness or reinitializability. All these
properties are automatically verified by PROD. As for the validation,
it checks whether the model is constructed in conformity with the
customer initial requirements. For this purpose, specific properties
of the system, written by the modeler, are used.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Since
the main motivation of this work is that the UML designer may reach
valid models without the need for knowledge of formal techniques, it
is only reasonable that the system properties are expressed by the
modeler in the OCL language and are automatically translated
afterwards into LTL and CTL OCL is mainly based on the use of
operations on collections for specifying object invariants. ← for
meeting? futurework?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Since
these collections correspond to association ends, the latter must
appear on Petri net specification so that the translated LTL and CTL
properties (whose expression is essentially made of these constructs)
can be verified. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">UML
action semantics was defined in [21] for model execution and
transformation. &nbsp;!!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">An
OCL invariant is a stereotyped constraint that must be true for all
instances at any time. ← see that’s the problem! for future
work/meeting </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">PROD
supports both LTL and CTL logics. LTL and CTL are different regarding
expressiveness: there are properties that can be specified in LTL,
but not in CTL and vice versa. LTL formulas express properties of one
possible system behavior. They are checked on the fly. CTL formulas
express the set of all possible behaviors starting in a state. They
are checked on all the state space. In LTL the future of a state in a
run is inevitable, whereas in </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">CTL
a state usually has many different possible futures. Thus, generally
speaking, CTL </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">expresses
possibility properties whereas LTL expresses properties that are
inevitable.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><U><SPAN STYLE="background: transparent">
</SPAN></U></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">In
other words, when mapping an OCL invariant to temporal logic, the
only potential used operator is always. I</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">n
order to better exploit PROD temporal logics and permit the
expression of more properties, </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">we
propose to introduce optionally in OCL invariant two new operators</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">.
The first is the keyword will which means that the condition will be
verified in the future (LTL property). The second is the keyword can
that means that the condition will be verified in one of the possible
futures (CTL property). So, the new forms of the OCL invariant are:</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Context
object:class inv : ocl-expr [will ocl-expr]</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">and</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Context
object:class inv : ocl-expr [can ocl-expr].</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">..It
is written for each object of the context ← then how do you relate
two objects?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
navigationExp is a reference to an association end defined in a UML
model. It is used to determine for an object, the collection of its
linked objects. The object is matched with the association end by
using a ‘.’ as follows: object.associationEnd. As seen in Section
4, an association end is translated into a place of role type, with
the name of the association end.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">To
illustrate the OCL translation into PROD logics, we present three
properties </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">covering
a large</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">spectrum
of OCL expressions: (yeah right)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">-
The number of connected stations is limited to</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">maxStation.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">-
Only connected stations can transmit messages.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">expression
in OCL:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">Context
s:Server inv :</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">s.connectedStation→excludes(st1:Station)</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">implies
st1.transmittedMessage→isEmpty()</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">-
While a station st2 is connected, it receives all the messages that
are transmitted from a station st1</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Oh
come on these three are not so representative, it’s crap! Maybe the
last one only</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Other
works tackle OCL invariant extension with temporal operations [7],
[9] ← check these!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Formal
semantics of static and temporal state-oriented OCL constraints
(2003) ← cited by 28, VERY PROMISING READ (at least for future
work) </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
textual Object Constraint Language (OCL) is primarily intended to
specify restrictions over</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">UML
class diagrams, in particular class invariants, operation pre-, and
postconditions. Based on several improvements in the definition of
the language concepts in last years, a proposal for a new version of
OCL has recently been published [43]. That document provides an
extensive OCL semantic description that constitutes a tight
integration into UML. However, OCL still lacks a semantic integration
of UML Statecharts, although it can already be used to refer to
states in OCL expressions. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">This
article presents an approach that closes this gap and introduces a
formal semantics for such integration through a mathematical model.
It also presents the definition of a temporal OCL extension by means
of a UML Profile based on the metamodel of the latest OCL proposal.
Our OCL extension enables modelers to specify behavioral
state-oriented real-time constraints. It provides an intuitive
understanding and readability at application level since common OCL
syntax and concepts are preserved. A well-defined formal semantics is
given through the mapping of temporal OCL expressions to temporal
logics </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">formulae.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><U><SPAN STYLE="background: transparent">
</SPAN></U></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">Moreover,
UML and OCL are missing adequate means to specify constraints over
</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">the
dynamic behavior of a UML model.</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">However,
it is essential to support the definition of temporal constraints
already in early phases of development in order to specify correct
system behavior over time. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">While
other approaches focus on UML Collaboration and Sequence Diagrams and
consider temporal OCL constraints for event communication (e.g., [6,
22, 44]), we investigate consecutiveness of states and state
transitions in UML Statecharts and time-bounded constraints over
sequences of states.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Since
the current UML specification does not come with an OCL metamodel, we
first took the OCL type metamodel presented by Baar and H ̈hnle [1]
and performed a rather heavyweight extension by directly extending
that metamodel [18]. More recently, we developed a UML Profile for
our temporal OCL extension based on the OCL 2.0 proposal </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
order to be able to specify temporal OCL constraints, we introduce
the notion of a trace over a given model. A trace is an (infinite)
sequence of system states. Each element occurring in a trace
indicates that a ‘noteworthy’ change to the model has happened,
e.g., that an operation is called or terminated. We present a mapping
of (future-oriented) temporal OCL expressions to time-annotated
formulae expressed in a discrete temporal logics called Clocked CTL.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">OCL
is a declarative expression-based language, i.e., evaluation of OCL
expressions does not have side effects on the corresponding UML
model. To integrate constraints into the visual UML modeling
approach, invariants, pre- and postconditions are modeled as
annotations and attached to the respective model elements in class
diagrams. ← for future work?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Due
to the lack of an OCL metamodel in the UML standard, extensions of
OCL have so far been defined purely on the concrete syntax level, in
particular in the areas of business processes [8, 23], knowledge- and
databases [5, 11], and real-time systems [41]. A semantics on the
language definition level is not given so far.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">As
soon as an OCL metamodel becomes part of the UML standard, we expect
that extensions of OCL are developed by means of UML Profiles, just
as it has already been done for other parts of UML, e.g., in the
domain of modeling real-time systems.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">An
Extension of OCL with Temporal Logic (2002, todo: read fully)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">UML
class diagrams are widely used to model the static structure of
object-oriented software systems. As a supplement, OCL becomes more
and more popular for formulating constraints that can not be modeled
by the diagrams. In this paper, we extend OCL with elements of
temporal logic. With this extension, constraints on the temporal
development of the system structure as well as on the system behavior
can be stated in terms of temporal invariants and pre- and
postconditions.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Temporal
logic, as an extension of predicate logic, has been used successfully
in the field of software development (see [13, 8, 7], among other
approaches). The basic idea of (linear) temporal logic is to consider
not only single states or state pairs, but to care about arbitrary
finite state sequences. By doing so, it is possible to characterize
system behavior and system development by specifying the allowed
system state sequences as life cycles. ← for meeting</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
this paper, we present an extension of OCL with important elements of
a finite linear temporal logic. Past and future temporal operators
are introduced. Our extended version of OCL, which we </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">call
TOCL (Temporal OCL), is capable of specifying constraints on the
temporal development of a </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">system’s
structure. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
@next</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">modifier
applied to an operation has the effect of evaluating the operation in
the next state. The past expressions ‘previous e’,
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">‘</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">existsPrevious</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">e’,
‘alwaysPast e’, ‘some- timePast e’, ‘</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">always
e1 since e2</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
’</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">,
‘sometime e1 since e2 , and the modifier </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">@pre</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">can
be defined analogously. They behave like the future expressions
flipped (with</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">respect
to to the temporal ordering) across the reference state. &nbsp;Finally,
a tool could be developed for validation of TOCL constraints with
respect to state sequences. The USE tool [16] allows validation of
OCL constraints by testing the validity of constraints with respect
to example states. For TOCL, example state sequences would be
necessary. These could be recorded by a tool like USE; however, long
sequences can hardly be produced manually.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
automatic production of appropriate state sequences would be a
welcome feature.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">example
for your reference: obj@pre(a,b)→forAll( c | expr) ← meeting</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Some
approaches already include timing bounds for property specifications,
but they either use completely different notations [22] or introduce
time-bounded OCL operations for event-based specifications ← for
meeting/future work!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Together
with our previous work, we presented an OCL extension that allows for
the specification of past-and future-oriented state-oriented
time-bounded constraints based on the latest OCL 2.0 metamodel
proposal. Our approach is still the only one that extends OCL by us-</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">ing
the UML extension mechanism of profiles, i.e., stereotypes, tagged
values, and constraints.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Model
Checking: Algorithmic Verification and Debugging (todo: read fully!)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Algorithmic
verification involves three different tasks: (1) requirements
specification, (2) building executable system models, and (3)
developing scalable algorithms both for checking requirements and for
providing diagnostics when requirements are not met. The status for
each of these tasks is discussed below. ← for meeting</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Requirements
Specification. Requirements characterize the expected behavior of a
system. They can be expressed following two paradigms. State-based
requirements specify a system’s observable behavior by using
transition systems. Property-based requirements use a declarative
style. These requirements are expressed as sets of formulas in a
formalism such as a TL. A combination of the two paradigms is
necessary for enhanced expressiveness, such as in the PSL language.
The state-based paradigm is adequate for characterizing causal
dependencies between events, e.g., sequences of actions. In contrast,
the property-based paradigm is more appropriate for global
properties, e.g., liveness and mutual exclusion. For concurrent
systems, an important trend is toward semantic variations of
state-based formalisms such as Live Sequence Charts. ← for meeting</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Using
TLs has certainly been a breakthrough in understanding and
formalizing requirements for concurrent systems. Nonetheless, subtle
differences in the formulation of common concepts such as liveness
and fairness, which depend on the underlying time model (e.g.,
branching or linear time), show that writing rigorous logic
specifications is not trivial. Furthermore, the declarative and dense
style in the expression of property-based requirements is not always
easy to master and understand. Requirements must be sound. That is,
they must be satisfiable by some model. In addition, they must be
complete. That is, no important information is omitted about the
specified system. In contrast to soundness, which is a
well-understood property and can be checked automatically by using
decision procedures, there is no consensus as to what precisely
constitutes completeness in requirements specifications, nor how to
go about achieving it. Absolute completeness, which means that
specifications describe the system exactly, has only a theoretical
interest and is probably unattainable for non-trivial systems.
Existing requirements specification formalisms are mainly appropriate
for expressing functional requirements. We lack rigorous formalisms
for extra-functional requirements for security properties (e.g.,
privacy), reconfigurability properties (e.g., noninterference of
configurable features), and quality of service (e.g., degree of
jitter). ← for meeting!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Successful
application of verification methods requires techniques for building
executable models that faithfully represent a system or an
abstraction of it. Faithfulness means that the system to be verified
and its model are related through a checkable semantics–preserving
relation. This will ensure soundness of the model. In other words,
any property that we can verify for the model will hold for the real
system. Furthermore, to avoid errors in building models and to cope
with their complexity, models should be generated automatically from
system descriptions. Once the semantics is fixed, tractable models
can be extracted from real software through abstraction.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Visualizing
Requirements in UML Models</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">This
paper describes an alternative approach termed R E VU (Requirements
Visualization of UML), a process for visualizing functional
requirements in terms of behavioral interactions in a UML model. &nbsp;Two
related approaches exist for analyzing behavioral relationships in
UML models: visual inspection and guided simulation. In contrast, the
R E VU process enables a developer with minimal knowledge of a model
to learn about the system. Specifically, a critical aspect for
understanding how a UML model realizes requirements are witness
scenarios. A witness scenario is a particular sequence of steps
executed by the system to fulfill a given functional requirement. The
R E VU process uses three key steps to create and visualize witness
scenarios. First, the developer declaratively specifies properties of
a witness scenario in natural language. The declarative specification
allows a developer to “underspecify” the witness scenarios,
thereby uncovering scenarios when little system information is
available. Second, a model checker generates one or more witness
scenarios that adhere to the previously specified properties. For
this step, we use a model checker’s ability to search for counter
examples in the state space and store these counter examples in the
form of violation traces. Specifically, we exploit this trace
creation capability to create witness traces, which our tool suite
automatically converts to witness scenarios in terms of UML elements.
</SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Therefore,
our process has three main contributions:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">(1)
support for declaratively specifying the scenarios to be visualized
in natural language; (2) automated generation of witness scenarios;
and (3) support for visualizing the witness scenarios.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
REVU process leverages a roundtrip-engineering approach to the
construction of conceptual UML diagrams for modeling and analyzing
system requirements. ← rountripping, nice buzzword</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
this process, requirements are specified declaratively as natural
language properties that are mapped to temporal logic
representations. In contrast, the system model is specified in
operational fashion using UML class and state diagrams. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Three
existing approaches and their tool support jointly facilitate the
round-trip engineering approach. First, the SPIDER tool suite [19,
21] facilitates the specification of formally analyzable properties
using natural language. Properties specified using S PIDER can be
automatically translated to formal specification languages, e.g.,
linear-time temporal logic (LTL) [25] to be used with the model
checker Spin [14]. Second, Hydra [26] implements a metamodel-based
approach to mapping UML diagrams to the specification languages of
formal analysis tools, e.g., model checkers. Third, Theseus [8]
visually animates the analysis results (i.e., witness scenarios) in
terms of the original UML diagrams.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">To
validate our work, we applied the R E VU process to an industrial
case study for an adaptive light control system. In this case study,
we demonstrate how R E VU facilitates the understanding of complex
system interactions. ← so this is how you “validate” :-/</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">This
section provides a brief introduction to our natural language
specification tool suite (S PIDER), our UML formalization framework
(Hydra), and our UML visualization tool (Theseus).</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">S
PIDER [19, 21] (Specification Pattern Instantiation and Derivation
EnviRonment) is a process with corresponding tool support that
enables a developer to use a natural language-based grammar to
specify properties of UML models. Specifically, these properties are
specified in natural language using a previously developed process
for deriving and instantiating formally analyzable natural language
properties based on specification patterns [5, 20]. Briefly, the
SPIDER process comprises three steps:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">1.
Derivation: Derive a natural language sentence from a structured
natural language grammar.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">2.
Instantiation: Instantiate the natural language representation with
model-specific elements.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">3.
Mapping: Map the instantiated natural language sentence to the
temporal logic required by the targeted formal validation and
verification tool and analyze. An important component of this process
is a structured natural language grammar. This grammar is used to
derive natural language sentences that can be mapped to formal
specifications, such as LTL formulae.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">It
is well-known that UML lacks a precise, formally defined semantics.
Therefore, numerous semantic interpretations are possible for a given
diagram. In order to address this problem and to make UML diagrams
amenable to rigorous analysis, McUmber and Cheng [26] developed a
metamodel-based formalization framework that maps a given UML model
into a formal specification language, such as Promela, the
specification language for the model checker Spin [14]. Hydra
automates this mapping process [26].</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
general UML-to-Promela formalization approach is to map objects to
processes in Spin (proctypes) that exchange messages via channels.
Nested and concurrent states are also formalized as processes.
Additional details on the modeling and analysis process, and the
underlying formalization framework can be found in [26]. ← for ppt!
The first paragraph is how I do it. But mapping objects to processes
in Spin, not good for known reasons.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Theseus
[8] is a UML visualization tool that enables developers to visualize
analysis results produced by formal analysis tools in terms of UML
model elements. Theseus comprises an analysis-tool-specific Theseus
trace processor sand the generic Theseus visualization engine. The
Theseus trace processor converts a trace created by a formal analysis
tool, e.g., a counter example generated by Spin [14], into a scenario
in terms of the original UML model elements. The scenario information
includes state transitions and detailed information about messages
passed between classes. This scenario is stored in a well-defined
intermediate XML representation. The Theseus visualization engine
reads the scenario from the XML file and presents a step-by-step
animation of the counter example through both sequence and state
diagrams. The developer has the option of viewing the entire counter
example or stepping through any section of interest. The Theseus
visualization engine is general in that it can visualize a scenario
generated by any formal analysis tool, provided the scenario is
represented in the well-defined XML format. ← for ppt! Exactly how
I do it! Find this tool! Also separate trace-processor from
visualization (XMI representation)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">This
grammar (</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">shown
in Figure 2)</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">can
be used by S PIDER to guide the developer in deriving a natural
language property in a syntax-guided fashion [19]. While the grammar
follows the structure </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">of
the specification pattern system by Dwyer et al. [5], LTL property
templates that are not well-</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">suited
for the specification of witness scenarios have been modified. ← a
very simple grammar! </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">To
make the LTL formulae useful for uncovering witness scenarios, we
modified the specification patterns by Dwyer et al. that were poorly
suited for the specification of witness scenarios. The grammar
contains natural language representations of all stutter-invariant
specification patterns by Dwyer et al. [5],2 tailored to the
specification of witness scenario properties. According to the survey
in [5], this selection of specification patterns is sufficient to
specify more than 90% of properties encountered in practice. ← for
future work!</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Using
this grammar, developers are able to derive natural language
templates of properties that can be mapped to the temporal logic
representations of the corresponding specification pattern.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Before
instantiating a natural language property to be applicable for the
system model at hand, the developer replaces the placeholders (i.e.,
P and S in Expression 3) with free-form text describing the system
conditions to which the property applies.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Next,
the LTL property created with S PIDER is used by a formal analysis
tool, i.e., Spin [14], to create a witness trace. Model checkers, in
general, search for violations of a property by traversing the
complete state space of the system, thereby analyzing every possible
execution sequence. If a sequence is uncovered that violates the
specified property, then the model checker provides this sequence as
a violation trace, which may be used by our visualization framework
and Theseus for the visualization of a property violation (this
process is described in [8]). In contrast to the previous technique,
this work presents the generation and visualization of witness
scenarios in terms of the original UML model. The witness scenarios
are created from witness traces generated by the model checker.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">A
witness trace, as opposed to a violation trace, represents a sequence
of steps executed by the system that adheres to the specified
property, instead of violating it.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">They
don’t mention how they create the “complementary property”! →
Specifically, we specify the complement of the LTL property. This
complementary property is passed to the model </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">checker.
If the model checker finds a violation trace of the complementary
property, then the uncovered trace is a witness trace of the original
property</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">.
Since model checkers are most effective in finding and generating
violation traces [7], the model checker commonly finds such traces
traversing only a small portion of the model’s state space. ← for
ppt in bold!</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Spin
offers an algorithm for iteratively finding the shortest trace [14].
The shortest witness trace</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
a property is the minimal behavior the system performs for a
requirement. It excludes irrelevant steps that may be performed by
concurrent components. Therefore, shorter traces are commonly easier
to understand. It is important to note that Spin only guarantees this
trace to be the shortest for safety properties.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Theseus
[8] offers two different animation modes for a scenario: state
diagram animation (shown in Figure 3) and sequence diagram
generation. ← can’t really find the tool?! Not in the references
</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">As
a result, the following natural language property is obtained:</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Globally,
it is eventually the case that the user entering the room while the
system is in automatic mode and the brightness level is not
sufficient is eventually followed by the system regulating the dimmer
to match the desired brightness level.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">By
examining the UML model using the UML CASE tool and previous
requirements visualizations, the developer has determined that when
the system detects that the user enters the room and is in automatic
mode, then the variables ComputingComponent.motionDetected and
ComputingComponent.automaticMode are both set to true. ← for future
work, this is how I would do it (selecting potential values for
placeholders, that is!)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
visual depiction of this scenario expands the developer’s
understanding of the requirement by highlighting the objects and
interactions that can occur to fulfill it. Numerous CASE tools [2,
13, 16, 28, 31] provide visual simulation support for systems
specified in terms of UML models. Simulation, in contrast to R E VU,
requires the developer to have extensive knowledge about a system
model in order to guide the simulation to achieve the visualization
of a specific requirement. Other tools exist that visualize analysis
results from model checkers in terms of UML models, such as vUML
[24], MOCES [27], and Hugo/RT [18]. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">However,
to the best of our knowledge, none of these tools is concerned with
the generation and visualization of witness traces for the original
UML diagrams.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
&nbsp;</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">(What,
only countertraces?) ← see papers!</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
contrast to our approach, the Play-In/Play-Out methodology is
tailored to the specification of scenario-based system requirements,
while our approach focuses on the automatic visualization of
scenarios in UML class and state models.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
conclusion, none of the aforementioned approaches combines natural
language specification of witness scenario properties, the automated
generation of such witness scenarios, and the visualization of the
witness scenarios in terms of the original UML model. Numerous
directions for future work are possible. First, the tool support
could be extended to accommodate traces</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">generated
by formal analysis tools other than Spin.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Transforming
Process Algebra Models into UML State Machines: Bridging a Semantic
Gap?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Process
algebras are used for algebraic and axiomatic reasoning about the
behavior of distributed systems. UML state machines are suitable for
automatic software generation. We have developed a transformation
from the process algebra ACP into UML state machines to enable
automatic software generation from process algebra models. This
transformation needs to preserve both behavioral and structural
properties. The combination of these preservation requirements gives
rise to a semantic gap. It implies that we cannot transform ACP
models into UML state machines on a syntactic level only. We address
this semantic gap and propose a way of bridging it. To validate our
proposal, we have implemented a tool for automatic transformation of
ACP process algebra models into UML state machines. However, in many
applications one also needs to preserve semantic properties. This is
not trivial since the semantic domains of the source and target
formalism may differ, or a formal semantics may be lacking. These
systems are being modeled using a process algebra [2]. Process
algebra is a formalism used for algebraic and axiomatic reasoning
about the behavior of systems, in particular those involving
concurrency [3]. However, little is known about automatic code
generation from process algebra models. We use UML state machines as
an intermediate step because multiple techniques are available for
automatic code generation from them.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Therefore
we propose a transformation from process algebra models to UML state
machines [4]. We start with plain process algebra in order to
understand the basics of software generation from, and model
transformations based on process algebras. In this paper we use the
well-known process algebra ACP (Algebra of Communicating Processes)
[5,6] without encapsulation. In the transformation of this small
process algebra we already encounter a semantic gap. The obtained
results will be used when translating process algebra based
formalisms like timed χ [7] or mCRL2 [8]. This requires that the ACP
models and the obtained state machines are structurally equivalent
with respect to parallel behavior. The ACP models and the state
machines obtained from this transformation obviously need to exhibit
the same behavior. It is this combination of requirements, i.e.,
preserving structural and behavioral properties, that confronted us
with the problems of bridging a semantic gap. In ACP, constructs are
available for modeling synchronous communication between parallel
processes. UML state machines are inherently asynchronous, hence no
primitives exist for modeling synchronous communication. This means
that the transformation from ACP to UML state machines encompasses
more than translating syntax. Special care is needed to ensure that
the semantic gap is bridged in order to preserve both behavioral and
structural properties.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
a recent technical report [12], a transformation from timed χ into
UPPAAL timed automata is presented. The main purpose of that mapping
is to enable model checking and verification of process algebra
models. ← dafuk the first one does not support model checking?</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
our work we use the tool Telelogic Rhapsody to generate simulation
code from state machines. The semantics of Rhapsody state machines
differs slightly from UML state machines [15], but this does not
affect our approach. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">We
use the formal semantics of ACP described in [17] and the semantics
description of UML presented in [4] to explain informally the
behavioral equivalence of ACP constructs and the resulting UML state
machines. With behavioral equivalence we mean that the the state
machines need to define exactly the same traces as the original ACP
models. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
state machine constructs for the sequential, alternative, and
parallel composition are straightforward, i.e., the semantics is
clear from the syntax. &nbsp;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
left merge operator cannot be expressed in a natural way in a state
machine. It is impossible to express that a specific action in one
branch of a parallel composition should be performed first.
Therefore, the left merge operator is eliminated by rewriting
according to the axioms of ACP. Also the communication merge operator
cannot be expressed in a natural way in a state machine. Therefore,
when communication of two actions is encountered the communication
function (γ) is consulted whether this communication should be
rewritten into an action or the deadlock constant. These are the only
two cases in which structure is not preserved,</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">but
since these two constructs are seldomly used in modeling this is
acceptable. ← quee?? communication IS used!!</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
ACP the parallel composition of two or more process terms represents
not just the interleaving of these terms. It also involves
communication of the actions inside them. Consider for example the
ACP process term a || b. This will rewrite using the ACP axioms to a
· b + b · a + a|b. Suppose now the communication function γ(a, b)
= c exists for some action c. In this case actions a and b can be
executed simultaneously (a|b) and communicate. The result of this
communication is action c. So the traces allowed by this parallel
composition are a · b, b · a, and c. In UML state machines the
parallel composition, created by transitions that fork into
orthogonal regions, represents interleaving or concurrent execution
of the traces in the orthogonal regions. There is no communication
between the actions in these traces like in ACP. This gap between the
semantics of ACP and UML state machines needs to be bridged.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">One
possibility to bridge this gap is to use the ACP axioms to rewrite an
ACP model such that all parallel composition operators are removed.
In this way all communication is made explicit. The state machine
acquired after rewriting is sketched in Figure 3(a). This is not a
valid solution since one of the requirements is that the UML state
machines need to preserve the structure of the ACP models, at least
with respect to the parallel composition. In fact, the combination of
the requirements of preserving both behavioral and structural
properties gives rise to the semantic gap.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Another
possible solution is to exploit the semantic openness of UML state
machines. Therefore we propose an action dispatcher that takes care
of executing all actions. Actions are not executed in the state
machine itself. Instead, an action is announced to the action
dispatcher and the branch of the state machine that contains the
action is blocked. After the action dispatcher executes the action,
it enables the appropriate branch again such that the state machine
can continue. If multiple actions that can communicate have been
announced, the action dispatcher ensures that communication can occur
in accordance with the communication function. Suppose for example
that actions a and b are announced and that γ(a, b) = c, i.e.,
actions a and b can communicate resulting in action c. The action
dispatcher now also allows action c to be executed. Using the action
dispatcher, we succeed in preserving most of the structure of the ACP
model. Figure 3(b) sketches the resulting state machine.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">It
can be argued whether having a global action dispatcher that exploits
the semantic openness of UML state machines is a proper solution. The
disadvantage of having this global action dispatcher is that
communication behavior is invisible in the state machine. In the case
of ACP this is not a problem.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Communication
in ACP models is also invisible because it is expressed by a global
communication function (γ) and not in a process term itself. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Transformation
of Atoms. The transformation of all constructs except for the atoms
has already been explained in Section 3.2. The atom a maps to the
state &nbsp;machine depicted in Figure 5. The entry activity on the
simple state creates an action object from atom a and invokes the
AddToPool method of the action dispatcher. This puts the newly
created action object in the action pool. In order to ensure that the
state machine does not continue until the action has been executed, a
guard is present on the outgoing transition. This guard is true when
the action object is not in the action pool. This is the case when
the action has been executed or has communicated.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Correctness
Considerations. Interference between methods of the action dispatcher
can be avoided by executing them under mutual exclusion.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
transformation from ACP models into UML state machines expressed in
the XMI format is too complex to implement in a single step.
Therefore we split the transformation into four independent steps.
This modular approach makes the transformation more transparent,
which benefits extensibility, maintainability, and testability.
Moreover, every step is (re)usable in isolation. ← for future work,
maybe I should do it like this!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
the first step of the transformation the ACP model is rewritten using
the ACP axioms to remove all instances of the left merge and
communication merge operator. After this step the ACP model will only
consist of constructs that have a state machine equivalent. In the
second step the implicit tree structure of an ACP model is made
explicit. For the representation of this tree structure we use an
intermediate language for which we defined a metamodel. This language
uses a prefix format. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
the third step the tree representation of an ACP model is transformed
into a state machine. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">This
state machine is defined in a state machine language for which we
have also defined a metamodel. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">This
language closely resembles UML state machines. The only difference is
that it does not support the history mechanism. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">We
chose to use this intermediate format to avoid having to transform
into complex XMI constructs directly.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
the last step a state machine is transformed into its XMI [19]
representation. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">This
back-end part is isolated, because the XMI standard is actually not
so standard. Most UML tools use a different dialect of XMI requiring
different backends. Currently our implementation is able to generate
XMI files for the UML tools ArgoUML [20] and Telelogic Rhapsody [21].
&nbsp;← THIS!! FOR KEES! FOR THESIS!</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Our
state machine language closely resembles UML state machines and there
is a one-to-one mapping from UML state machine constructs to XMI.
Therefore, this final transformation step is straightforward. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
Telelogic Rhapsody tool allows for execution of state machines. &nbsp;←
does RSA SUPPORT THIS?</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">We
use the term rewriting system ASF+SDF [22,23] for the development of
our metamodels and for the implementation of our transformation.
Transformations between languages is one of the main applications of
ASF+SDF. These transformations are performed between languages
specified in the Syntax Definition Formalism (SDF) using conditional
equations specified in the Algebraic Specification Formalism (ASF).
Because the concrete syntax of the source and target language of a
transformation are formally defined in SDF, syntax-safety of the
input and output of a transformation is guaranteed. This implies that
every syntactically correct ACP model is transformed into a
syntactically correct XMI document representing a state machine that
preserves structural and behavioral properties. Syntax-safety also
implies that every ACP model that is syntactically incorrect is not
transformed at all. ← for future work, do this in spare time!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Note
that trace equivalence is in general only one aspect of semantic
equivalence. Without providing a formal semantics for the UML we
cannot guarantee that we have bridged the semantic gap completely.
Since there are many formalisms with different (or without) formal
semantics, there are probably many model transformations that are not
proven to be semantics preserving. Proving that a model
transformation preserves semantics requires different expertise. ←
for ppt!!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">We
have used the term rewriting system ASF+SDF to implement a
transformation from ACP without encapsulation to UML state machines.
This required us to define metamodels for both ACP and UML state
machines. We have created a metamodel for ACP and for UML state
machines without history mechanism. The modular implementation of our
transformation has proven to be useful for decreasing the complexity.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">We
have used the term rewriting system ASF+SDF to implement a
transformation from ACP without encapsulation to UML state machines.
This required us to define metamodels for both ACP and UML state
machines. We have created a metamodel for ACP and for UML state
machines without history mechanism. The modular implementation of our
transformation has proven to be useful for decreasing the complexity.
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Since
our transformation preserves most structure of ACP models, UML tools
can be used for visualizing this structure. ← for future
work/paper; we preserve the structure</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
have considered ACP without the encapsulation operator (∂). The
next thing to consider is the transformation of the encapsulation
operator. This makes the semantic gap even larger. The encapsulation
operator prevents certain actions from being executed, which cannot
be expressed in a state machine. This requires an extension of the
action dispatcher such that it forbids the execution of encapsulated
actions. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Software
Model Checking Takes Off</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Although
formal mehtods have been used in the development of safety- and
security-critical systems for years, they have not achieved
widespread industrial use in software or systems engineering.
However, two important trends are making the industrial use of formal
methods practical. The first is the growing acceptance of model-based
development for the design of embedded systems. Tools such as MATLAB
Simulink6 and Esterel Technologies SCADE Suite2 are achieving
widespread use in the design of avionics and automotive systems. The
graphical models produced by these tools provide a formal, or nearly
formal, specification that is often amenable to formal analysis. The
second is the growing power of formal verification tools,
particularly model checkers. For many classes of models they provide
a “push-button” means of determining if a model meets its
requirements. Since these tools examine all possible combinations of
inputs and state, they are much more likely to find design errors
than testing. ← for ppt!</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Here,
we describe a translator framework developed by Rockwell Collins and
the University of Minnesota that allows us to automatically translate
from some of the most popular commercial modeling languages to a
variety of model checkers and theorem provers. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Model-based
development (MBD) refers to the use of domain-specific, graphical
modeling languages that can be executed and analyzed before the
actual system is built. The use of such modeling languages allows the
developers to create a model of the system, execute it on their
desktops, analyze it with automated tools, and use it to
automatically generate code and test cases.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">There
are many types of model checkers, each with their own strengths and
weaknesses. Explicit state model checkers such as SPIN construct and
store a representation of each state visited. Implicit state
(symbolic) model checkers use logical representations of sets of
states (such as Binary Decision Diagrams) to describe regions of the
model state space that satisfy the properties being evaluated. Such
compact representations generally allow symbolic model checkers to
handle a much larger state space than explicit state model checkers.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">These
translators work primarily with the Lustre formal specification
language, but this is hidden from the users. The starting point for
translation is a design model in MATLAB Simulink/Stateflow or Esterel
Technologies SCADE Suite/Safe State Machines. SCADE Suite produces
Lustre models directly. Simulink or Stateflow models can be imported
using SCADE Suite or the Reactis tool and a translator developed by
Rockwell Collins. To ensure each Simulink or Stateflow construct has
a well-defined semantics, the translator restricts the models that it
will accept to those that can be translated unambiguously into
Lustre.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
translators produce highly optimized specifications appropriate for
the target language. For example, when translating to NuSMV, the
translator eliminates as much redundant internal state as possible,
making it very efficient for BDD-based model checking. When
translating to the PVS theorem prover, the specification is optimized
for readability and to support the development of proofs in PVS. When
generating executable C or Ada code, the code is optimized for
execution speed on the target processor.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">..</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">While
very complex, the WM is specified in Simulink using only Booleans and
enumerated types, making it ideal for verification using a BDD-based
model checker such as NuSMV. Ultimately, 563 properties about the WM
were developed and checked, and 98 errors were found and corrected in
early versions of the WM model. This verification was done early in
the design process while the design was still changing. By the end of
the project, the WM developers were checking the properties after
every design change.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
similar fashion, the testing team developed a series of tests from
the same OFP requirements. Even though the testing team invested
almost half as much time in testing as the formal verification team
spent in model checking, testing failed to find any errors. The main
reason for this was that the demonstration was not a comprehensive
test program. While some of these errors could be found through
testing, the cost would be much higher, both to find and fix the
errors. In addition, the errors found through model checking tended
to be intermittent, near simultaneous, or combinatory sequences of
failures that would be very difficult to detect through testing. The
conclusion of both teams was that model checking was shown to be more
cost effective than testing in finding design errors. Because of its
extensive use of floating point numbers and large state space, the EB
cannot be verified using a BDD-based model checker such as NuSMV.
Instead, the EB was analyzed using the Prover SMT-solver from Prover
Technologies. Even with the additional capabilities of Prover,
several new issues had to be addressed, the hardest being dealing
with floating point numbers.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">While
this allowed the EB to be verified using Prover’s bit-level integer
decision procedures, the results were unsound due to the loss of
precision. However, if errors were found in the verified model, their
presence could easily be confirmed in the original model. This
allowed the verification to be used as a highly effective debugging
step, even though it did not guarantee correctness. In particular,
even very complex models can be verified with BDD-based model
checkers if they consist primarily of Boolean and enumerated types.
Every industrial system we have studied contains large sections that
either meet this constraint or can be made to meet it with some
alteration.</SPAN></FONT></FONT></FONT></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">A
Survey of Automated Techniques for Formal Software Verification</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">This
paper surveys algorithms that perform automatic static analysis of
software to detect programming errors or prove their absence. The
three techniques considered are static analysis with abstract
domains, model checking, and bounded model checking. A short tutorial
on these techniques is provided, highlighting their differences when
applied to practical problems.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
method should be highly automated and scalable to cope with the
enormous complexity of software systems. &lt;-- &nbsp;for ppt: well
we achieve (1), but struggling with (2); </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">also
for ppt: highly automated vs fully automated</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">As
the state space of software programs is typically too large to be
analyzed directly, model checking is often combined with abstraction
techniques. We survey predicate abstraction, a popular abstraction
technique for software model checking. BMC explores program behavior
exhaustively but only up to a given depth. Bugs that require longer
paths are missed. Thus, the essence of static analysis is to
efficiently compute approximate but sound guarantees: guarantees that
are not misleading. Due to the undecidability of static analysis
problems, devising a procedure that does not produce spurious
warnings and does not miss bugs is not possible. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Static
analysis techniques typically propagate a set of values through a
program until the set saturates, i.e., does not change with further
propagation. Mathematically, such analyses are modeled as iterative
application of a monotone function. Saturation occurs when a fixed
point of the function is reached. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">An
abstract domain is an approximate representation of sets of concrete
values. An abstraction function is used to map concrete values to
abstract ones. An abstract interpretation involves evaluating the
behavior of a program on an abstract domain to obtain an approximate
solution. An early popular static analysis tool for finding simple
errors in C programs is LINT, released in 1979 by Bell Labs. Several
modern tools emulate and extend LINT in terms of the kind of errors
detected, warnings provided, and user experience. FINDBUGS for Java
is a notable modern tool with similar features. We mention LINT and
FINDBUGS because of their significance and influence on static
analysis tools. However, these tools are unsound and provide no
rigorous guarantees, so we do not discuss them further. Several tools
require annotations such as types, pre- and postconditions, and loop
invariants to be provided. Annotations may reduce the information
that the static analyzer has to compute and improve its precision,
but increase the burden on the programmer. This approach is used to
varying degrees in the (ESC/Java) tool family [61] and Microsoft’s
PREFIX and PREFAST [89]. The annotation and verification mechanism
has been integrated in programming languages and development
environments such as SPARK [16] and SPEC# [17] to make writing
annotations a natural part of programming. We only mention these
techniques for completeness. Unlike in model checking, generating
counterexamples is difficult or even impossible, due to the precision
loss in join and widening operations, and is a current research topic
</SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Model
checking is an algorithmic method for determining if a model of a
system satisfies a correctness specification [36], [97]. A model of a
program consists of states and transitions. A specification or
property is a logical formula. A state is an evaluation of the
program counter, the values of all program variables, and the
configurations of the stack and the heap. Transitions describe how a
program evolves from one state to another. Model checking algorithms
exhaustively examine the reachable states of a program. This
procedure is guaranteed to terminate if the state space is finite. If
a state violating a correctness property is found, a
counterexample—an execution trace demonstrating the error—is
produced. Due to their diagnostic value, counterexamples, to quote
Clarke and Veith [35], “. . . are the single most effective feature
to convince system engineers about the value of formal verification.”
← great for ppt!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">However,
theoretical results have shown that static analysis methods can be
cast as model checking algorithms and vice versa [102], [104]. In
practice, static analyzers and model checkers still differ in their
applicability and capabilities. Nonetheless, modern static analyzers
support specification mechanisms, and software model checkers use
abstraction and operate on a program code, so the practical
distinction may cease to be meaningful as well.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Explicit-state
model checking algorithms directly index states and use graph
algorithms to explore the state space, starting from the initial
states. Symbolic model checking algorithms use implicit
representations of sets of states and may start from the initial
states, error states, or the</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">property.
We briefly describe both techniques. Explicit-state methods construct
a state transition graph by recursively generating successors of
initial states. The graph may be constructed in a depth-first,
breadth-first, or heuristic manner. New states are checked for a
property violation on-the-fly, so that errors can be detected without
building the entire graph. Explored states are compressed and stored
in a hash table to avoid recomputing their successors. If the
available memory is insufficient, lossy compression methods can be
used. Bit-state hashing or hash compaction uses a fixed number of
bits from the compressed image of a state [74]. This may cause hash
collisions, which lead to error states being missed. In practice,
with state spaces containing close to a billion states, and hash
tables of several hundred megabytes, the probability of missing a
state can be less than 0.1%.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Partial
order reduction is a method to prune the state-space exploration of
concurrent programs [62]. The order in which instructions in
different threads are executed may not matter for proving some
properties. Transitions whose interleavings do not affect the
property can be grouped into classes. A model checker only needs to
generate one representative of each class while constructing the
state graph. In the best case, partial order reduction can reduce the
state space to be explored by a factor that grows exponentially in
the number of threads. ← for ppt?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Symbolic
model checking methods represent sets of states rather than
enumerating individual states. Common symbolic representations are
Binary Decision Diagrams (BDDs) [27] and propositional logic for
finite sets [24] and finite automata for infinite sets [82]. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
BDD is obtained from a Boolean decision tree by maximally sharing
nodes and eliminating redundant nodes. For a fixed variable ordering,
BDDs are canonical, permitting Boolean function equivalence,
essential in model checking, to be checked efficiently. However, BDDs
grow very large. The issues in using finite automata for infinite
sets are analogous. Symbolic representations such as propositional
logic formulas are more memory efficient, at the cost of computation
time. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Symbolic
techniques work well for proving correctness and handling state-space
explosion due to program variables and data types. Explicit-state
techniques are well suited to error detection and handling
concurrency. An orthogonal approach to counter state-space explosion
is abstraction. It suffices to analyze a sound abstraction of the
program, with a smaller state space. Abstractions were manually
constructed but are constructed automatically in recent tools.
Automated abstraction is based on abstract interpretation. Since
model checking examines every possible combination of input and
state, it is also far more effective at finding design errors than
testing, which can only check a small fraction of the possible inputs
and states. ← ppt?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">As
discussed in the CerTA FCS Phase II case study, the verification of
very large models may be achieved by using model checking on
subsystems and more traditional reasoning to compose the subsystems.
Combining model checking and theorem proving in this way could be a
very effective approach to the compositional verification of large
systems.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Promoted
by the success of the SLAM toolkit [10], predicate abstraction is
currently the &nbsp;predominant abstraction technique in software
model checking. PROMELA supports simple data types, nondeterministic
assignments and conditionals, simple loops, thread creation, and
message passing. SPIN operates on-the-fly and extensively uses
bit-state hashing and partial order reduction. Recent versions of JPF
analyze the byte code of Java programs directly and handle a much
larger class of Java programs than the original implementation. JPF
also supports symbolic techniques but only for software-testing
purposes. The Bandera tool supports</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">state
abstraction but does not fully automate it [57]. The VERISOFT
software verification tool attempts to eschew state explosion by
discarding the states it visits [63]. Since visited states are not
stored, they may be repeatedly visited and explored. This method is
state-less and has to limit the depth of its search to avoid
nontermination. This approach is incomplete for transition systems
that contain cycles. One of the first implementations of BMC for C
programs is CBMC [38], [83] developed at CMU; it emulates a wide
range of architectures as environment for the design under test. It
supports both little- and big-Endian memory models, and the header
files needed for Linux, Windows, and Mac-OS X. It implements loop
unrolling as described in Section IV-C, thus avoiding the exponential
blowup that is inherent in path enumeration. SATURN is a specialized
implementation of BMC, which is tailored to the properties it checks
[108]. It implements loop unwinding as described in Section IV-C. The
authors have applied it to check two different properties of Linux
kernel code: NULL-pointer dereferences and locking API conventions.
They demonstrate that the technique is scalable enough to analyze the
entire Linux kernel. Soundness is relinquished for performance;
SATURN performs at most two unwindings of each loop. Bugs that
require more than two unwindings are missed.</SPAN></FONT></FONT></FONT></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">GENERATING
PROPERTIES FOR RUNTIME MONITORING FROM SOFTWARE SPECIFICATION
PATTERNS</SPAN></FONT></FONT></FONT></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Relating
computer systems to sequence diagrams: the impact of
underspecification and inherent nondeterminism. </SPAN></B></FONT></FONT></FONT>
</P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Having
a sequence diagram specification and a computer system, we need to
answer the question: Is the system compliant with the sequence
diagram specification in the desired way? We present a procedure for
answering this question for sequence diagrams with underspecification
and inherent nondeterminism. The procedure is independent of any
concrete technology, and relies only on the execution traces that may
be produced by the system. If all traces are known, the procedure
results in either “compliant” or “not compliant”. If only a
subset of the traces is known, the conclusion may also be “likely
compliant” or “likely not compliant”.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Intuitively,
a system is compliant with a specification if the behaviours of the
system are as described by the specification. The system should
potentially be able to perform every behaviour that the specification
requires it to offer, and it should do nothing that the specification
disallows.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
question of compliance is essential every time a computer system is
built from a specification. Even so, the relationship between
sequence diagrams and computer systems is surprisingly unclear. An
important reason for this, is that sequence diagrams (in contrast to
most other techniques for specifying dynamic behaviour) give only a
partial view of the behaviour. Also, sequence diagrams are used for
specifying computer systems within a broad range of application
domains, and they are used for different methodological purposes
including requirements capture, illustrating example runs, test
scenario specification and risk scenario documentation.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">In
this paper we investigate compliance with respect to two classes of
sequence diagrams: Sequence diagrams with underspecification and
sequence diagrams with both inherent nondeterminism and
underspecification. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
first class may be used to capture trace properties, i.e., </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">properties
that can be falsified by a single trace. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Examples
of trace properties include safety and liveness properties. The
second class is also able to capture trace-set properties, which are
properties that can only be falsified by sets of traces. Inherent
nondeterminism, on the other hand, means that the system must be able
to produce all of the described alternatives.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">This
section provides a general introduction to sequence diagrams with
underspecification (but not inherent nondeterminism, which is treated
in Sect. 5), and their semantic model as defined in STAIRS [HHRS05].
For further details of the STAIRS semantics of sequence diagrams, we
refer to</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">[HHRS05,
RHS05b] </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">and
the summary in Appendix A. This formal semantics is compliant with
the semi-formal descriptions given in the UML 2.x standard [OMG10]. ←
found and printed those two papers!</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">This
example demonstrates that for alternatives specified as
underspecification (e.g. using the alt operator), the computer system
is not required to 604produce more than one of these. To require the
system to produce all alternatives, we need the xalt operator that
will be described in Sect. 5. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">As
can be seen from the definition, a refinement step may add more
positive and/or negative behaviours to the specification, hence
reducing the set of inconclusive traces. Also, a refinement step may
reduce underspecification, i.e., redefine positive traces as
negative. Negative traces always remain negative. A computer system
that complies with a sequence diagram resulting from a series of
refinement steps, will also comply with the original sequence
diagram. In the case of underspecification (and no inherent
nondeterminism) investigated above, a system may comply with a given
sequence diagram even if the system is able to produce only one of
the positive traces in the diagram, and nothing else. In most cases
this is of course not satisfactory, as one would like to specify a
set of behaviours that should all be reflected in the implementation
in one way or another. One example is the gambling machine from Sect.
4.3, where the sequence diagram allowed a system where the only
possible outcome was the user losing his money. A realistic
specification would be to require that both winning and losing should
be possible outcomes. Also, the choice between the two should be
performed nondeterministically (or at least appear so to the user of
the gambling machine).</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
ref-construct may be understood as a syntactical shorthand for the
contents of the referenced sequence diagram. &lt;-- for ppt?</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">[
blabla theorems etc....]</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
the work by Kruger [Kru00], a variant of Message Sequence Charts
(MSC) is given a formal semantics and provided a formal notion of
refinement. Four different interpretations of MSC are proposed,
referred to as the existential, universal, exact, and negative
interpretation. The existential interpretation requires the
fulfilment of the MSC in question by at least one system execution,
while the universal interpretation requires the fulfilment of the MSC
in all executions.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Uchitel
et al. [UBC07] present a technique for generating Modal Transition
Systems (MTSs) from a specification given as a combination of system
properties and scenario specifications. System properties, such as
safety or liveness properties, are universal as they impose
requirements on all of the execution traces, and are in [UBC07]
specified in Fluent Linear Temporal Logic. Scenario specifications
are existential as they provide examples of intended system
behaviour, and are specified in the form of MSC. Live sequence charts
(LSC) [DH01, HM03] is an extension of MSC that particularly address
the issue of expressing liveness properties. LSC support the
specification of two types of diagrams, referred to as existential
and universal diagrams. An existential diagram describes an example
scenario that must be satisfied by at least one execution trace,
whereas the scenario described by a universal diagram must be
satisfied by all execution traces. Modal sequence diagrams (MSD)
[HM08] is defined as a UML 2.x profile. The notation is an extension
of the UML sequence diagram notation based on the
universal/existential distinction of LSC. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
main motivation for the development of the MSD language is the
problematic definitions of the assert and negate constructs of UML
sequence diagrams.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
authors observe that the UML 2.x specification is contradictory in
the definition of these constructs, and also claim that the UML trace
semantics of valid and invalid traces is inadequate for properly
supporting an effective use of the constructs</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">.
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Grosu
and Smolka [GS05] interpret positive and negative sequence diagrams
as specifying liveness and safety properties, respectively. This is a
much stronger interpretation than the traditional use of sequence
diagrams for illustrating example runs. Based on several
transformation steps, the semantics of sequence diagrams is defined
as two Buchi automata, one for the positive and one for the negative
behaviour. The approach is based on composing simple sequence
diagrams without composition operators into high-level sequence
diagrams, i.e., interaction overview diagrams. A valid trace is
allowed to have any suffix, and events not explicitly mentioned in
the diagram may be interleaved with the specified events. Refinement
is defined as language inclusion, and the most common composition
operators are shown to be monotonic with respect to this refinement
notion. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">(found
the paper!) </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">There
exists also other works on the semantics of sequence diagrams.
However, to the best of our knowledge none of these include a
distinction between underspecification and inherent nondeterminism or
work on refinement and the relationship between computer systems and
sequence diagrams. In general, the semantics is also far from the
informal description given in the UML 2.x semantics.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
CSP [Hoa85, Ros98], there are two different operators for
nondeterminism, referred to as internal and external nondeterminism,
respectively. With internal nondeterminism, the system is free to
choose whether it should offer all alternatives or only one (or some)
of them. The choice may be performed at run-time, making the system
nondeterministic, but the choice may also be made by the implementer,
resulting in a deterministic system. For external nondeterminism
(also called environmental choice), the behaviour is determined by
the environment and the system must be able to perform all
alternatives. If sequence diagrams are to be used as formal
specifications, it is important to know how to evaluate whether a
given computer system is compliant with the sequence diagram or not.
To the best of our knowledge, our work is the first to address this
in detail. Sequence diagrams are different from most other techniques
for specifying dynamic behaviour in that they usually give only a
partial view. The approach is faithful to the UML 2.x standard, both
with respect to the underlying semantic model using sets of positive
and negative traces, and with respect to the semantics given for each
concrete operator. In particular, all of our definitions take into
account the partial nature of sequence diagrams. The compliance
checking procedure is independent of any particular programming
language or paradigm. All we require, is that there exists some means
to obtain (a subset of) the execution traces of the system. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">In
this paper we have only considered sequence diagrams without external
input and output. Our results may be generalized to handle also
sequence diagrams with such external communication by in each case
defining an adversary representing the environment of the system, and
then checking compliance under the assumption of this adversary. ←
for ppt: adversary representing the environment of the system, and
then checking compliance under the assumption of this adversary </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">To
make practical use of the theoretical work presented in this paper,
tool support is obviously needed. We have plans to extend the
Escalator tool developed by Lund [Lun08, Lun09] to facilitate testing
according to our procedure and guidelines. This will furthermore
allow us to investigate the feasibility and usefulness of the
proposed procedure in empirical studies. ← !! no tool support yet!</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">------------------------------</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">Formal
Verification and Validation of UML 2.0 Sequence Diagrams using Source
and Destination of Messages</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">For
presentation VERY RELEVANT</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">SD-&gt;SPIN
via Eclipse</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">it’s
like a copy of our paper; Section 3 most important for properties,
how to express them; </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">could
use it to shorten intro on SD in my paper; PAR fragments as
sub-processes with token synchronization</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">trace
semantics of combined fragments [most popular ones] ← maybe I have
referenced it already! → </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">lifeline
is a process; combined fragments interesting ideas;</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">good
examples of LTL properties over SDs!</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">performance
metrics for the property checks useful for NASA paper’</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">BREAK
operator with goto statements in PROMELA</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">guards
are defined globally, not very nice</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">flag-based
technique as a trick to find out who is sending/receiving what and
to/from whom. This is useful for writing properties to be verified </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">synchronization
mechanism must be implemented to ensure that no event after the
combined PAR fragment will overtake an event in it ← for my
eventual implementation</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">This
paper presents a formal V&amp;V technique for one of the most popular
UML diagrams: sequence diagrams. The proposed approach creates a
PROMELA-based model from UML interactions expressed in sequence
diagrams, and uses SPIN model checker to simulate the execution and
to verify properties written in Linear Temporal Logic (LTL). </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
whole technique is implemented as an Eclipse plugin, which hides the
model-checking formalism from the user. (for ppt. also the following)</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
main contribution of this work is to provide an efficient mechanism
to be able to track the execution state of an interaction, which
allows designers to write relevant properties involving send/receive
events and source/destination of messages using LTL. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Another
important contribution is the definition of the PROMELA structure
that provides a </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">precise
semantics of most of the newly UML 2.0 introduced combined fragments,
allowing the execution of complex interactions.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
this study, we focus on formal V&amp;V of one type of UML diagrams:
sequence diagrams. UML sequence diagrams are behavioral diagrams used
to specify interactions among system entities in many different
situations. They are used to get a better grip of an interaction
situation for an individual designer or for a group that needs to
achieve a common understanding of the situation [10]. Along with
class diagrams and use case diagrams, sequence diagrams are the most
popular diagrams of UML [23].</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
ppt:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Though,
most of the proposed approaches target only activity and state
machine diagrams [4, 8, 9, 12, 14, 16, 19, 20]. There are some
approaches targeting sequence diagram [2, 23]. However, when it comes
to interactions, it is important to analyze the type of messages
being exchanged, as well as their source and destination, and their
send and receive events. The proposed approaches targeting sequence
diagram mainly focus on getting a formal representation of
interactions, and they miss a well-defined methodology to analyze all
these important elements. Moreover, those works either do not take
into account UML combined fragments (components newly introduced to
UML 2.0 that allow designers to describe a number of traces in a
compact and concise manner [17]) or their semantics models are not in
accordance with the semantics defined in the UML 2.0 specification.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Consequently,
it gives them flexibility to write very expressive properties.
Another important contribution is the definition of the PROMELA
structure that provides a precise semantics of most of the newly UML
2.0 introduced combined fragments, allowing the execution of complex</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">interactions.
It allows the developer to simulate much more complex sequence
diagrams, with non-straightforward execution trace. The result of
these contributions is an efficient approach which is capable of
detecting more flaws on more complete and complex interactions.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
proposed approach creates a PROMELA-based model from UML interactions
expressed in sequence diagrams, and uses SPIN model checker to
simulate the execution and to verify properties written in Linear
Temporal Logic (LTL). (for ppt and future work maybe, because mCRL2
has not so intuitive, or not even existent, sending/receiving
primitives) </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">PROMELA/SPIN
was chosen because it provides important concepts (sending and
receiving primitives, parallel and asynchronous composition of
concurrent processes, and communication channels) that are necessary
to implement sequence diagrams [15]. This makes the implementation
easier since the communication primitives and channels are already
available in PROMELA and it does not need any extra effort to
implement them. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
whole technique is implemented as an Eclipse 3 plugin, which hides
the model-checking formalism from the user and allows the V&amp;V
engine to be embedded into the development environment.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
this section, we briefly present the PROMELA representation of the
basic elements of sequence diagrams as defined in [15, 22]. for ppt:
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Then
we present the trace semantics of the most popular combined fragments
and their respective PROMELA code that correctly simulates the
execution traces. The composition of the presented translation rules
allows the simulation of complex interactions with interesting and
non-straightforward execution trace.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
PROMELA elements used for representing basic components of
interactions are: (1) proctype: it is used for declaring new process
behaviour, (2) mtype: it defines symbolic names of numeric constants
that are used as messages in the communicating process. (3) cham: it
declares and initializes communication channels. Finally, (4) !/?
operators: Theses symbols are used for sending/receiving messages
to/from channels, respectively.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
communication primitives available in PROMELA naturally implements
the seq operator following the translation map shown in table 1. This
is one of the main reasons for choosing PROMELA/SPIN for model
checking of sequence diagrams. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt: Alternative and Option combined fragments represent a choice of
behaviour in sequence diagrams. The opt operator designates that the
combined fragment represents a behaviour choice where either the sole
operand happens or nothing happens. An option is semantically
equivalent to an alternative combined fragment where there is one
non-empty operand and the second operand is empty [17]. The set of
traces that defines a choice is the union of the traces of the
operands [10, 17].</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt: Alternative and Option operator are represented as if condition
in PROMELA. The guard variable is declared globally to enforce all
lifelines to get the same decision at the choice point. ← globally,
not convenient</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
Parallel Combined Fragment, denoted by par operator, represents a
parallel merge between the behaviours of the operands.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Parallel
behaviour can be implemented using sub-instances of the lifelines
covered by the parallel fragment (Fig. 4(b), lines 9 and 11). The new
element is instantiated right before the main process starts the
parallel activities. A synchronism mechanism should be implemented to
ensure that no event after a combined fragment will overtake an event
in it. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
main process must wait for all tokens before continuing the execution
(Fig. 4(b), lines 4 and 8). Fig. 4(b) shows the PROMELA code of the
model in Fig. 4(a).</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
operator loop indicates that the combined fragment represents a
repetition structure. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Our
PROMELA implementation of loop works with a fixed number of
repetition. PROMELA defines do operator as a repetition construct.
Loop fragments are implemented by declaring a global variable with
the total number of repetition,</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">and
a do structure in each lifeline covered by the fragment. &lt;-- for
ppt: when you implement iteration, you don’t write a for cycle in
each of the objects, do you?</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
interaction operator </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">break</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">shows
a combined fragment representing a breaking scenario. If the guard
condition is true, the operand scenario is performed instead of the
remainder of the enclosing interaction fragment. The break operator
can be simulated with goto statements in PROMELA. If</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">the
guard condition is true, the action inside the break combined
fragment is performed, then the execution jumps to the end </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">(</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">from
my notes on fig 6: process b has to know there is a guard, not very
natural)</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Indeed,
the system</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">state
does not change when messages are sent over channels [23]. To
overcome this obstacle, [23] proposed a flag-based technique to mark
an occurrence of a send/receive event. This section presents an
extension of this approach that is able to determine who is
sending/receiving what to/from whom at any time of the execution.
This information is very useful when one wants to write properties to
be verified. We also show how to write LTL properties using this
approach. ← “a trick” to actually get what we can naturally do
with event based temporal logic.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
properties! Excellent brainstorm:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
spite of the fact that they improved the set of properties thatcan be
verified, many other properties are still not covered since they
require the information of the entities the are interacting (e.g.,
the following constraint could be specified to a particular system:
“Alice is not supposed to receive a request from Bob”). In [2],
the authors define the concatenation of sender,</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">message
and receiver as one action, but they do not include send and receive
events. Even though it provides the entities information, it does not
give the flexibility to write properties looking only at a particular
element in the model. (e.g., Server does not send anything to anyone
without signing). This flexibility is important because systems
usually have many entities, but only some of them are really
critical. To address these weaknesses, we define a state transition
system such that the transitions are triggered by the send and
receive events of the interaction and each state is characterized by
a 4-tuple consisting of the following fields:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">(i)
Lifeline that performed the last action.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">(ii)
Last performed action (send or receive).</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">(iii)
Message used in the last action.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">(iv)
Lifeline to/from which the message was sent/received.</SPAN></FONT></FONT></FONT></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
update is done using a d step statement to make the assignment of all
new values as one step at the execution time. After defining a
methodology to track the execution state, LTL formulas can be written
in terms of boolean expressions over the flags. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">&nbsp;</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">A
very useful property of the flag-based state is the ease of
expressing sentence over all lifelines, or all messages, or all
actions only by omitting the respective element in the expression</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">.
For example, if one wants to verify if “no lifeline receives
messages from a”, the respective expression is: ¬(receive∧proc2
a). ← your translation should also support, with wildcards. but
this is state-based, that’s why the hack </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
order to illustrate the performance of our approach regarding this
case study, Table 2 shows a summary of the results along with the
number of states, number of transitions, memory and time used by SPIN
to perform the verification. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
tool is implemented as an Eclipse plugin composed of three main
parts:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">(i)
A property editor to allow the developer to assign properties to UML
diagrams.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">(ii)
A UML translator to generate the PROMELA code from UML interaction.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">(iii)
A result interpreter to read the output of the SPIN model checker and
translate it into an easy-to-understand graph to be analysed by the
developer.</SPAN></FONT></FONT></FONT></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt: Second, many security aspects are not usually encapsulated in
only one type of diagram. Normally they are scattered in various
diagrams of different kinds. An inter-diagram analysis might provide
results that are much more consistent in the assessment of UML
models.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">------------------------------<BR></SPAN></I></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: #ffffff">A
True-Concurrent Interpretation of Behavioural Scenario</SPAN></I></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
(informal) semantics of a SD is given in terms of partial order on
the events appearing in that interaction SD. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">You
cannot rely on a graphical notation for formal specificaiton; formal
notation with well defined semantics is needed; </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">too
theoretical, formulas all over;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">NOT
OK, invalid SDs considered [fig 4]; they use some expressive
“component vectors” to model a component that offers/requires
services concurrently; good simple explanation of SDs, could be
useful for ppt or paper; </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">component
language: describes the intended behavior, indicates possible
constraints on the order in which operations can/should be called;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">focus
is on a single lifeline as a component, to obtain the vector-language
part; events on a lifeline: starting and ending points of a combined
fragment ← unique</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Current
approaches based on interleaving semantics and do not consider
component as having multiple access points;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">translation
UML 2.0 SDs into </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">component
vectors </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">←
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">map
all locations along a lifeline into (a set of) component vectors;
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">“</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">interleaving
semantics” - two events may not occur at exactly the same time; for
PPT: locations with different visual time along the vertical axis may
still ahve the same occurrence time [par fragments, different SDs]
&lt;-- for ppt?</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
describe a translation of scenarios given in UML 2.0 sequence
diagrams into a tuples-based behavioural model that considers
multiple access points for a participating instance and exhibits
true-concurrency. Interactions specified in a scenario are modelled
using tuples of sequences, one sequence for each access point. In
previous work, we have described how (sets of) vectors generate
concurrent automata. The extension to our model with sequence
diagrams in this paper provides a way to verify the diagram against
the state-based model.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
overall system functionality is the result of, often complex and
highly concurrent, interactions between components of the system. A
thorough understanding of the behaviour exhibited at the interfaces
of a component can increase expectations of a successful outcome
prior to deployment. A component in pragmatic approaches to software
design such as UML [12] or the Koala component model [15] is
understood as having multiple access points (i/o ports) through which
it provides and requires services, by interacting with other
components. UML2.0 sequence diagrams, Message Sequence Charts (MSc)
[5] and</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Live
Sequence Charts (LSCs) [2] are the mainstay of industrial software
specifications describing interactions within the context of a given
scenario. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">for
ppt: The (informal) semantics of a sequence diagram defined in any of
the above notations is given in terms of a partial order on the
events appearing in the interaction described in the diagram.
Although useful, the graphical notation alone cannot be relied upon
for rigorous analysis and formal verification. Scenarios need to be
translated into some other, more formal, notation with a well-defined
behavioural semantics. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">for
ppt: Current approaches seem to be geared towards an interleaving
semantics and also do not consider participating instances
(components) as having multiple access points (ports). </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
a component setting, different ports of a component are connected to
different components, which have no knowledge of each other, and thus
the case that services are requested/offered at the same time cannot
be reasonably excluded. A non-interleaving interpretation of
concurrency [16] considers such cases and can faithfully describe
concurrent interactions.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Component
interactions are modelled</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">using
tuples of sequences, one for each access point. These so-called
component vectors are expressive enough to model the component
offering or requiring services concurrently through its multiple
ports. Such vectors, formed over a given component signature Σ (cf
Definition 3.1), give rise to a certain class of automata [11] in
which concurrency is expressed as an explicit structural property. Of
course, we are interested in that subset of all possible component
vectors over Σ that describes intended behaviour only. ←
concurrent automata</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
this paper we describe a formal translation of scenarios given in
UML2.0 sequence diagrams into component vectors. We give a
mathematical construction for the unfolding of scenarios into vector
languages, based on a non-interleaving semantics for sequence
diagrams.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
formalisation of the information conveyed by a UML sequence diagram,
including the constructs for expressing parallel and alternative
scenarios, is based on that found in [8], which includes notation for
moving down the diagram and identifying any particular constructs. In
the context of components, we are interested in the intended
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">behaviour
of a component </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">and
thus we adopt the formal definition of a sequence diagram given in
[8] </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">to
a single lifeline</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">rather
than the diagram as a </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">whole.
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">In
our formal model of components, the system behaviour exhibited during
the </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">execution
of the scenario as a whole is then given in terms of composition of
the components involved, as described in [10]. &lt;-- for ppt?
somewhat same as my approach</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">SDs
describe a behavioural view of a system showing the interactions
between objects or components in the system. In a nutshell, a
sequence diagram displays participating instances as lifelines
running down the page (dashed vertical lines in Fig. 1) and their
interactions over time are represented as messages drawn as
horizontal arrows between lifelines. Each sending/receiving of a
message is associated to an event of the sender/receiver. Sequence
diagrams in UML 2.0 [12] have been considerably revised in relation
to those in previous versions of UML. They have been extended to
include features from MSCs [5] and, to a lesser extent, from LSCs [2]
and as a result they are more expressive and fundamentally better
structured.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">One
of the major changes has to do with the introduction of
sub-interactions called interaction fragments which can be combined
using interaction operators. Interaction fragments may comprise one
or more operands (compartments) depending on the corresponding
interaction operator. For example, the alt operator designates that
the corresponding interaction fragment represents a choice between
alternative scenarios. The seq interaction operator (default for
sequence diagrams) designates that the interaction fragment specifies
a sequencing between the corresponding event occurrences. The PAR
interaction operator is used to represent parallel execution of the
behaviours from different operands and the resulting par interaction
fragment models concurrent interactions. &nbsp;←</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">how
about animation that merges (overlaps) two SDs to express that they
could be happening in parallel? for ppt</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
any behaviour of the system, each port will experience </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">sequences
of events (&lt;-- they can be also at the same time??)</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">(calls
to interface operations) formed over the corresponding set β(p). We
simply describe the behaviour of the component as a whole by
assigning such sequences to each of its ports.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Thus,
a component consists of the static structure described by a signature
Σ together with a ’language’ V of component vectors, formed over
Σ. Intuitively, the idea is that the component language describes
the intended behaviour in that it indicates possible constraints on
the order in which the operations of the component can or should be
called.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
PPT:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Effectively,
the independence relation implies that behaviours which may happen
concurrently engage distinct ports of the component. In
component-based development, different ports of the component will be
connected to different components which have no knowledge of each
other and thus cannot be expected to respect any particular ordering
in issuing requests over their allocated port. It is important to
note that independence alone does not guarantee concurrency - there
is the additional requirement that the events concerned are both
offered after some behaviour and occur consecutively. ←</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">weird
though, why only distinct ports of the component?</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
describing component interactions, we are interested in event
occurrences over ports of the component. These are captured in our
formalism using a specific kind of component vectors, termed column
vectors, which have at most one event per coordinate.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
describe the unfolding of scenario-based specifications into
component vectors. Our primary objective is to capture the intended
behavior of the component, in terms of its interactions over ports as
specififed in sequence diagrams, and use that to restrict to an
appropriate subset V of all possible component vectors VΣ formed
over a given component signature Σ.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
approach we advocate uses UML2.0 sequence diagrams - with a
non-interleaving semantics, together with a flavour of LSCs - for
specifying the allowed sequences of events over the multiple ports of
a component. The idea is to capture the observed behaviours at each
point (graphical position) in a sequence diagram by mapping them onto
component vectors.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
practice a component will appear in several sequence diagrams. UML
2.0 [12] includes Interaction Overview Diagrams (IODs) which generate
a single sequence diagram. We therefore assume a single sequence
diagram for a component c. &nbsp;← </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">whaa</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">?</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">An
alt interaction fragment in a sequence diagram represents choice of
behaviour, the choice being between the behaviours described by each
of its operands. Recall that at most one of the operands executes. At
the end of an alt fragment we need to capture the fact that there are
n alternative scenarios the component may have engaged in. We do this
by associating the end location of an alt with the component vectors
of the last location of each operand.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">ppt:
</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Another
way of expressing this is by saying that locations from different
operands are reached in no particular order. This perception of
parallelism is rooted in the formal treatment of concurrency, via an
independence relation [13], within our the oretical framework.
Independent events that are enabled, and occur consecutively, are
concurrent.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">This
is to reflect the fact that event occurrences appearing in different
operands of par are effectively unordered (in parallel).</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Fundamentally,
not all properties for concurrent systems can be expressed and</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">verified
without considering true-concurrency. Following an interleaving
interpreta-</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">tion,
it is not possible (to the best of our knowledge) to differentiate
between the</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">behaviours
described in the sequence diagrams of Fig. 6. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">a
|| b = a.b + b.a + a|b ← multiation, true concurrency, </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">not</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">interleaving
semantics</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">------------------------------</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">Tool
Support for fUML Models</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">m’eh;
action language based on fUML is proposed by this group, with a
syntax similar to modern OO languages; here they discuss the GUI
editor more; the editor can take a textual representation of the
functionality of an operation, and convert it to UML activity diagram
with all actions necessary; The </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><SPAN STYLE="background: transparent">activity</SPAN></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">is
added as the </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><SPAN STYLE="background: transparent">behavior</SPAN></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">of
that class </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><SPAN STYLE="background: transparent">operation.</SPAN></U></SPAN></FONT></FONT></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Only
elements from fUML are used; fUML still in beta; action lanugage is
based on </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><SPAN STYLE="background: transparent">Action
Semantics package from UML</SPAN></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
← </SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">find?</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
fUML standard is currently built and promoted by OMG for building
executable UML models. The compatibility of the executable models
with the fUML standard means that only the UML elements allowed by
fUML should be used for the abstract syntax and the extra constraints
imposed by the fUML standard should be considered. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
executable models are models that can be executed and tested without
having to generate</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">code
from them and test them in a specific platform. The Foundational UML
(fUML) [1] is a computationally complete and compact subset of UML
[2], designed to simplify the creation of executable UML models. The
generated code is meant to be complete, with no code placeholders for
the developer to fill out. The fUML standard provides a simplified
subset of UML Action Semantics package (abstract syntax) for creating
executable UML models. However, creating executable fUML models is
difficult, because the UML primitives intended for execution are too
low level, making the process of creating reasonable sized executable
UML models close to impossible. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">To
generate code from MOF compliant models, OMG created MOF Model to
Text Transformation Language [8], which is suitable to generate code
from fUML models.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Model
creation. To create the structure of the model, the usual UML Class
Diagrams should be used. These Class Diagrams, however, must restrict
the elements that can be used to those included in the fUML standard.
To create the part of the model corresponding to the behavior of the
operations, an Action Language based on fUML needs to be used. This
is because it is close to impossible to use UML Activity Diagrams for
this task, as the user will need to create, configure and relate too
many elements. The Class Diagram editor needs to be integrated with
the Action Language textual editor, which is used to create the
behavior for each operation. An action language that follows the
principles of the structured programming is to use by many
programmers familiar with structured programming languages.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">ppt:
The action language will need to create the abstract representation
for the statements and control structures as provided by the
programming languages mentioned above, it must support complex
expressions and easy access to parameters and variables.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">This
can be achieved with a virtual machine that knows how to execute fUML
models. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">ppt:
The UML meta-model is provided by the Eclipse UML2 project [9], which
is part of the larger Model Development Tools (MDT) project. UML2 is
built on top of EMF(Core) [10] (which is part of the bigger Eclipse
Modeling Framework project - EMF) with some adaptations, as UML has a
structure that is not compatible with EMF.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
introduced in a previous paper [3] an action language based on fUML,
with a concrete syntax similar to the concrete syntax of the modern
programming languages like Java or C++. This action language follows
the principles of the structured programming.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
fUML standard specifies how a virtual machine for fUML models should
work, and there is a reference implementation in progress from
ModelDriven.org [13].</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">To
generate code, we used the Acceleo project [14], which is part of the
bigger Model To Text (M2T) project from Eclipse. This project
implements the MOFM2T standard from OMG. It allows the user to create
templates, which can later be used to generate code from the models.
← check this out!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">------------------------------</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">An
attempt to combine UML and formal methods to model airport security</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">B
and Z are used as target languages for formal analysis, since they
are adequate to express </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><SPAN STYLE="background: transparent">invariant</SPAN></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">properties;
apparently there are tools to translate from UML+Z annotations to
full Z specifications. Annotations on several levels: class,
attribute, association, diagram level.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
ppt? : Multiplicities in a class diagram put dynamic constraints on
the execution of the model;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><U><SPAN STYLE="background: transparent">not
so important, only the underlined </SPAN></U></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Strong
link has always existed between graphical and formal models, to make
sure that “What you validate is what you verify”.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Security
is regulated by international standards: These are natural language
documents with their usual problems: risk of ambiguity or
incompleteness, and poor tool support for consistency checking and
validation.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
links between the formal specifications and the UML diagrams should
be automated since the validation of the formal models is only made
indirectly by the certification authority, based on this link. This
paper will focus on this link.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">invariant
properties: properties that should always hold;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
translation was recently adapted to produce a specification that can
be animated by the Jaza tool [8]. Snapshots of the animation are
represented graphically as object diagrams. These animations and
representations help understand and validate the specification. ←
validate the specification via animations/simulations? ppt?</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Difficulties
in translating UML into Z The class diagram of Fig. 2 had to be
adapted in order to translate it with RoZ ← for ppt: do I need to
adapt SDs?</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">------------------------------</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">Formalising
and analysing the control software of the Compact Muon Solenoid
Experiment at the Large Hadron Collider</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Modal
mu-calculus explained in Section 3.3 details! ← </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">need
it!</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">data
language mCRL2 great explanation; </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">great
for mCRL2 ppt!</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">[34]
on mu-calculus; state space explosion - techniques help to a limited
extent, more important is to exploit the structural properties of the
system; lambda operator in mCRL2 explained; </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">VERY
good for ppt</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">livelocks
can be tested:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">overapproximation
-&gt; could end up with false positives</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">underapproximation
-&gt; we miss some reachability</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Under
the SMI++ framework, the real world is viewed as a collection of
objects behaving as finite state machines (FSMs); &nbsp;new language
features are only being added at a slow rate. However, its semantics
is only defined </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">informally</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
average depth of the control tree is approximately 9 nodes, with a
minimal depth of 3 nodes and a maximal depth of 11 nodes. Considering
the scientific importance of these experiments, this justifies the
use of rigorous methods for understanding and analysing the system.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Using
the ASF+SDF meta-environment [5], we have developed a prototype
translation implementing our mapping of SML to mCRL2. This allows us
to quickly assess the adequacy of the translation through simulation
and visualisation of FSMs in isolation, and by means of formal
verification of small subsystems of the control software, using the
mCRL2 toolset. The feedback obtained by the verification and
simulation enables us to further improve the transformation. … </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">As
a result, our translation can easily be converted to another
formalism if needed. &lt;-- for ppt?</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Explicit
state model checking suffers from the infamous state space explosion
problem; in parallel systems, the number of states in the complete
system grows exponentially in the number of parallel components.
Several techniques have been developed to tackle this explosion,
e.g., symbolic model checking [11], symmetry reduction [12,13] and
compositional verification. However, from 1020 states there still is
a long way to go before we can verify the 1027,500 estimated states
in our system. We therefore think it is reasonable to assume that
these techniques will only help to a limited extent, and that to
verify the control software, we need to exploit the structural
properties of the system.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
finite state machines used in the CMS experiment are described in the
State Manager Language (SML) [2,3]. In ibid. only an informal
semantics is given, and a formal semantics of SML is unavailable. We
present the syntax and the suggested meaning of the core of the
language using snapshots of a running example; we revisit this
example in our formalisation in Section 4, where also the
abbreviations that are used in the formalisation are explained in
more detail. Note that SML is larger than presented here, also
offering language constructs for the hardware device drivers, but the
FSMs making up the control system employ these core constructs only.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
mCRL2 language [4] consists of three distinct parts: a data language
for describing the data types and transformations, a process language
for specifying system behaviours and </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">a
modal language for reasoning about the system behaviours. ← for ppt</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">for
ppt: </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">New
data sorts can be defined either by directly specifying the
constructors of a data sort, or using structured sorts, or through
aliasing. Relations and mappings on data sorts, and their rules of
logic are formalised through equational rewrite rules. Defining data
sorts through structured sorts introduces a few built-in mappings and
relations, such as projection functions, equality and inequality.
Expressions in the data language can be built by combining sort
constructors, functions, </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">relations
and data variables. &lt;-- for ppt: if you use structured sorts, you
get some things for free </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Of
particular interest for the formalisation of SML programs is lambda
abstraction, which is well-known from λ-calculus and type theory. In
our specification, we use them, e.g., to model association lists.
Functions, specified through lambda abstraction or otherwise, can be
updated concisely and intuitively, as illustrated by the following
example. f=lambda n:Nat. n+n. Note that this is equivalent to
defining f(n) = n + n, but allows inline definition of this function.
The support for universal and existential quantifiers further
facilitates conventional mathematical reasoning.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
process specification language of mCRL2 consists of only a small
number of basic operators and primitives. We forego a formal
exposition of its semantics, for which we refer to [4,29]; instead,
we restrict ourselves to introducing its syntax, sketch its meaning
informally and illustrate its use through small examples. ← </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">ppt
entire section</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><SPAN STYLE="background: transparent">“<FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">now
when you add data to your process, you probably need to use or test
the value of that data”</SPAN></SPAN></FONT></FONT></SPAN></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Animate
the following:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
parallel composition of processes p and q, which is denoted by
process p||q, behaves as the interleaving of both processes involved:
the first action may come from process p, which after execution of
this action behaves as process p’; the resulting process then is
p’||q. Symmetrically, the first action may come from process q. In
addition, both processes may execute their first actions
simultaneously, producing a multi-action, after which the processes
that remain are again composed in parallel.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Example
5. Consider the process p defined as sum n:Nat. read(n).send(n) and
q, defined as sum m:Nat. send (m).read(m+m). The parallel composition
of p and q, may first execute a read(n) action, after which it will
behave as the parallel composition send(n)||q, it may first execute a
send(m) action, after which it will behave as the parallel
composition p||read(m+m), or both processes may execute their first
actions simultaneously, denoted by the multi-action read(n)|send(m),
after which the remaining process behaves as send(n)||read(m+m)</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Finally,
recursive equations … </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Whereas
the process language is typically used to specify how a system
achieves its behaviour, the modal language is typically used to
reason about high level requirements of such systems. The modal
language of mCRL2 is based on the theory of the modal μ-calculus
[30], extended with facilities to reason about data, see [31,32]. The
resulting language is quite expressive; for instance, it admits a
linear encoding of the temporal logic LTL, see [33]. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Apart
from standard Boolean connectives such as conjunction and
disjunction, the mCRL2 modal language permits the use of existential
and universal quantification over data sorts (specified by the data
language), and the use of Boolean expressions. In addition the
language permits the use of modalities. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
must modality [A]f expresses that any first action a(v) executed by a
process will result in a process that satisfies property f if action
a(v) is among the actions in the set of actions described by A.
Dually, the may modality &lt;A&gt;f asserts that among the set of
first actions that can be executed by the process, there is one
action that is contained in the set of actions described by A, and
which, if executed, will result in a process satisfying property f.
The modal language permits describing infinite sets of actions, which
is needed because of the possibly infinite branching processes that
can be described by the process language. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
set of actions characterised by true is the entire set of actions;
the set of actions characterised by exists n:Nat. read(n) is the set
of read actions with a parameter taken from the set of all natural
numbers. Thus, &lt;true&gt;true asserts that a process can execute an
action, and [!exists n:Nat. read(n+n)]false asserts that a process
can at most execute read actions with even valued natural numbers.
Lastly, forall n:Nat. &lt;read(n)&gt;true asserts that a process can
execute read actions with every natural number parameter. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Finally,
least and greatest fixpoints, denoted by mu X. f(X) and nu X. f(X),
respectively, permit reasoning about finite and infinite runs of a
system. Typically, least fixpoints are used to specify eventualities,
whereas greatest fixpoints are used for invariants. By mixing least
and greatest fixpoints, increasingly complex properties, such as
fairness properties, can be stated. We refer the reader to [34] for
an excellent in-depth discussion of the μ-calculus.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Verification
of the behaviour described by processes is supported by computing
whether a given functional requirement, expressed as a modal
μ-calculus formula holds for the process or not; this is known as
model checking. For specific types of requirements, counterexamples
that are easy to interpret can be reported in the case the
requirement fails on the given process. This facilitates debugging
the cause of the failure.</SPAN></FONT></FONT></FONT></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><SPAN STYLE="background: transparent">“<FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">So
far we have only discussed the translation of individual SDs...How do
we fit this in the big picture, which process starts orchestrating
them..This is done at another level of the specification” &nbsp;&lt;--
for ppt</SPAN></SPAN></FONT></FONT></SPAN></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">For
each FSM, the process describing its class is instantiated with its
id, the id of the parent, the ids, states and types of its children,
and the parameters for the initialisation phase. The processes
obtained in this way, are then put in parallel. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><SPAN STYLE="background: transparent">“<FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">You’ll
probably ask the question “how do you know it’s right, how do we
know it’s correct, this translation of yours?”” : (for ppt)</SPAN></SPAN></FONT></FONT></SPAN></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">he
challenge in formalising SML is in correctly interpreting its
language constructs. We combined two strategies for assessing and
improving the correctness of our semantics: informal discussions with
the development team of the language (well, it helps if you know UML,
and I’ve studied the metamodel because I had to), supported by
simulations run using the PVSS-II environment used for developing
FSMs, and applying formal analysis techniques on sample FSMs taken
from the control software. The discussions with the SML development
team were used to solidify our initial understanding of SML and its
main constructs. Based on these discussions, we manually translated
several FSMs into mCRL2, and validated the resulting processes
manually using the available simulation and visualisation tools of
mCRL2. This revealed a few minor issues with our understanding of the
semantics of SML, alongside many issues that could be traced back to
sloppiness in applying the translation from SML to mCRL2 manually. In
response to the latter problem, we eliminated the need for manually
translating FSMs to mCRL2. To this end, we utilised the ASF+SDF
meta-environment (see [5,36]) to rapidly prototype an automatic
translator that, ultimately, came to implement the translation scheme
we described in the previous subsection. The Syntax Definition
Formalism (SDF) was used to describe the syntax of both SML and
mCRL2, whereas the Algebraic Specification Formalism (ASF) was used
to express the term rewrite rules that are needed to do the actual
translation. Apart from the gains in speed and the consistency in
applying the transformations that were brought about by the
automation, the automation also served the purpose of formalising the
informal semantics of SML, since the language is mapped to a language
that does have a formal semantics. The final details of our semantics
were tested by analysing relatively well-understood subsystems of the
control software in mCRL2. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">However,
the verification using the modal μ-calculus currently requires too
much overhead to serve as a basis for lightweight tooling that can be
integrated in the SML development environment, since their
verification in mCRL2 requires their complete state space. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
first problem we consider is detecting livelocks that manifest
themselves through loops in the when phase (i.e., generalising the
stability property expressed by requirement 2 in the previous
section). We use an overapproximation for detecting such loops. This
means that we are guaranteed to find all loops a system may exhibit,
and the absence of loops proves the absence of a particular type of
livelock in the system. However, we may detect loops that cannot
occur in practice because the circumstances under which these happen
may not be feasible. The second problem we consider is the mutual
reachability problem (i.e., generalising requirement 3 of the
preceding section). Basically, we use an underapproximation to detect
whether there are states in an FSM that can never reach all other
states in the FSM. If our analysis reveals there are indeed such
states, it indicates that the FSM may become stuck in such states.
While this may constitute desired behaviour, it can also indicate a
design flaw. Note that, since we use an underapproximation, we may
miss reachability issues that occur in practice.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">A
second desirable behavioural property of an FSM is that all states
should remain potentially reachable during the execution of an FSM.
That is, the FSM should not become trapped in a subset of its states</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">.
While we can again easily encode this property into the modal
μ-calculus, we use a more direct approach to detect violations of
this property by constructing a graph that captures all potential
state changes. Computing the strongly connected components (SCCs) of
the thus obtained graph gives sufficient information to pinpoint
violations to the reachability property: the presence of more than a
single SCC means that one cannot move back and forth these SCCs (by
definition of an SCC), and, therefore, their states.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">------------------------------</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">A
Graphical Property Specification Language</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
real-time systems</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">LTL=&gt;state-based;they
consider a formula as an acyclic graph; but their notation is still
very close to formula and not a real scenario; okayish just the
underlined</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">works
on two levels: first “experts” specify the patterns or constructs
that the users can combine later; users just use existing templates</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">formulas
representing properties of even moderate complexity tend to be hard
to understand. Usually, an expert in formal methods is required to
create such formulas. The patterns can be organized into libraries
and reused in later projects. This two-level approach provides for a
natural division of responsibilities, when the users, who are not
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">necessarily
well versed in formal methods</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">,
are able to express properties in terms, familiar to them. We use LR
to express properties of speci cations expressed in the real-time
process algebra ACSR. ACSR employs the notion of discrete time.
Operational semantics for ACSR gives rise to a labeled transition
system LTS with two types of transitions. Transitions of the rst kind
are labeled with communication events and represent instantaneous
interaction between processes in the speci cation. Transitions of the
second kind represent passage of time and are labeled with sets of
resources that are used by the system during the time interval. When
choosing a logic for expressing behavioral properties, one has to
balance expressive power of the logic with efficiency of verification
algorithms. In general, a formula is an acyclic graph. Nodes of the
graph are operators of the logic - state predicates, propositional
connectives, modal and temporal operators. The novel part is in the
representation of temporal operators. Each temporal operator
illustrated by operator eventually in the example above is
represented as a node with an arbitrary number of outgoing edges,
each of which may be labeled with a set of conditions, to which we
refer as modifiers, to be applied to the corresponding subformulas.
Nodes of the graph represent predicates, logical connectives, modal
operators and quanti ed temporal operators. Predicates are
non-recursive properties that can be decided locally for each state.
← still not very intuitive</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Modal
operators are &quot;next state&quot; properties and represent single
occurrences of a communication event from a speci ed set. Temporal
operators express properties of a path. The two path quantifiers are
along some path&quot; and along every path&quot;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Modifiers
place restrictions on traces to which the temporal operator is
applied. &nbsp;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">To
provide semantics to LR expressions, we had to place severe
restrictions on the structure of the expression graphs. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">------------------------------</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">Scenario-Based
Techniques for Supporting the Elaboration and the Validation of
Formal Requirements</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">m’eh,
old paper (1998), only underlined</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
ppt: ← “animator” is important to understand interaction at the
level similar to controlled code execution ← lpsxsim of mCRL2</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">This
paper focuses on the language Albert II, a formal language designed
for the purpose of expressing requirements for distributed </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">real-time
systems. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
first contribution aims at improving the elaboration process by
providing a method for constructing an Albert II description from
scenarios expressing the stakeholders’ requirements. These are
represented through message sequence charts extended to deal with
composite systems. &nbsp;In particular, at the RE level, it is clear
that we cannot expect our various stakeholders to read mathematical
formulae. This is why we are developing a so-called animator tool
which allows stakeholders to cooperatively explore different possible
behaviours of the future system (as allowed by the formal Albert II
description). The purpose of the tool comes down to testing if a
given scenario proposed by one or several stakeholders is compatible
with the requirements specification. Albert II [13,14] is a formal
requirements specification language based on a real-time temporal
logic.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
life of an agent instance is an infinite alternate sequence of states
and state transitions. A state of an agent instance represents the
value of all its state components in a time interval during which
they remain unchanged.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">.
MSC-like notations are intuitive and therefore facilitate
communication and understanding between the analysts and the
stakeholders;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">.
MSC-like notations are particularly well suited for expressing
interactions (as opposed to internal actions) which is precisely what
one should focus on at the RE activity level (adopting a black-box
view of the system).</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">------------------------------</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">The
many meanings of UML 2 sequence diagrams: a survey (2011)</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Awesome!
Survey of the proposed formal semantics; categorizes the semantic
choices ← just what I need; most extensive survey</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">complexity
of the language yields several possible choices in its semantics ←
ppt</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">how
many of the proposed semantics are actually formalised? &nbsp;</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Very
relevant, but long :( </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">13
proposed formal semantics for UML2 SDs. Underlined for presentation;
&lt;-- for ppt, make it dramatic! :)</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">two
main challenges when dealing with semantics: </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">1.
scattered through the text of the superstructure</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">2.
specification uses semantic variation points -&gt; part of the
semantics is left underspecified, to allow UML to be used in many
domains; </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">even
these variation points are not always marked clearly</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">check
[3] -&gt; liveness properties expressed with OCL</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">There
is one “true concurrency semantics” in 3.5 Considers a limited
set of operators and constructs, but gives them well-defined
semantics.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Weak
sequencing: events that don’t belong to the same lifeline can occur
independently + ...they are not related by a path of messages. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Most
surveyed approaches formulate the semantics by mapping it to known
formalisms (FSM, LQN, Petri-Nets, process algebras etc)</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">they
differ quite heavily in the symbols and definitions they use</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">for
ppt? → problem: the UML spec gives the semantics of UML as a set of
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><SPAN STYLE="background: transparent">valid</SPAN></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">and
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><SPAN STYLE="background: transparent">invalid</SPAN></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">traces,
but also states that there can be other traces for which we don’t
know whether they are valid/invalid.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
2.0 version of UML changed Sequence Diagrams significantly and the
expressiveness of</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">the
language was highly increased. However, the complexity of the
language (and the diversity of the goals Sequence Diagrams are used
for) yields several possible choices in its semantics. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">This
paper collects and categorizes the semantic choices in the language</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">,
surveys the formal semantics proposed for Sequence Diagrams, and
presents how these approaches handle the various semantic choices.
Message Sequence Chart (MSC) [23] was one of the first of such
scenario languages. The 2.0 version of UML changed Sequence Diagrams
significantly. Several elements were borrowed from MSC, many new
complex elements were added to the language, and the semantics and
the underlying metamodel were rewritten. Due to the increased
expressiveness of the language, interpreting a complex diagram that
uses the new constructs is a difficult task; thus, having a precise
formal semantics becomes even more critical. But the many different
purposes Sequence Diagrams are used for, e.g., showing the</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">flows
of method calls inside a program, or giving a partial specification
of interactions in a distributed system, require quite different
interpretations of the language. Indeed, many different semantics
have been proposed for Sequence Diagrams. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">When
we tried to define the semantics of TERMOS, we encountered the
problem that the various formal semantics for Sequence Diagrams
handle even the most basic diagrams quite differently. It turned out
that there are several subtle choices in the interpretation of
language constructs. Moreover, these choices and all their
consequences are often not obvious. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">We
thus felt the need for a thorough review of the existing approaches.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
ppt: The syntax defined in the specification consists of (i) a
concrete syntax defining the graphical notation and (ii) an abstract
syntax given with a metamodel defining the relationships between the
elements. GeneralOrdering can constrain the ordering of otherwise
unrelated occurrences. Messages on their own cannot cross the
boundaries of CombinedFragments: they need a Gate which links the two
parts of the message. An InteractionUse refers to another
Interaction. It can be passed parameters and can have a return value.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
abstract syntax of Interactions is defined with metamodeling; the
model is presented in Section 14.2 Abstract Syntax of [33]. The
abstract syntax is depicted in several separate diagrams From the
abstract syntax we can see, for example, that a StateInvariant
belongs to one Lifeline; thus it is a local constraint, or that there
are three kinds of Gates, each for different purposes.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
right side of Fig. 5 contains the metamodel elements of sd1. The
Interaction is a container for all other elements. The
OccurrenceSpecifications are linked to the appropriate Lifelines and
Messages. The Lifelines are connected to the CombinedFragments that
cover them. The InteractionOperand contains the InteractionFragments
(OccurrenceSpecifications, StateInvariants, other CombinedFragments,
etc.) which are enclosed by this operand. An InteractionFragment</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">can
be enclosed only by one operand; thus when an InteractionFragment is
nested in several operands, only the bottommost containment is
illustrated in the model explicitly.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">for
ppt: The central concept of the semantics is a trace.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
“</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">A
trace is a sequence of event occurrences, each of which is described
by an OccurrenceSpecification in a model.” (p. 484). A central
question is what part of the behavior is modeled by the Interactions.
“There are normally other legal and possible traces that are not
contained within the described interactions” (p. 459). &lt;-- for
ppt: well, I say, no. My claim is, ifthe code can represent all legal
and possible traces, so can the model, the model can be closed. This
is where we deviate a bit from the standard UML proposed semantics.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
Interactions can model also invalid traces, and there could be traces
that are not described by the Interaction: “The semantics of an
Interaction is given as a pair of sets of traces. The two trace sets
represent valid traces and invalid traces. The union of these two
sets need not necessarily cover the whole universe of traces. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">&nbsp;←
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">we
go with the assumption that the total behavior is described</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">for
ppt all: “The semantics of </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Interactions
is explained with an interleaving semantics, i.e., two events may not
occur at exactly the same time.” </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">←
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">is
this official?</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
rules for </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">weak
sequencing </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">are
the following:</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><SPAN STYLE="background: transparent">“<FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">The
ordering of OccurrenceSpecifications within each of the operands is
maintained.</SPAN></SPAN></FONT></FONT></SPAN></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><SPAN STYLE="background: transparent">“<FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">OccurrenceSpecifications
on different lifelines from different operands may come in any
order.”</SPAN></SPAN></FONT></FONT></SPAN></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">OccurrenceSpecifications
on the same lifeline from different operands are ordered such that an
OccurrenceSpecification of the first operand comes before that of the
second operand.”</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
first category contains operators that introduce choice and
iteration. The operators in the second category are for
parallelization and sequencing. Operators in the last category are
related to the conformance relation, i.e., the way a trace is
categorized as valid, invalid, or inconclusive according to a
diagram. For example, an assert describes a mandatory behavior, while
a negate one that should not happen. Consider and ignore change the
set of message names from which valid and invalid traces can be
built. ← for property specification</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
selected 13 approaches, listed in Table 2. As the UML 2.0
specification completely changed</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">how
Interactions are defined (different semantics, introduction of
invalid traces and CombinedFragments, etc.), the table does not
contain approaches for UML 1.x Sequence Diagrams</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Conformance-related
operators (consider/ignore/neg/assert) &nbsp;were not considered in
one-third of the approaches. Even if it is one of the most important
aspects of the language, it is hard to formalize it and solve its
issues. Moreover, consider and ignore were not mentioned in four of
the eight, that dealt with conformance.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Gates
were handled explicitly in only a small number of papers. ← on the
other hand, we handle gates (not detailed in the paper) </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">STAIRS
approach is trace-based semantics for SDs. In [3] the authors
proposed a technique using Object Constraint Language (OCL) templates
to express liveness properties in UML Sequence Diagrams, based on
results of LSC [10]. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Using
concepts from LSC, several problematic parts of the OMG specification
were addressed. May and must behavior, universal, and existential
diagrams can be differentiated. In Fig. 2 in [3] the authors give a
nice example that certain liveness properties cannot be expressed
with assert or negate. Therefore, they propose an after/eventually
OCL template, which says that after a condition becomes true there is
a guarantee that eventually another condition will become true.
Moreover, they introduce </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">global
constraints and methods for synchronization at the beginning or end
of </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">CombinedFragments.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
authors point out that with the basic interpretation of negative
fragments it is easy to construct overspecified Interactions, i.e.,
an Interaction that can be positively and negatively satisfied from
the same trace. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Küster-Filipe
defined a true-concurrent semantics based on event structures in
[14]. In [1] the semantics is extended to handle the InteractionUse
construct. It considers only a smaller number of operators and
constructs (alt, par, seq, and StateInvariant), but gives them a
well-defined semantics. The approach constructs for every Lifeline a
labeled prime event structure. The model takes into account the
possible nesting of CombinedFragments and gives a very clear
definition for the predecessors of every event. ← for ppt: I also
take into account nested fragments</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
[12] a semantics is given for Sequence Diagrams based on M-nets
(multivalued nets), which is an algebra based on high-level Petri
nets. The method handles basic data types (Boolean and integers);
thus, it can include the local attributes of Interactions, the
arguments of Messages, and the evaluation of conditions in the
semantics </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
semantics defined in the paper assumes that all behavior is
explicitly specified in the diagrams and no conformance-related
operator is used ← ppt: same here!</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
[15] the authors propose to interpret valid and invalid &nbsp;parts
of an Interaction as liveness and safety properties, respectively.
The Sequence Diagrams are first transformed to hierarchic,
non-deterministic automata, then the high-level automata are
flattened, and finally liveness Büchi automata are constructed from
the positive automata, and safety Büchi automata from the negative
ones. &nbsp;← see how Buchi automata are constructed</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Modal
Sequence Diagrams (MSD) [19] are an extension to UML Sequence
Diagrams by Harel and Maoz, which adapts LSCs to the notation of UML.
LSC is a language inspired from MSC that allows the specification of
possible and mandatory scenarios. The authors point out that the root
of all the challenges regarding negate and assert are that these were
introduced as simple operators, while they are rather modalities. (
have read it: assert and negate revisited)</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">ppt:
The authors also treat the question how multiple diagrams should be
handled, one point that is often missing from others. In the
Appendix, a formal semantics based on weak alternating automata is
sketched. First, the diagram is transformed into an intermediate
format, an unwinding structure, from which the states (the cuts of
the diagrams) and the transitions (message sending) of the automaton
are derived. The current semantics considers only synchronous
messages; the sending and receiving is treated as one event. ← only
synchronous messages</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
paper [26] proposes an operational semantics, where an interaction
automaton is produced by unwinding the Interaction. One single
interaction automaton is created for the entire Interaction. &nbsp;(have
read it “Model checking UML 2.0 interactions”)</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Later,
this interaction automaton is used as an observer process in the SPIN
model checker to check the communication produced by UML State
Machines. &lt;-- for future work: can I use this automaton created
from SDs for properties specification? See what kind of SPIN observer
process comes out of it and if you can create an mCRL2 one!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
[13], the authors propose a translation that produces a Colored Petri
Net from UML use cases and Sequence Diagrams. For the basic operators
(opt, alt, par, loop, and ref &lt;-- for ppt, I handle those, plus
break), templates are assigned to show what kind of CPN fragment
should be created. The translation does not consider
conformance-related operators. It seems, although it is not stated
explicitly in the paper, that each diagram contains initially only
one active instance (it can later fork into several executions with a
par). Only synchronous messages are handled, because the sending and
receiving are represented by the same transition. In [41] a
formalization using template semantics is proposed for UML 2 Sequence
Diagrams. The formalization is described in more detail in the
technical report [42]. The approach gives an operational semantics
for which the basic computation model is hierarchical transition
systems (HTS). First, the maximal sequence fragments of the diagram
are computed, i.e., the maximal sequences of consecutive Messages
that do not contain CombinedFragments. </SPAN></FONT></FONT></FONT>
</P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Categorizing
semantic choices:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">1.
Interpretation of a basic &nbsp;Interaction: What is a trace?
Categorizing traces; Complete or partial traces;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">2.
Introducing Combined-Fragments: combining fragments</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">3.
Computing partial orders: Processing the diagram; Underlying
formalisms; Choices and predicates</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">4.
Introducing Gates: formal and actual gates</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">5.
Interpretation of conformance-related operators:
assert/negate/ignore/consider; traces being both valid and invalid</SPAN></FONT></FONT></FONT></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Because
the semantics of an Interaction is defined as the valid and invalid
traces produced by the diagram, first the content of a trace has to
be specified. However, in a formal semantics, one has to be more
explicit, e.g., because there can be several Lifelines in the
Interaction sending messages with the same name, it should be
specified who sent or received the message. Thus some of the
semantics (STAIRS, Cengarle &amp; Knapp, Grosu &amp; Smolka, Template
semantics) represents elements of the trace with tuples, e.g.,
(action, sender, receiver, message name).</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">each
OccurrenceSpecification is assigned a unique location name; thus the
two receptions of Signal m can be differentiated. The location names
are symbolic labels that usually conform to the visual position of
the location.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Traces,
the receiving events should be matched with the sending event that
caused it, which is only possible if each message in the trace can be
uniquely identified.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt: The UML specification gives the semantics of an Interaction as a
set of valid and a set of invalid traces. However, it states that
there can be other traces, for which we cannot know whether they are
valid or invalid. According to the OMG specification, basic Sequence
Diagrams specify complete, potential behaviors, meaning that the
traces represented by the Interaction are examples for valid traces,
and all the other traces are inconclusive with respect to the given
diagram. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Sometimes
this interpretation is not convenient, e.g., when one would like to
specify requirements [19], safety properties [15] or test purposes
[36]. For this reason, two of the semantics use an interpretation
with partial traces, i.e., the diagram depicts only parts of the
valid traces; other messages can interleave with them to form the
complete, valid traces.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Intuitively,
interpretations with partial traces amount to filter out the behavior
that is irrelevant to the categorization of traces: trace prefix,
suffix, or extra interleaving events are ignored and categorization
is based on the remaining part of the trace. It turns out that two
operators of the UML 2.0 Sequence Diagrams, ignore and its dual
operator consider, allow us to further manipulate the set of events
appearing in the traces. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
OMG specification defines weak sequencing as the default composition
operator for fragments. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Accordingly,
most semantics retain this operator to compose a CombinedFragment
with the rest of the diagram. Due to the weak sequencing, events that
do not belong to the same lifeline can occur independently if they
are not related by a path of messages. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Figure
9 important for ppt! </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Figure
9 exemplifies this. Message m1 is located above the opt fragment, but
there is actually no precedence relation: m1 can occur independently
of messages m2 and m3. Similarly, placing something below a
CombinedFragment does not necessarily mean that it comes after the
messages inside the CombinedFragment. In Fig. 9, there is an ordering
constraint between m2 and m3 only because they share lifeline c. If
the optional message m2 does not occur, then there is no constraint
on m3. For example, trace !m3.!m1.?m1.?m3 is valid. Technically,
entering or exiting an operator is not an OccurrenceSpecification.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">As
far as we understand the OMG specification, the only
OccurrenceSpecifications are (1) sending and receiving of Messages
and (2) start and end of an ExecutionSpecification.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">While
weak sequencing is the default according to the OMG specification,
five semantics we reviewed introduce synchronization on entering and
exiting fragments (Cavarra &amp; Filipe, P-UMLaut, Hammal, MSD, CPN).
This nonstandard interpretation is usually adopted for work using
Sequence Diagrams for verification purposes.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
loop construct has an interpretation that is similar to the one of
loops in programming languages.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
UML 2 specification defines the rules for computing the orderings
between the OccurrenceSpecification on a simple diagram (see Sect.
2.2.1). This is usually a partial order because there can be
independents events in the Interaction. When a diagram contains
several CombinedFragments their effects combine. It may result in
complex orderings, which are not trivial to calculate. Thus, a
significant question about a semantics is how it computes the
orderings for an Interaction.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
semantics in the first category parse the diagram and decompose it.
The CombinedFragments and the basic fragments in the diagram are
identified (Störrle, P-UMLaut, Hammal, Thread-tag, CPN, Template
semantics); some approaches even build a syntax tree from the
elements of the diagram based on an abstract syntax (STAIRS, Cengarle
&amp; Knapp, Knapp &amp; Wuttke). Usually, the parsing from a
diagram’s concrete syntax to this intermediate representation is
not given in detail (some rules can be found in [12] or in [41] based
on maximal independent sets). After the parsing, the semantics is
computed by recursively unfolding the fragments and gluing them
together based on rules defined for each of the operators. ← for
ppt: how I do it</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt maybe also: </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
diversity of formalisms in the approaches is the consequence of the
diversity of interests for using Sequence Diagrams. Some authors
define the semantics to check traces (e.g., Knapp &amp; Wuttke), some
to compute all possible traces of a diagram (e.g., Störrle), some
use the semantics to support refinement-based development (e.g.,
STAIRS), or translate the diagrams into behavior models in order to
connect to existing simulation or verification tools (e.g.,
P-UMLaut). The different purposes can be supported in either one or
the other formalism more easily. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
definition of choices and predicates in the OMG specification is very
permissive. As will be seen in this section, there are numerous
options what and when to choose and who chooses.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">What:
An alt offers much more flexibility than an if construct in
traditional programming languages would: several of its operands can
have implicit true guards, from which one is non-deterministically
chosen. Some approaches try to reduce this non-determinism. Cavarra &amp;
Filipe prescribe that the operands of the alt are evaluated from top
to bottom, and the first one evaluated as true be chosen.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Who:
The UML 2 specification does not define who should make the choice
between the operands of an alt. This can lead to non-local choices, a
problem well studied in MSC [30]. An example for non-local choice can
be seen on Fig. 12, where either instance a sends m1 or instance b
sends m2, but not both. For semantics working with complete traces,
non-local choices raise implementation problems: it may be impossible
to implement a system, which shows the valid traces of the diagram.
Most of the semantics accept non-local choice as a consequence of
having a high-level, powerful specification language. ← LE CRUCIAL
THING! ppt: We do not support non-local choices, we think this
restriction is reasonable for OO implementation languages! </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">When:
With the introduction of synchronization at the beginning and end of
CombinedFragments (Sect. 4.2) some approaches specify a common point
in time when all Lifelines have to make the choice Thus handling
choices is a complex issue. The main approaches used in the different
semantics are:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><SPAN STYLE="background: transparent">• <FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">No
explicit time point for the choice: The sets of traces from each
operand are computed independently and are combined with the rest of
the diagram using the default weak sequencing to obtain all the
possible traces of a diagram (Störrle, STAIRS, Cengarle &amp; Knapp,
Thread-tag).</SPAN></SPAN></FONT></FONT></SPAN></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 114%"><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">•
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: transparent">Explicit
time points for the choice on each Lifeline: Lifelines process the
diagram separately and choose between operands independently (Cavarra
&amp; Filipe, Küster-Filipe, Template semantics). Therefore, each
Lifeline could make its choice at different times, but the semantics
guarantees that all Lifelines choose the same operand (e.g., by
fixing the evaluation order of operands). ← </SPAN></SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">we
are here ! for ppt</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><SPAN STYLE="background: transparent">•
<FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">Explicit
global time point for the choice: All involved lifelines synchronize
before entering a choice, and only one global choice is made
(P-UMLaut, Hammal, Grosu &amp; Smolka, MSD, Knapp &amp; Wuttke, CPN).
These approaches typically use an automaton-based formalism, where
one transition represents the taken choice for all Lifelines.</SPAN></SPAN></FONT></FONT></SPAN></FONT></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
ppt: There are several options regarding who should evaluate the
guard. The evaluation could be local to one Lifeline (STAIRS,
Küster-Filipe), all Lifelines could interpret the guard separately
(Cavarra &amp; Filipe), or the guard could be evaluated globally
(P-UMLaut, Hammal, MSD, Knapp</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">&amp;
Wuttke). The latter option is consistent with an explicit global time
point for the choice. Lifelines can evaluate the guards at different
times, the value of the guard can change in the meantime. The UML 2
specification prescribes that </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">the
guard should be placed on the lifeline where the first</SPAN></I></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">event
occurrence will occur, positioned above that event, in the containing
Interaction or InteractionOperand.</SPAN></I></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">However,
as we mentioned before, “the” first event in an operand is not
well defined With the cfragmentGate type of Gate, messages can cross
the boundaries of CombinedFragments (see Figure 14.10 of [33]). Since
cfragmentGate is allowed for any operator, it can yield problems.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">As
reported by Pickin in [36], this will cause issues with loops.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">ppt:
Most of the semantics do not consider cfragmentGates, or disallow it
by their redefined abstract syntax (STAIRS, Cengarle &amp; Knapp,
Knapp &amp; Wuttke). Our recommendation is also to remove it from the
specification or heavily restrict its use, e.g., only to critical
regions and co-regions. The other two types of Gates (formal and
actual) introduce a convenient facility for expressing complex
scenarios: when a diagram includes a reference to another diagram
(see Fig. 16), Gates make it possible to model the passing of
messages. The referenced diagram has formalGates placed on its
boundaries, allowing the representation of messages that come from,
or go to, its environment. The environment is determined by the
including diagram, where actualGates are placed at the borders of the
ref box. Gates are MessageEnds that connect the Messages inside and
outside the referenced diagram. ← just highlight those boxes in the
metamodel. for ppt</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">In
P-UMLaut the referenced fragments are inlined before processing the
Interaction. ← for ppt we do the same</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt also: The interpretation of conformance-related operators (see
our classification in Table 1) is a central issue in the definition
of the semantics. Many papers about UML 2 Sequence Diagrams deal with
this issue (or at least mention it). Indeed, quoting from [35],
“[assert/negate/ignore/consider] constructs open up a veritable
pandora’s box of expressions whose meaning is obscure.” We
provide here an overview of how the various semantics handle these
constructs. Assert and negate allow the specification of mandatory
and forbidden behavior. Ignore and consider affect the notion of
conformance to a diagram, by changing the alphabet from which the
valid and invalid traces are built. They make it possible to account
for the sending and receiving of messages not explicitly represented
in the diagram. The description of these operators is unclear in the
OMG specification, and few semantics address them. For the ones that
do, the proposed interpretation depends on whether the semantics
works with complete or partial traces.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Up
to now, we discussed the interpretation of each conformance-related
operator taken in isolation. But in complex diagrams,
conformance-related operators can include, or be nested into, other
constructs. Let us consider the nesting of conformance-related
operators into each other. This raises issues such as the
interpretation of multiple assertions, multiple negations, assertions
of negations, negation of fragments with considered and ignored
messages, and messages that are both ignored and considered. Of
course, the semantics dealing with these constructs will assign a
precise meaning to such cases. However, the assigned meaning may
defeat intuition, with the risk of producing diagrams that users do
not properly understand. ← sometimes adding syntactic restrictions
helps. Example: NEG should not be used as an ordinary operator, only
on complete scenarios to depict a forbidden scenario -&gt; for
model-checking!</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Ambiguous
diagram can be constructed, where a given trace is both valid and
invalid. In the example of Fig. 22, this is due to non-determinism. A
given event in the trace can be</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">considered
as occurring either inside or outside the scope of the
conformance-related operator, depending on some nondeterministic
choice. Parallel constructs come with similar ambiguities. ← ppt</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
ppt: </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">These
various examples show that it is extremely difficult to get rid of
ambiguous cases. We may put syntactic restrictions to avoid some of
the cases (e.g., use only a deterministic if-then-else form of alt
constructs, or use neg only at the top level of the diagram), but
avoiding all of them by construction would probably require us to
sacrifice too much in terms of language expressiveness. Indeed, from
our analysis of work dealing with conformance-related operators, all
surveyed approaches face cases where a trace can be both valid and
invalid. In general, checking whether a diagram is ambiguous is an
undecidable problem.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">ppt:
Existing scenario languages do not offer concepts to account for the
dynamically changing structure and context, nor do they offer
constructs to represent broadcast communication in local vicinity. ←
SDs are not suitable for, say, mobile networks domain: There are no
constructs for broadcast, or dynamically changing context and
structure</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">&gt;&gt;
checking whether a diagram is ambiguous is an </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">undecidable</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">problem.
</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
main goal of the language is to check whether an execution trace
satisfies a given scenario. In order to fulfil this purpose, the
choices were handled according to the following design decisions
(Table 8 summarizes them). ← !!!!!!!! I NEED STUFF LIKE THIS IN MY
PAPER; Also for PPT: These choices, make them explicit!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">ppt:
Due to the variety of usage for scenarios, there is nothing such as
“the” semantics of UML Sequence Diagrams. The OMG group has
always insisted on the fact that the standard enables specialization
of parts of UML for a particular situation or domain. As regards
Sequence Diagrams, it would probably be an impossible task to exhibit
an “all-in-one” semantics fitting purposes as diverse as the
description of example interactions, of test cases, or of checkable
properties. Flexibility to assign different interpretations to
diagrams leaves UML practitioners with a difficult problem: the one
of</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">selecting
a semantics well suited for their purpose. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">There
is a lack of a clear picture of available options.</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
&nbsp;</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">&lt;--
&nbsp;for ppt: ...but if we try to fit our semantic choices, it would
probably be a bit of this and a bit of that</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">------------------------------</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-left: 0.03in; margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">Property
specification patterns for finite-state verification</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-left: 0.03in; margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Awesome!
Taxonomy of property specification patterns;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-left: 0.03in; margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">obstacle:
accurately express requirements that you wish to verify using the
specification formalism of the tool</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-left: 0.03in; margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">patterns
tend to generalize experience across multiple specific problem
domains; they express “best practises” in the sw domain</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-left: 0.03in; margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
propose a pattern-based approach to the presentation, codification
and reuse of property specifications for finite-state verification.
Finite-state verification refers to a set of techniques for proving
properties of finite-state models of computer systems. Properties are
typically specified with temporal logics or regular expressions,
while systems are specified as finite-state transition systems of
some kind. Despite the automation, users of finite-state verification
tools still must be able to specify the system requirements in the
specification language of the tool. For example...Although the
property and the formula are relatively simple, writing the LTL
formula requires knowledge of several standard LTL idioms. For
example, the property is (implicitly) a safety property, thus the
formula begins with the [] operator. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><SPAN STYLE="background: transparent">A
property specification pattern</SPAN></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">is
a generalized description of a commonly-occurring requirement on the
permissible state/event sequences in a finite-state model of the
system. Describes the essential structure of some aspect of behavior.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">users
of those techniques do need to be expert enough to accurately express
the requirements they wish to verify in the appropriate specification
formalisms. We contend that acquiring this level of expertise
represents a substantial obstacle to the adoption of automated
finite-state verification techniques and that providing an effective
way for practitioners to draw on a large experience base can greatly
reduce this obstacle.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Patterns
were originally developed to capture recurring solutions to design
and coding problems. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Patterns
are successful because practitioners want to solve naturally
occurring domain problems. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">While
there are a number of very expressive formalisms, such as CTL* and
the modal mu-calculus, the specifications that are documented in the
literature, for example in [l, 6,12,14,24,27], appear relatively
simple.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Thus,
we believe a collection of simple patterns can be defined to assist
practitioners in mapping descriptions of system behavior into their
formalism of choice, and that this may improve the</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">transition
of these formal methods to practice. A well-defined design pattern
has the following characteristics </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">It
Solves a Specific Problem, or class of problems, rather than being an
abstract principle or strategy.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">It
is a Proven Concept that has been demonstrated to be effective in
practice.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
Solution isn’t Obvious application of basic principles. and is not
a direct application of basic principles</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">It
Describes Relationships between solution components rather than
isolated components of a solution.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">It
is Generative in that it demonstrates how to construct a solution. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Some
specification formalisms (e.g., quantified regular expressions (QRE)
[25]) are event-based, while others (e.g., various temporal logics,
such as LTL and computation tree logic (CTL) [7]) are state-based.</SPAN></FONT></FONT></FONT></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Each
pattern has a scope, which is the extent of the program execution
over which the pattern must hold. There are five basic kinds of
scopes: global (the entire program execution), before (the execution
up to a given state/event), after (the execution after a given
state/event), between (any part of the execution from one given
state/event to another given state/event) and after-until (like
between but the designated part of the execution continues even if
the second state/event does not occur). The scope is determined by
specifying a starting and an ending state/event for the pattern. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">For
state-delimited scopes, the interval in which the property is
evaluated is closed at the left and open at the right end. Thus, the
scope consists of all states beginning with the starting state and up
to but not including the ending state. We chose closed-left
open-right scopes because they are relatively easy to encode in
specifications and they work for the real property specifications we
studied. It is possible, however, to define scopes that are open-left
and closed-right as well; we discuss this in Section 7. In
event-based formalisms the underlying model does not allow two events
to coincide, thus event-delimited scopes are open at both </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">ends.
Nevertheless, our experience strongly indicates that most informal
requirements are specified as properties of program executions or
segments of program executions. Thus a pattern system for properties
should mirror this view to enhance usability. In event-based
formalisms, although it is easy to require that only certain events
occur within a scope, the property that a proposition holds
throughout the scope would probably be expressed in terms of the
appropriate occurrence of an event indicating that the proposition
has become true and the absence of an event indicating that it has
become false, which does not bear a simple relation to the Absence
pattern. Similarly, we note that some formalisms can express
conditions involving infinite executions, while others are limited to
finite sequences of states or events.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">This
hierarchy distinguishes properties that deal with the </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">occurrence
and ordering</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">of
states/events during system execution. It also provides separate
patterns for compound properties that are built up from combinations
of more basic patterns. While the systems he studies and the meanings
of the properties are very different there is significant structural
similarity among the specifications in terms of patterns of temporal
and logical operators, for example.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Occurrence
Patterns include:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Absence:
</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">A
given state/event does not occur within a scope. This pattern is also
known as </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Never.
</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Existence:
</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">A
given state/event must occur within a scope. Known also as
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Future/Eventuality</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Bounded
Existence: </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">A
given state/event must occur k time within a scope. Variants specify
at least </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">k
occurrences and at most k occurrences of a state/event.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Universality:
</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">A
given state/event occurs throughout a scope. This pattern is also
known as </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Globally,
Always.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Ordering
Patterns include:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Precedence:
</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">A
state/event P must always be preceded by a state/event Q within a
scope.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Response:
</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">A
state/event P must always be followed by a state/event Q within a
scope. This pattern is also known as </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Follows
</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">or
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Leads-to.
</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">It’s
a mixture of </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Existence
and Precedence</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">,
and expresses a causal relationship between two subject patterns.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Compound
Patterns include:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Chain
Precedence: </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">A
sequence of states/events P1,...,Pn must always be preceded bya
sequence of states/events Q1,...,Qm. Generalization of the
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Precendence</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">pattern.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Chain
Response: </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">A
sequence of states/events P1,...,Pn must always be followed by a
sequence of states/events Q1,...,Qm. -||-</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Boolean
Combinations:</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">most
patterns delimit scopes and describe inter-scope properties in terms
of individual events/states. There are cases where we want to
generalize the patterns to allow for sets of states/events to
describe scopes and properties. In some cases it’s straightforward
and disjunctions or conjunctions of state/event descriptions can be
substituted into patterns; These patterns outline how boolean
combinations can be applied in different cases.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Related
work: </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">There
have been some attempts at describing taxonomies for property
specifications. The most popular and long-lived of these
distinguishes safety and liveness properties [20]. While this
provides a very high-level intuitive understanding of classes of
specifications, i.e., “nothing bad will ever happen” vs.
“something good will eventually happen” it is much too coarse to
be of practical use in constructing particular specifications. These
specifications were derived from informal English language statements
of system requirements, which had been refined into a stylized
structured English. The specifications were subsequently verified
using model-checking. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Validation
is also an important issue. How can the analyst be sure that the
specification correctly captures the intended property? </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">There
are two aspects to this problem. One is ensuring that the analyst has
identified the correct specification pattern. Although we hope that
providing very precise prose descriptions and examples of the
patterns will minimize the risk of error, this is a difficult problem
and one that is really outside the scope of the pattern system per
se. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">------------------------------</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">An
Overview of the mCRL2 Toolset and its Recent Advances</SPAN></I></FONT></FONT></FONT></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">for
ppt:</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">The
mCRL2 language consists of three different sublanguages: a data
language, &nbsp;a process language, and a property language. &nbsp;</SPAN></I></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
mCRL2 data and transformations on data are described using abstract
data types. This allows users to create their own data types by
defining the appropriate constructors and by providing functions
operating on the data types. The mCRL2 data language has built-in
support for commonly used data types, like the booleans, natural
numbers, integers and reals. The usual operations on these data
structures are predefined. Complex types can be constructed using
type constructors such as sets, lists, and functions over any data
type. This permits the modelling of systems whose behaviour crucially
depends on the data that is exchanged: actions can be parameterised
by data and if-then-else constructs allow for specifying conditional
process behaviour. The semantics of processes is defined using a
structural operational </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">semantics,
which associates with every expression in the language a labelled
transition system </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">(LTS).
Such a labelled transition system is viewed as a graph consisting of
vertices and edges, where each edge is labelled with an action, which
in turn can have data parameters. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
ppt: Least and greatest fixpoint operators, which may be nested
arbitrarily, can be used in combination with modal operators to
describe requirements of increasing complexity.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Semantically,
expressions in the property language identify a set of states in a
given labelled transition system (namely, those states that satisfy
the property). </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Although
unrestrictive, the μ-calculus is an intricate formalism. Its
usability is improved by providing a set of powerful, intuitive
macros, inspired by the </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">regular
expressions</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">found
in PDL. In many practical situations, </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">this
eliminates the need for fixpoint operators</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">.
&lt;-- maybe ppt?</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
ability to use parameterised actions in the process specification
language requires similar capabilities in the property language. Like
processes, properties are therefore interpreted in the context of a
data specification. &nbsp;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
ppt:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Fixpoint
variables and actions can be parameterised with data, boolean
expressions may contain data variables, and universal and existential
quantification over (possibly infinite) data types are allowed. For
example, one may write true to denote the set of all actions, or
exists n:Nat.val( n &gt; 5 )&amp;&amp; s(n) to denote the set of s(n)
actions, where n&gt;5. The property [ true*. exists n: Nat.val( n &gt;
5 ) &amp;&amp; s(n) ]false then expresses that such an action never
occurs.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Any
analysis on mCRL2 specifications is preceded by an automated
transformation of the specification to the linear process format. A
linear process is again an mCRL2 process specification adhering to a
restricted grammar, which essentially is a syntactic format for the
single-step transition relation that a process induces. That is, a
linear process is a recursive equation, in the untimed setting. The
state space is represented by variable d of sort D. In practice, this
is a vector of variables of complex sorts. &nbsp;Explicit state
spaces can be reduced using behavioural equivalences like strong and
branching bisimulation. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Parameterised
Boolean Equation Systems (PBESs) or just equation systems, for short,
are essentially systems of least and greatest fixpoint equations over
predicates involving parameterised predicate variables. &nbsp;← ?</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
problem of deciding whether a given property expressed in the
μ-calculus holds for a given process specification is automatically
encoded in an equation system such that the property holds for the
specification if and only if the solution to the equation system is
true. &nbsp;We are primarily interested in the solution of a PBES, as
it is also the answer to the encoded problem. ← yes also these PBS
counterexample traces are horrible! Solving a PBES typically proceeds
by transforming it into an equation system in which all data
parameters and data expressions have been eliminated [36]. Such
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">equation
systems, which are systems of fixpoint equations over propositions</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">,
are called boolean equation systems or </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">BESs</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">.
In close collaboration with its developers a coupling has been
established with LTSmin [6], that enables symbolic and pa</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">rallel
state space generation of LPSs.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Recently,
an interface has also been added that enables instantiation of
equation systems into parity games using LTSmin. As a result, the
parallel and symbolic exploration techniques from LTSmin can now also
be used to solve PBESs.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">DIRAC:
The technology enabling the verification was the symbolic exploration
(usingg the equation system interface with LTSmin, see [28]) and
solving of the equation systems encodin the model checking problems.
This allowed for a full verification of the system in under 60
seconds on a 64 bit Intel Core Duo (1.6GHz) machine with 2 GB RAM.
&nbsp;For comparison, the model checking problem for a single
property required more than 50 hours when conducted using explicit
state space generation approaches, exploring well over 1.5 x 10^8
states. Attempts to employ compositional verification, relying on
equivalence reductions to minimise state spaces, failed due to the
fact that the individual processes that make up the subsystems have
infinite state spaces.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">For
instance, the property that eventually all nodes in the network will
keep sending messages according to their schedule was expressed as a
μ-calculus formula that uses fixpoints parameterised with data
variables representing sets, and user-defined functions to specify
the schedule. The properties were verified by creating a PBES,
expanding it and solving the resulting BES. Solving time for these
(large) equation systems was reduced by interpreting the BES as a
parity game, reducing that game using a notion of stuttering
equivalence tailored to parity games, and then solving the</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">reduced
game.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">By
formalising the language, that is, by creating an SOS (Structural
Operational Semantics) for its syntactic constructs and subsequent
application of the semantic transformation, we were able to
discover—and improve upon—sub-optimal design decisions using the
mCRL2 toolset. The SOS consisted of 43 deduction rules and resulted
in an mCRL2 specification of slightly over 1000 lines of code. The
toolset that—in terms of functionality—most resembles the mCRL2
toolset is CADP, developed in Grenoble [19]. It uses the
specification language Lotos NT, which, like the process language of
mCRL2, has its roots in process algebra; it has a property language
that is, like the mCRL2 property language, based on a variant of the
propositional μ-calculus, and, like in the mCRL2 toolkit,
verification is conducted using equation systems. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Unlike
CADP, mCRL2 can be used to specify and analyse real-time systems. On
the other hand, CADP provides features to support performance
evaluation, which are lacking in mCRL2. Prominent tools focussing on
model checking include SPIN [25] and nuSMV [10]. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
languages supported by these tools have more restricted data types
&lt;-- for ppt</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
ppt if you overview other languages/toolsets: (generally booleans or
bits, limited range integers and finite arrays). SPIN uses a C-like
process specification language Promela for the analysis of parallel
programs. It primarily focusses on LTL model checking. Properties can
be established by augmenting the specification with assertions and
so-called ‘never claims’, which are either obtained from LTL
formulae or constructed manually. The tool is most famous for its use
of partial order reduction and bit hashing technology.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Several
toolsets are optimised for verifying specifications with
predominantly quantitative aspects. These include real-time and
probabilistic model checking, with tools such as Uppaal [4] and Prism
[30] The tool Uppaal is based on the notion of timed automata and
uses graphs to draw behaviour which can be used to describe timed
behaviour. Model checking of a restricted temporal logic is solved
elegantly relying on efficient representations and manipulations of
time regions. The tool Prism targets discrete and continuous-time
Markov chains and decision processes. It supports simulation and
model checking of PCTL and CSL. Contrary to the toolsets listed
above, LTSmin has no dedicated language. Instead, it provides highly
optimised state space generation tools employing multi-core, parallel
and symbolic reachability analysers and model checkers, and it is
used as back-ends for, e.g., DiVinE, SPIN and mCRL2.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">------------------------------</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">Patterns
in Property Specifications for Finite-State Verification</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Perfect
for presentation also! [General one!]. 1999 the only study of this
kind. Nevertheless, the transition of this technology from research
to practice has been slow. While there are a number of potential
causes for reluctance to adopt such formal methods, we believe that a
primary cause is that practitioners are unfamiliar with specification
processes, notations, and strategies. In a recent paper, we proposed
a pattern-based approach to the presentation, codification and reuse
of property specifications for finite-state verification. Since then,
we have carried out a survey of available specifications, collecting
over 500 examples of property specifications. We found that most are
instances of our proposed patterns. Furthermore, we have updated our
pattern system to accommodate new patterns and variations of existing
patterns encountered in this survey. Finite-state verification refers
to a set of techniques for proving properties of finite-state models
of computer systems. Properties are typically specified with temporal
logics or regular expressions, while systems are specified as
finite-state transition systems of some kind. Finite-state
verification techniques are especially critical in the development of
concurrent systems, where non-deterministic behavior makes testing
especially problematic.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Despite
the automation, users of finite-state verification tools still must
be able to specify the system requirements in the specification
language of the tool. Not only is this formula difficult to read and
understand, it is even more difficult to write correctly without some
expertise in the idioms of the specification language. We contend
that acquiring this level of expertise represents a substantial
obstacle to the adoption of automated finite-state verification
techniques and that providing an effective way for practitioners to
draw on a large experience base can greatly reduce this obstacle.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">This
system is, essentially, a collection of parameterizable, high-level,
formalism-independent specification abstractions. To evaluate our
hypothesis, we surveyed all the sources of property specifications we
could locate and collected over 500 examples of property
specifications for finite-state verification tools. As expected, we
found that the vast majority (92%) are instances of patterns in our
system. We subsequently updated the pattern system to accommodate new
patterns and variations of existing patterns encountered in the
survey. For finite-state verification, the system is modeled as a
transition system with a finite number of states and a set of
transitions, possibly labeled with events, between these states.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">A
property specification pattern is a generalized description of a
commonly occurring requirement on the permissible state/event
sequences in such a finite-state model of a system.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">A
property specification pattern describes the essential structure of
some aspect of a system’s behavior and provides expressions of this
behavior in a range of common formalisms.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Scope
operators are not present in most specification formalisms (interval
logics are an exception). Nevertheless, our experience indicates that
many informal requirements are specified as properties of segments of
program executions. Thus a pattern system for properties should
mirror this view to enhance usability.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">We
note that the various specification formalisms have different
semantics and expressive power, and that a property that can be
expressed easily in one formalism may be unnatural, or even
impossible to capture precisely, in a different formalism. For
instance, in state-based formalisms such as LTL or CTL, it is
reasonable to specify that a certain proposition hold throughout a
scope (the Universality pattern), and to regard this as being in some
sense dual to the Absence property stating that a proposition holds
at no state in the scope. In event-based formalisms, although it is
easy to require that only certain events occur within a scope, the
property that a proposition holds throughout the scope </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">would
probably be expressed in terms of the appropriate occurrence of an
event indicating that the proposition has become true and the absence
of an event indicating that it has become false</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">,
which does not bear a simple relation to the Absence pattern.
Similarly, we note that some formalisms can express conditions
involving infinite executions, while others are limited to finite
sequences of states or events. Although we expect that, in practice,
almost all of the properties to be specified can be expressed in
almost all of the commonly used formalisms, the pattern system should
point out these differences to the user.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
believe the most useful way to organize the patterns is in a
hierarchy based on their semantics. In addition to the patterns
themselves, we provide a set of pattern notes, which explain how to
combine and/or vary the patterns. For example, pattern templates are
typically parameterized by individual events or state formulae. In
some cases, however, we can allow patterns of states/events to be
substituted into the templates.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">For
most we had an expression of the requirement in a specific
specification formalism (e.g., LTL). For many we also had an informal
prose description of the requirement. The specifications came from a
wide variety of application domains, including: hardware protocols,
communication protocols, GUIs, control systems, abstract data types,
avionics, operating systems, distributed object systems, and
databases. The specification was a new variant of one of our
patterns. We discovered two interesting variants of the Response
pattern. The first describes an execution in which S must respond to
P and there must be no ZS between the (stimulus) P and the (response)
S . The second requires that the response be in the next state/event.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Of
the 555 example specifications we collected, 511 (92%) matched one of
our patterns.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">As
shown in Figure 4, the most common pattern in the sample is Response,
with the next most common being Universality and its dual Absence.
Together, these three patterns accounted for 80% of the sample. Also,
note that almost all examples that used a non-global scope were
instances of Absence, Universality, or Existence. These three
patterns are conceptually the simplest; for global scopes, they map
to single operators of temporal logics.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Traditionally,
specification formalisms are presented in terms of a minimal set of
operators in order to simplify their semantics definition. Additional
operators are then defined in terms of those operators. Our
specification pattern system provides a set of commonly occurring
high-level specification abstractions for formalisms that do not
support the definition of such abstractions directly.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
are currently exploring several directions for further work on
specification patterns. We are working to define patterns to simplify
writing a class of assume-guarantee properties in CTL. Writing such
specifications in LTL is straightforward; in CTL, however, such
properties can be quite tricky to express.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">------------------------------</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">Modeling
concurrent interactions</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">3.5
True concurrency semantics from Kuster-Filip</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">SD
semantics is given using Labelled Event Structures (LES ?) to allow
to express distributed computations as event occurrences. Event
structures, they claim, are a natural way to capture behavior
specified in SDs </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">VERY
good for PPT - underlined stuff;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><SPAN STYLE="background: transparent">causality</SPAN></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">and
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><SPAN STYLE="background: transparent">conflict</SPAN></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">are
relations over events; from them, </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><SPAN STYLE="background: transparent">concurrency</SPAN></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">is
derived as a relation too. SDs model </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><SPAN STYLE="background: transparent">possible
</SPAN></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">interactions;
liveness properties mean </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><SPAN STYLE="background: transparent">necessary
</SPAN></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">interractions.
Is assert meant to specify mandatory behavior? Not clear!</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Not
all properties can be expressed/verified without considering true
concurrency.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
other work we have shown how sequence diagrams combined with an OCL
liveness template gives us a much richer language for inter-object
behaviour specification. In this paper, we give a semantics of these
enriched diagrams using labelled event structures. Further, we show
how sequence diagrams can be embedded into a true-concurrent
two-level logic interpreted over labelled event structures. The top
level logic, called communication logic, is used to describe
inter-object specification, whereas the lower level logic, called
home logic, describes intra-object behaviour.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">One
of the major changes made to UML 2.0 with respect to its previous
versions concerns sequence diagrams which have been extended to
include a number of features </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">borrowed
from message sequence charts (MSCs)</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">[6]
and, to a limited extent, live sequence </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">charts
(LSCs) [5]. As a consequence, UML’s sequence diagrams are now more
expressive and fundamentally better structured. However, there are
still several problems with their informal description in the UML 2.0
specification [11]. A major change in sequence diagrams is that
interactions can be structured using so-called interaction fragments.
There are several possible fragments, for example, alt (alternative
behaviour), par (parallel behaviour), neg (forbidden behaviour),
assert (mandatory behaviour—though we will mention some ambiguities
in the specification concerning this fragment), and so on. Compared
to LSCs, sequence diagrams in UML 2.0 can still not adequately
distinguish between mandatory and possible behaviour. For instance,
it is still not possible to distinguish between a message that if
sent may or must be received, or to enforce progress of an instance
along its lifeline. To address this limitation we have proposed in
[2] to enrich a sequence diagram with liveness constraints expressed
in UML’s object constraint language (OCL) using an OCL template </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
provide a semantics to UML 2.0 sequence diagrams (as well as liveness
enriched sequence diagrams) and on the other hand provide a means for
reasoning about the &nbsp;specified inter-object behaviour.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
give a semantics to sequence diagrams using labelled event structures
[15]. We show how to obtain such a model from a sequence diagram.
Event structures allow us to describe distributed computations as
event occurrences together with relations for expressing causal
dependency (causality) and nondeterminism (conflict). From these
relations a further one denoting concurrency can be derived, that is,
events not related by causality or conflict are necessarily
concurrent. The causality relation implies a partial order among
event occurrences, while the conflict relation expresses how the
occurrence of certain events excludes the occurrence of others.
Essentially, event structures constitute a simple and very natural
model to capture the behaviour specified in a sequence diagram.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
interaction captured by a sequence diagram can be specified as a
collection of formulae in a true-concurrent two-level logic
interpreted over labelled event structures. The top level logic,
called communication logic, is used to describe inter-object
specification. It can be understood as modelling an observer of the
interaction who notices, for example, that whenever a message is sent
it is always eventually received, or that certain interactions are
happening concurrently. By contrast, the lower level logic, called
home logic, describes intra-object behaviour. It can be used to
capture local state invariants, interaction constraints, and the
interaction from a local perspective. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
ppt: </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Graphically,
a sequence diagram has two dimensions: an horizontal dimension
representing the instances participating in the scenario; and a
vertical dimension representing time. Objects have a vertical dashed
line called lifeline. The lifeline represents the existence of the
instance at a particular time; the order of events along a lifeline
is significant denoting, in general, the order in which these events
will occur. A message is a communication between two instances which
can cause an operation to be invoked, a signal to be raised, an
instance to be created or destroyed. Messages are shown as horizontal
arrows from the lifeline of one instance to the lifeline of another
instance. A message specifies not only the kind of communication
between instances, but also the sender and receiver event occurrences
associated to it. For an example of a sequence diagram using UML 2.0
constructs see Fig. 1 given in Section 3. UML 2.0 sequence diagrams
may contain sub-interactions called interaction fragments which can
be structured and combined using interaction operators. There are
several possible operators, for example, alt (alternative behaviour),
par (parallel behaviour), neg (forbidden behaviour), assert
(mandatory behaviour), loop (repeated behaviour), and so</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">on.
Depending on the operator used, an interaction fragment consists of
one or more operands. In the case of neg, assert and loop the
fragment has exactly one operand, whilst for most other operators it
has several. The semantics of an interaction fragment with a given
operator is described informally in the UML 2.0 superstructure
specification [11]. Below we give the meaning of some operators used
in this paper according to [11]:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">alt:
At most one of the operands will execute (so it could be that </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">none</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">executes)</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">par:
parallel merge between the behaviors of the operands. The event
occurrences of the different operands can be interleaved in any way
as long as the ordering imposed by each operand as such is preserved.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">seq:
event occurrences on the same lifeline</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">from
different operands are ordered such that an event occurrence of the
first operand comes before that of the second operand</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">neg:
represents traces that are defined to be invalid</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
borrow two concepts introduced in LSCs which are missing in sequence
diagrams, but are useful semantically, namely location and
temperature. Locations are the points in the lifeline of an instance
which correspond to the occurrence of events. Every element in an LSC
has a temperature which can be either hot or cold. This is used to
distinguish between possible (cold) and mandatory (hot) elements and
behaviour. &nbsp;Sequence diagrams can only express the possibility
that a certain scenario occurs. That is, sequence diagrams model
behaviour in the form of possible interactions, i.e. communication
patterns that may occur between a set of instances. Furthermore,
sequence diagrams, in their current setting, seem to be able to
express necessity only to a very limited extent. In particular, it is
not clear whether the intention of the new assert operator is to
specify mandatory behaviour. The superstructure specification is
ambiguous in the definition of this operator, and it is not obvious
from the text whether this operator enforces the whole
sub-interaction to happen or it is simply “expected” to happen. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Note,
however, that notationally sequence diagrams in UML 2.0 cannot
address the dichotomy between must and may behaviour as the notion of
temperature as described above does not exist. A lightweight
extension of sequence diagrams addressing this has been suggested in
[2] using constraints given in an extension of OCL with liveness
proposed in [1]. The idea is that by default a sequence diagram only
reflects possible behaviour (except for the assert operator) or
forbidden behaviour (given by the neg operator). &nbsp;It suffices to
understand that the OCL liveness constraints change the temperature
of associated locations/messages/fragments from cold to hot.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">UML
2.0 provides two kinds of conditions in sequence diagrams, namely
interaction constraints and state invariants. An interaction
constraint is a boolean expression shown in square brackets covering
the lifeline where the first event will occur, positioned above that
event inside an interaction operand. A state invariant is a
constraint on the state of an instance, for example, on the values of
its attributes. The invariant is assumed to be evaluated during run
time immediately prior to the execution of the next event occurrence:
If it is true the trace is a valid trace; otherwise, the trace is
invalid. Notationally, state invariants are shown as a constraint
inside a state symbol or in curly brackets, and are placed on a
lifeline.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Our
semantics is only defined for sequence diagrams which do not contain
neg or assert interaction fragments. The reason for this is that
there is no real need to use either interaction fragments to indicate
forbidden or mandatory behaviour. ← for ppt: same with our work!
These are properties that can be expressed outside the model. How do
you implement them in an OO language anyways? The system can exhibit
or not exhibit a certain behavior. But barely counterparts in
implementation languages (other than “assert”). </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Further,
all locations of a particular instance have necessarily different
time values (condition (5)), but locations of different instances can
still have the same time value. Notice that time here does not
necessarily mean occurrence time but visual time according to the
diagram. Visual time, or time as given in the diagram, progresses
from top to bottom. ← they can still have the same actual time. for
ppt: even though visual time says they do not happen at the same
instance, occurrence time can in fact be equal. As we have mentioned,
in a sequence diagram we may find simple constraints associated to
locations, namely interaction constraints or state invariants.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Further,
we assume here that these constraints are always local to a
particular instance</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">.
← for ppt “semantics adopted” Messages in a sequence diagram
cannot cross borders of operands or interaction fragments. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">We
have given a semantics to sequence diagrams in UML 2.0 based on
labelled event structures. The presented semantics given is not
complete as we have not considered all interaction fragments
permitted in UML (for example strict and loop). Extending the
presented model with such fragments is straightforward. ← for ppt!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Firstly,
to capture some interaction properties (e.g. forbidden behaviour,
liveness properties, state invariants, etc). In this case we can
check whether the inter-object behavioural model (a labelled event
structure) satisfies the properties. Secondly, to capture the entire
interaction of a sequence diagram as a set of formulae. An
interesting consequence of this case is that we can verify the
sequence diagram against the state-based behavioural model directly
through model checking.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">In
order to achieve the latter, we need to incorporate the concurrent
logic into the workbench as it currently only allows verification of
modal mu-calculus. Moreover, in order not to lose the
true-concurrency aspect of the semantics defined here we need to
consider a non-interleaved interpretation of CCS.</SPAN></B></FONT></FONT></FONT></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">...but
the semantics given to these approaches differs from ours as they do
not, in general, consider concurrent executions or a true-concurrent
semantic model. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt: A different graphical approach to model sequences of
interactions formally is given through specification diagrams [14].
Interestingly, specification diagrams offer most of the new
constructs available in UML 2.0 and further provide a formal
operational semantics. Liveness and safety properties can also be
asserted diagrammatically which makes specification diagrams closer
to our combined use of sequence diagrams and OCL constraints. The
essential difference in our approach is the true-concurrent
semantics. We believe that the semantics given here as well as the
embedding onto a true-concurrent logic as ours is novel and offers
interesting perspectives concerning synthesis and verification which
we will explore in the future. Fundamentally, not all properties for
concurrent systems can be expressed and verified without considering
true-concurrency.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">------------------------------</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">Formal
analysis of sequence diagram with combined fragments (2012)</SPAN></I></FONT></FONT></FONT></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">They
claim</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">to
preserve the structure of SDs[example: lifelines and combined
fragments!] which makes it easier to demonstrate that the semantics
of the original notation is maintained.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">They
formally describe SDs intu nuSMV -&gt; they also visualize the
counterexample</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">somehow
similar to our work: there are terms like “enabled occurrence
specification”, which are described similar to our busy/ready mCRL2
processes</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
Case Study they refer to a TEchnical Report. maybe read it?</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">for
ppt: Related work section useful! ; </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">alt</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">:
they use a global variable to make sure that all lifelines execute
the same operand.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
introduce an approach to formally describe Sequence Diagrams with
Combined Fragments in terms of the input language of the model
checker NuSMV. Scenario-based models have been widely employed for
the description of interactions among environmental actors (e.g.,
human beings) and the components (aka Lifeline) of the software
systems through the exchange of messages. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
semantics of Sequence Diagram with Combined Fragments is not formally
defined compared to their precise syntax descriptions (Object
Management Group, 2011), making it is hard to derive the traces from
Sequence Diagrams. Thus, subtle errors from concurrency can easily be
introduced to Sequence Diagrams to evade discovery via manual
inspection. for ppt: Our approach supports all the features of
Combined Fragments, including all 12 Interaction Operators, nested
Combined Fragments, both asynchronous and synchronous Messages, and
Interaction Constraints.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">ppt:
</SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">We
devise an approach to codify the semantics of Sequence Diagrams and
Combined Fragments in the input language of NuSMV by deconstructing
Sequence Diagrams and Combined Fragments to obtain fine-grained
syntactic constructs (see section 2 and 3). We formally describe each
Combined Fragment in terms of NuSMV (Cimatti et al., 2000) modules ←
for ppt</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt: We have also created an Occurrence Specification Trace Diagram
generator that automatically produces Sequence Diagram visualizations
from NuSMV-produced counterexamples. This automation will increase
the accessibility of our approach by allowing software engineers to
remain focused in the realm of Sequence Diagrams.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Messages
are of two types: asynchronous and synchronous. The source Lifeline
can continue to send or receive other Messages after an asynchronous
Message is sent. If a synchronous Message is sent, the source
Lifeline blocks until it receives the target Lifeline’s response.
The semantics of the seq Sequence Diagram is defined by two sets of
traces, one containing a set of valid traces, denoted as Val(seq),
and the other containing a set of invalid traces, denoted as
Inval(seq). The intersection of these two sets is empty.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">ppt:
In this section, we develop techniques to translate Sequence Diagrams
into the input language of NuSMV. The NuSMV model preserves the
structure of the Sequence Diagrams (e.g., Lifelines and CFs), which
makes it easier to demonstrate that the semantics of the original
notation is maintained. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">We
base the mapping of a Sequence Diagram to the input language of NuSMV
on syntactic deconstruction. A Sequence Diagram is represented as the
main module. We map the Lifelines into respective NuSMV modules,
which are instantiated and declared in the main module. Recall that a
CF is projected onto each of its covered Lifelines to obtain a CEU.
Accord-</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">ingly,
its Operand on each of the covered Lifelines forms an EU. Both CEUs
and EUs are represented as NuSMV modules. ← DAFUQ</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">ppt:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
the case that a Sequence Diagram contains nested CFs (i.e., a CEU
consisting of an EU that encloses other CEUs), we map each enclosed
CEU as a submodule of the containing EU’s module. This procedure is
recursively applied until all CEUs and EUs are mapped accordingly.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">ppt:
use this to explain the algorithm of ready vs busy processes: To
express the interleaving semantics among Lifelines, we introduce an
INVAR statement in the main module to assert that at most one OS on
one of the Lifelines can take place in each step (the semantic rule
4). A boolean variable chosen is used for each Lifeline to restrict
that: (1) a Lifeline is chosen only if it is enabled, i.e., there is
an OS that is ready to take place on the Lifeline, represented by the
derived variable enabled; (2) either only one Lifeline can be chosen
to execute an OS in each step if Lifelines are enabled (i.e., before
all OSs on the Lifelines have occurred); or no Lifeline can be chosen
when all Lifelines are not enabled and all chosen variables remain
False thereafter. A sending OS is enabled to execute if and only if
the OSs prior to it on the same Lifeline have already occurred. A
receiving OS is enabled to execute if and only if the OSs prior to it
on the same Lifeline and the sending OS of the same Message have
already occurred (the semantic rules 2 and 3). To execute the OSs
enclosed in CFs, the variable chosen for each Lifeline is passed to
the CEU and EU modules on that Lifeline as a parameter.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">ppt:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Collectively,
we call Alternatives, Option, and Break branching constructs. &nbsp;←
opt and BREAK are syntactic sugar; In an Alternatives CF, each
Operand must have an explicit or an implicit or an “else”
Constraint. An implicit Constraint always evaluates to True. The
“else” Constraint is the negation of the disjunction of all other
Constraints in the enclosing Alternatives. The chosen Operand’s
Constraint must evaluate to True. If none of the Operands whose
Constraints evaluate to True, the Alternatives is excluded The use of
exe guarantees that all the enclosed Lifelines choose the same
Operand’s EU module to execute to avoid inconsistent choices (e.g.,
Lifeline L1 chooses Operand 1’s EU whereas Lifeline L2 chooses
Operand 2’s EU). ← global variable, not nice!</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">ppt</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">:
We need to evaluate the Interaction Constraint of its sole Operand
after minimum number of iterations. If n ≤ minint, the Loop
executes. If minint &lt; n ≤ maxint, the Loop executes only if
cond[n] evaluates to True. &nbsp;← we haven’t implemented this An
Assertion represents that, on each Lifeline, a set of traces of its
Operand are the only valid traces following the Assertion’s
preceding OSs. The semantics of a Weak Sequencing enforces the total
order among EUs of Operands on the same Lifeline. In any EU module of
an Operand (except the first one), the first OS takes the variable
flag_final of the EU of the preceding Operand on the same Lifeline as
an enabling condition, i.e., the EU cannot execute before the
preceding one completes.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">ppt:
The Sequence Diagram Translation tool takes the XML representation as
input, parses it into a syntax tree, and transforms it into a NuSMV
model. NuSMV model checker takes as input the generated NuSMV model
and a temporal logic formula that is specified by the software
engineer. ← temporal logic formula specified by the software
designer? LOL!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">ppt:
The output from the OSTDG is an easy-to-read Sequence Diagram
visualization of the counterexample to help the software engineer
locate the property violation faster. Thus, the software engineer may
transparently verify a Sequence Diagrams using NuSMV, staying solely
within the notation realm of Sequence Diagrams. We check the example
on a Linux machine with a 3.00GHz, 8 cores CPU and 32GB of RAM. One
ex-</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">ample
executed in 19 minutes 49 seconds with 3,825 reachable states out of
total 3.71e+012 states, while the other example executed in 18
minutes 14 seconds with 192 reachable states out of total 4.95e+012
states. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">ppt:
Related work, excellent overview: To the best of our knowledge, our
technique is the first to support all CFs and the nested CFs. Lima et
al. provide a tool to translate UML 2 Sequence Diagrams into
PROMELA-based models and verify using SPIN, with counterexample
visualizations (Lima et al., 2009). Their translation does not
support Critical Region, Strict Sequencing, Negative, Assertion,
Consider, Ignore, synchronous Messages and Interaction Constraint.
Van Amstel et al. present four complementary approaches for analyzing
UML 1.5 Sequence Diagrams, which do not support CFs (van Amstel et
al., 2007). They model check Sequence Diagrams using SPIN. Alawneh et
al. introduce a unified paradigm to verify and validate prominent UML
2 diagrams, including Sequence Diagrams, using NuSMV (Alawneh et al.,
2006). Their approach supports Alternatives and Parallel.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">To
model check MSCs, Alur et al. (Alur and Yannakakis, 1999; Alur et
al., 2005) formalize MSC using automata. They examine different cases
of MSC verification of temporal properties and present techniques for
iteratively specifying requirements (Alur et al., 2003). They focus
on MSC Graph, which is an aggregation of MSCs. We extend their work
to encompass more complicated aggregations using CFs. Peled et al.
perform intensive research on the verification of MSCs (Muscholl et
al., 1998; Gunter et al., 2001), in particular, they present an
extension of the High-Level MSC (Peled, 2000). They specify MSC
properties in temporal logic and check for safety and liveness
properties. Leue et al. translate the MSC specification, especially
branching and iteration of High-Level MSC, into PROMELA to verify
MSCs using the XSPIN tool (Leue and Ladkin, 1996). As Sequence
Diagrams have similar expressive features, our technique can be
extended to work with their approach. Kugler et al. improve the
technique of smart play-out, which is used to model check LSCs to
avoid violations over computations (Kugler et al., 2009). Walkinshaw
and Bogdanov (Walkinshaw and Bogdanov, 2008) detail an inference
technique to constrain a finite-state model with LTL. These
constraints reduce the number of traces required as input to a model
checker for discovery of safety counter examples. Our work can
automatically model check each Sequence Diagram of a system against
LTL properties separately, which helps to alleviate the state
explosion problem.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">------------------------------</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">Temporal
logic for Scenario-based specifications</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Semantics
of LSC [ Live Sequence Charts] provided, by translating it to
temporal logic (well, subsets of it)</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Paper
addresses the relationship between scenario-based requirements and
temporal logic They claim the approach is good enough to be applied
to other scenario-based languages. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Conditions
on messages are very unintuitive, almost nonsense; example:
conditions can be globally shared among instances; </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">LSC
is lacking many UML features, paper old! (2005)</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Quite
understandable first steps towards formalisation of LSC [use them for
mCRL2]</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Unbounded
loops: performed an apriori unknown number of times [recursion ?
howto?]</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">One
of the most widely used languages for specifying scenario-based
requirements is that of message sequence charts (MSCs), adopted long
ago by the ITU [26], or its UML variant, sequence diagrams [25]. This
paper addresses the relationship between scenario-based requirements
and temporal logic [23]. As a scenario based language we focus on the
language of live sequence charts (LSCs) [7] which is a powerful
extension of classical message sequence charts.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">LSCs
distinguish between behaviors that may happen in the system
(existential) from those that must happen (universal). We show how
the semantics of live sequence charts can be captured using temporal
logics.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
assume the LSC specification relates to an object system composed of
a set of objects O = {O1 . . . On }. An object system corresponds to
an implementation, and our goal while providing semantics for LSCs is
to define if a given object system satisfies an LSC specification.
The instance identifiers in the LSC charts are objects from O, and
possibly also the environment denoted env. The LSC specifies the
behavior of the system in terms of the message communication between
the objects in the system. We want to define the notion of
satisfiability of an LSC specification. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">What
follows are good ideas for formalisation, but formulas cannot be
copy/pasted here </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt: we assume SDs are well formed.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
activation message of a chart designates when a scenario described by
the chart should start ← for ppt: activation object.message in AD?
&nbsp;The formula requires that the activation message is sent once
(wi0 = f (amsg(m))), and then the trace satisfies the chart;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">We
assume also that a message does not appear more than once in the same
chart.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><SPAN STYLE="background: transparent">← <FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B>well,
actually a bad assumption</B></SPAN></FONT></FONT></SPAN></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
logic CTL is a restricted subset of CTL∗ . In CTL the temporal
operators G, F, X and U must be immediately preceded by a path
quantifier. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
LSC language allows using conditions, which are assertions on the
variables of the system. Variables may be local to an instance or
globally known. Conditions can come in two flavors: mandatory (hot)
and provisional (cold). If a system run encounters a false mandatory
condition the run aborts abnormally, while a false provisional
condition induces a normal exit from the enclosing charts. Conditions
can also be shared by several instances, forming a synchronization
barrier.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">ppt:
inspiration future work:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
verification is based on translating an LSC chart into a timed Buchi
automaton, as described in [19], and it also handles timing issues.
Standard translations from B ̈chi automata to temporal logic can
then be applied. ← Buchi automata based interpretation of Sequence
Diagrams, this is my “monitoring” process.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">------------------------------</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">A
Scenario Based Notation for Specifying Temporal Properties</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">!
A chain is different from as sequence of messages because repetitions
of the same message before the next element of the chain are not
allowed</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Survey
of the strengths of MSC [Message Sequence Charts] and UML2 SDs,
proposes something better, which they both lack</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">They
propose an extension of a subset of UML2 Sequence Diagrams</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">property
is a relation on a set of exchanged system messages ← ppt</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">VERY
IMPORTANT AS INSPIRATION</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">it
is known that LTL formula can be converted to Buchi automaton which
is then used by model-checkers ← ppt? </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">they
only deal with CTL in the paper; they measure their approach agianst
the 1999 paper on patterns in property specification </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">UML
no formal semantics → not clear what happens when nesting NEG and
ASSERT. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt: we are not concerned with realtime systems so we abstract from
absolute time;</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">chain
constraints on message labels: what can happen before, after, and
during a message exchange ← cause &amp; effect</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">partial
ordering in SDs is by default; strict ordering with operator STRICT</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">only
the act of sending and receiving are considered to be atomic ← in
synchronous communication they happen simultaneously;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">message
label prefixed with sender, postfixed with receiver</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">upper
and lower number of repetitions in a loop ← useful for “at
most/least k times”</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">So
why not use these as attributes of messages? They do here!</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Temporal
logics are commonly used for reasoning about concurrent systems.
Model checkers and other finite-state verification techniques allow
for automated checking of system model compliance to given temporal
properties. These properties are typically specified as linear-time
formulae in temporal logics. Unfortunately, the level of inherent
sophistication required by these formalisms too often represents an
impediment to move these techniques from “research theory” to
“industry practice”. The objective of this work is to facilitate
the non trivial and error prone task of specifying, correctly and
without expertise, temporal properties.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Properties
that are simply captured within the context of interest and that are
easily described by natural language may result very hard to specify
in LTL. In other words, there is a substantial gap between natural
language and the LTL syntax.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Although
in this paper we focus on formulae expressed in LTL notation, other
similar formalisms (such as CT L, ACTL) suffer the same problems.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
main problems of the latter approaches is in balancing the expressive
power and the simplicity of the graphical property description
language</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">.
GIL [7] is sufficiently expressive but lacks in user friendliness.
For example, GIL achieves expressive power by allowing nesting but
its formulae become potentially difficult to understand. This
difficulty comes from the fact that its graphical notation is too
close to temporal logic. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Based
on these considerations, we believe that an accurate analysis is
necessary in order to understand what is required in a formalism to
express a “useful set” of temporal properties (e.g., the set of
the property specification patterns [8]) while keeping in mind that
easy use and simplicity are mandatory requirements to make a
formalism adopted</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">by
industries. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
focus on the graphical formalisms for scenario-based specification
that are commonly and extensively used within industrial software
development practice: Message Sequence Charts (MSCs) [12], and UML
2.0 Interaction Sequence Diagrams. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Within
our PSC language, a property is seen as a relation on a set of
exchanged system messages, with zero or more constraints. Our
language may be used to describe both positive scenarios (i.e., the
“desired” ones) and negative scenarios (i.e., the “unwanted”
ones) for specifying interactions among the components of a system.
For positive scenarios, we can specify both mandatory and provisional
behaviors. In other words, it is possible to specify that the run of
the system must or may continue to complete the</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">described
interaction.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
main goal of this work is to propose a scenario-based visual language
for specifying temporal properties which balances expressive power
and simplicity of use.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
other words it is not possible to clearly distinguish between
mandatory messages and provisional ones. Furthermore, since MSCs can
only represent desired exchanging of messages (i.e., positive
scenarios), it can only be possible to define a set of liveness
property to stipulate that “good things” do (eventually) happen
during the execution of a system. On the contrary, often, it is
necessary to express forbidden scenarios (i.e., negative ones) to
specify safety properties which stipulate that “bad things” do
not happen during execution of a system;</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">PSC:
Property Sequence Chart.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Table1
important! ← comparison between PSC, UML2.0 SDs and MSC</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
order to identify the sender and the receiver components, the labels
for intraMSGs are prefixed by the name of the sender component and
postfixed by the name of the receiver component. For example, the
label Ci .l.Cj denotes the message labeled by l sent from the
component Ci to the component Cj . </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Regular
messages: the labels of such messages are prefixed by “e:”. They
denote messages that constitute the precondition for a desired (or an
undesired) behavior. It is not mandatory for the system to exchange a
Regular message, however, if it happens the precondition for the
continuations has been verified. This kind of messages can be mapped
into UML 2.0 and MSC provisional messages (i.e., non mandatory
messages graphically represented by simple arrows). Required
messages: are identified by “r:” prefixed to the labels. It is
mandatory for the system to exchange this type of messages. By means
of these messages we can specify liveness properties. Required
messages have the same meaning of UML 2.0 assert messages that are
used to identify the only valid continuations. All the other
continuations result in an invalid trace. No similar kinds of
messages exist in the MSC specification.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Fail
messages: the labels are prefixed by “f:”. They identify messages
that should never be exchanged. Fail messages are used to express
undesired behaviors and hence safety properties. UML 2.0 neg operator
expresses the same notion. In fact, the operator neg is used to
represent invalid traces.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">For
both boolean formulae and chains, past constraints are placed near to
the message arrow source. On the contrary future constraints are
placed near to the arrow target. ← nonsense, cluttered?!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">There
is no direct mapping for the complement of a message in MSC and UML
2.0. It is</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">possible
to indirectly express this concept by encapsulating each message in
the complement set of a given message into the alt operator of both
MSC and UML 2.0. For systems with a high number of exchanged
messages, this can be tedious or unfeasible.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
ppt and paper: In Figure 1 we can see that, parallel, loop, and
simultaneous operators are introduced with a UML 2.0 like graphical
notation. As previously mentioned, the UML 2.0 standard has not a
well defined semantics. Thus, it is not clear whether having the
power of recursion is a good thing in the first place, since it
introduces an extra level of complexity into any semantics by
implying fixed points. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Informally,
the parallel operator allows a parallel merge between the behaviors
of the two operands. The messages arguments of the operands can be
interleaved in any way as long as the ordering imposed by each
operand as such is preserved. The loop operator allows the operand to
be repeated a given number of times. As it is shown in Figure 1, it
is also possible to specify a lower and an upper number of
repetitions.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
PSC operational semantics is given in terms of Buchi Automata [3]
that are an operational representation for LTL formulae. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">ppt:
We recall that the automata-based model checking uses automata for
both representing the system and the property. More precisely the
model checker requires having the complement of the languages
recognized by the automaton of the property. Since it is an expensive
task to negate a Buchi automaton, we directly express in the Buchi
automaton the negation of the desired temporal property.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">More
precisely, Psc2Ba can graphically express a useful set of both
liveness and safety properties (from evaluation section) </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">FOR
FUTURE WORK INSPIRATION!!: Below, how to evaluate!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
order to better validate the expressivity of the PSC language we
refer to the specification patterns system introduced by the Kansas
State University [8]. Dwyer et al. define a repository with the
intent of collecting patterns that commonly occur in the
specification of concurrent and reactive systems. The patterns are
defined for various logics and specification formalisms and we refer
to the mappings for property patterns in LTL. A specification pattern
has a scope that defines the range in which the pattern must hold;
for example while global means that the pattern must hold everywhere,
between q and r means that the pattern must hold from the first
occurrence of q to the first occurrence of r only and only if r
happens.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
are able to represent in PSC all the defined patterns [20]. Similarly
to what done in the specification patterns system, in PSC a scope can
be represented once and instantiated for each pattern. See the PSC
web page [20] for a description of all patterns.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
translation algorithm proposed by Ghezzi et al. [25] gets in input a
LSC and produces an automaton and a LTL formula, both necessary to
express the correct temporal properties. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
automaton and the LTL formula are translated into Promela code that,
introduced into the proposed process, allow for the verification of
systems. The paper [14] proposes a translation into CTL* while the
work [13] offers a solution for timed Buchi automata generation.
Other approaches [4, 15, 1] define graphical languages that appeared
to be not easily comprehensible and not easily integrable into
industrial software development processes.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">------------------------------</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">Pattern
Based Property Specification and Verification for Service Composition</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">It
builds on the 1999 property-pattern system by alowing nesting and
composition into more complex requirements; it refines and extends
the original pattern system they propose pattern-specification
language, and represent its semantics as FSMs. Great summary of the
1999 paper. The semantics of pattern properties may be given in LTL,
CTL, QRE or FSA.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">FSA
semantics of example property pattern;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">composite
pattern: by connecting pattern properties using boolean operators
(connectors?) given: every </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><SPAN STYLE="background: transparent">elementary</SPAN></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">pattern
property has a FSM semantics. The verification example they give is
really a toy.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
rigorous compliance checking approach usually needs the requirements
being specified in property specification formalisms such as temporal
logics, which are difficult</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">for
ordinary software practitioners to comprehend. In this paper, we
propose a property pattern based specification language, named
PROPOLS, and use it to verify BPEL service composition schemas.
PROPOLS is easy to understand and use, yet is formally based. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">It
builds on Dwyer et al.’s property pattern system and extends it
with the logical composition of patterns to accommodate the
specification of complex requirements. PROPOLS is encoded in an
ontology language, OWL, to facilitate the sharing and reuse of domain
knowledge. A Finite State Automata based framework for verifying BPEL
schemas against PROPOLS properties is also discussed.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Model
checking [5] is a formal approach to software behavioral compliance
checking. In this approach, a software application is abstracted as a
formal model like Labeled Transition Systems (LTS), Finite State
Automata (FSA), Petri nets, or process algebra. The behavioral
requirements are specified as properties in formalisms such as Linear
Temporal Logic (LTL), Computation Tree Logic (CTL), or Quantified
Regular Expressions (QRE). Then the formal model can be verified
against the specified requirements/properties through exhaustive
state space xploration. A serious problem, however, prevents the wide
adoption of this approach. That is, the formal properties are
surprisingly difficult to write for practitioners, who usually don’t
have solid mathematical backgrounds. ← well, that and state-space
explosion?!</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">good
for future paper:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
property patterns enable people who are not experts in temporal
logics to read and write formal specifications with ease and thus
make model checking tools more accessible to common software
practitioners [8]. Although it is claimed in [6] that patterns can be
nested, no further work has been done on how to define composite
patterns and what are their semantics. PROPOLS refines/extends the
original pattern system in [6] by introducing the logical composition
of patterns. This mechanism enables the definition of complex
requirements in terms of property patterns, which is previously
difficult or even impossible. PROPOLS uses the Web Ontology Language
(OWL) as its base language. This makes PROPOLS properties sharable
and reusable within/across application domains.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Representing
the semantics of PROPOLS properties as FSAs, representing the
semantics of a BPEL schema as a LTS/FSA using Foster’s BPEL2LTS
tool [9], and checking the language inclusion between these two FSAs.
Property specification patterns were first proposed by Dwyer et al in
[6]. These patterns include a set of commonly occurring high-level
specification abstractions for formalisms like LTL, CTL or QRE.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
pattern property specification consists of a pattern and a scope. The
pattern specifies what must occur and the scope specifies when the
pattern must hold. Patterns are classified into occurrence patterns
and order patterns. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Occurrence
and order - one dimension; scope - another dimension. Basically time
is one dimension, and frequency is another (sort of)</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Figure
1 important; but yeah, “globally” properties are easy with FSM.
How about other categories?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Every
pattern (whether order or occurrence has a scope)</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
may write a composite</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">pattern
connected with the ‘And’ operator:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">Customer.GetOrderFulfilled
Precedes Bank.Transfer Globally</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">And</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">Customer.GetOrderFulfilled
LeadsTo Bank.Transfer Globally</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
this situation, both ‘GetOrderFulfilled’ and ‘Transfer’
should occur and must occur sequentially in the program. As stated
earlier, every elementary pattern property has a corresponding FSA
semantics. We thus define the semantics of a composite pattern
property from the logical composition of FSAs of its component
pattern properties The language set that can be accepted by a
composite FSA is the composition of the language set of the component
elementary FSAs. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">NICEST
explanation of a monitoring process ← for ppt</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">As
shown in Fig. 8, the verification is conducted in 3 steps. (1) For
every pattern property, a semantic equivalent Total and Deterministic
FSA (TDFA) is built. If the property is a composite one, the
corresponding TDFA is constructed by composing the TDFAs of its
sub-properties according to the composition semantics definition in
section 4.2. (2) For the BPEL schema, a finite and deterministic LTS
model is generated, from which a TDFA is built by introducing the set
of final states and an error state to collect all the unacceptable
events (or operation invocations) of each state. (3) The compliance
of the BPEL schema to the PROPOLS properties is then checked as a
verification problem of whether the accepting event sequences of the
BPEL TDFA are all present in the accepting event sequence set of the
property TDFA. This is done by testing the emptiness of the
intersection of the BPEL TDFA and the complement of the property
TDFA. The most significant difference between these approaches and
our work is that we focus on a practitioner-oriented approach to
property specification.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">------------------------------</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">Debugging
UML Designs with Model Checking (2002!)</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">For
future work: nesting of temporal operators can increase the
complexity of verification and decrease the confidence in the meaning
of the formula</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">general
correctness properties: non-reachable code, absence of deadlocks,
arithmetic errors ← they don’t require explicit formulas</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">very
informal, probably good for ppt; good definition of a monitoring
process automaton</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">some
very good stuff underlined;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">very
intuitive non-technical explanation of
overapproximation/underapproximation and which properties are
suitable. Just what I need for extending the CCGrid paper with “+”
explanation of abstractions by nondeterminism.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Alternative
way to SDs is to consider </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">OCL
as a property language!</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
ppt: Although this technique is successfully applied to many formal
description techniques, it is not commonly used by the object
oriented programming community, in general, nor by UML developers, in
particular. In this paper, we provide a comprehensive overview and
rules to integrate model checking into UML-based designs, showing its
usefulness from a practical point of view</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt: Model Checking represents one of the most useful results of
almost thirty years of research in formal methods to increase the
quality of software and other related systems. A model checker is an
automatic tool that is able to compare two descriptions of the
behavior of a given system. Usually, one description is considered as
the requirements and the other one as the actual design of a system
to meet these requirements. The main constraint is that the
description of thedesign, usually called the model, must be
executable. This executability makes it possible to perform an
analysis of all the execution paths (exhaustive analysis). The main
usefulness of model checking is its capability to produce a
counter-example, or sequence of steps in the model, leading to the
violation of a particular property. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Unified
Modeling Language (UML) provides a wide range of notations to model a
software system from different perspectives, organizing them in five
interrelated views: design view, process view, implementation view,
deployment view, and use case view.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">for
future work, for ppt also?: However, it is more complex to detect
when a dynamic behavior described by several state diagrams
corresponds to an acceptable scenario. Our aim in this work is to
show how a very well known technique (i.e. model checking) can be
applied to overcome the lack of tools to support exhaustive analysis
of diagrams describing dynamic behavior of UML models, specially when
modeling concurrent systems with UML. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">the
program can be encoded with formalisms very similar to programming
languages, and some current tools can even work with the final code.
The verification task consists in ensuring that all, some or no
execution paths, in the current design for the software, satisfy a
particular (desirable/undesirable) property. This task is carried out
automatically by generating and analyzing all the potential (finite)</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">states
of the program (exhaustive analysis). The structure is obtained by
executing all potential interleavings of the concurrent program.
Modern model checking tools work by translating the formula into an
automaton to recognize the correct/incorrect execution paths. As the
verification is performed as soon as the states are produced (and
stored), the method does not require the previous construction of the
whole state graph. This is why it is called on-the-fly model
checking.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
success of model checking to debug models of concurrent software
(writing the models in academic formal description techniques and
properties with temporal logic) has made this term relatively popular
to describe other verification methods such as: 1) the automatic
analysis of general correctness properties of concurrent systems that
do not require a particular representation with a property language
(absence of deadlock, non-reachable code, arithmetic errors, etc), 2)
the automatic verification of more commercial formal description
techniques (for example SDL) </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Nice
overview of the type of UML views</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">To
cover all these possibilities, UML includes structural (class,
object, component, deployment) and behavioral (use case, sequence,
collaboration, state, activity) &nbsp;iagrams. All these diagrams are
distributed in the so-called views, giving five different
perspectives of the same model, all of them organized around use
cases. Dynamic behavior is captured by four different kinds of
diagrams: sequence diagrams, interaction diagrams, state diagrams,
and activity diagrams. &nbsp;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Our
idea is to apply model checking to compare the behavior described by
a sequence diagram (or a collaboration diagram) with the behavior
expressed by a set</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">of
state diagrams. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">ppt:
If we consider that state and sequence diagrams are the two most
representative notations to describe the dynamic behavior of a
system, then three main phases have to be covered to apply model
checking. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">As
model checking works automatically, the Most of UML-based tools
include some possibilities of consistency analysis and automatic
system to be analyzed must be closed with respect to the environment.
</SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
automaton evolves synchronized with the system being debugged,
observing events in the statecharts, and when it reaches a final
state (the last event in the sequence diagram), then the property is
verified. Of course, the automaton is never accessible to the user,
and the verification tool must keep it hidden, but it allows
extending the basic verification method in Phase 1 to deal with the
sequence diagram verification.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Partial
order reduction is a method for replacing several interleaved
sequences of events (or actions) by only one that represents the
whole set. The State compression method reduces the use of memory by
compressing the representation of the states without losing
information, but increasing the verification time.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">In
general, abstracting the model of a system means to construct a
simpler specification which is equivalent to the initial one with
respect to the properties to be verified. The abstract model can be
verified using less time and memory.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
most powerful abstraction of statecharts to verify sequence diagrams
is the abstraction of events. This kind of abstraction consists in
using a single name of event (an abstract event) to represent a set
of real events. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">How
to know if button is representing play or load to fire the correct
transition? We need to introduce non-determinism in order to preserve
at least the same potential execution sequences as in the initial
statechart. This is a key point to obtain useful verification results
!!!! ← THIS IS THE IDEA BEHIND THE CCGrid paper guidelines</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
verification of undesired one in Figure 8 (left). It is worth noting
that the never produces a sequence like thebehaviors (Phase 3) is
done directly: If M* does not verify SD∗, then M does not verify
SD. &nbsp;← overapproximation: if it’s absent in the M* which
contains more behavior than M, then it’s absent in M too!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">However,
the loss of precision in the events and the addition of
non-determinism in the statecharts make the verification of desirable
behaviors (Phase 2) a more demanding task. One abstract event
represents a set of real events, so the occurrence of the abstract
event is not conclusive to decide about the occurrence of the real
one ← overapproximation is good for absence, but not for proving
presence of good traces. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
same problem appears when the tool reports an error in the
verification of undesirable properties. In both cases, we have to use
the abstract trace in order to check whether a particular sequence of
events represented by this one, is possible in the initial model. If
the sequence exists in M, then we have information to give a result
regarding the behavior of M. Otherwise, we have to revise the
abstraction. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">But,
even if the scenarios were formalized (e. g. as sequence diagrams)
the construction of the </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">whole
use-case tree (as a graphical view of the system) limits the
possibilities for automatic verification for two reasons. The first
is that a path in the use-case tree could contain all model events,
so the scenarios should also consider every event, including those
produced by objects which are not actually participating in the
scenario. These problems in Barnard’s method are overcome in our
proposal by considering partial verification as a debugging method.
Our observability conditions combined with the </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">objective</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">(desirable/undesirable
sequence diagram) for just one property in each verification reduces
the size of the scenarios. The underlying automata-based verification
for sequence diagrams allows us to explore the state space with an
on-demand generation of states (on-the-fly model checking).</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Being
temporal logic outside the UML framework, our approach is more
suitable for the way UML software engineers normally work. A related
and non-explored alternative closer to UML could be the use of OCL as
a property language.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Tool
vUML [LP99], although keeps Promela hidden to the user, only supports
the verification of general properties of statecharts.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">HUGO
[SKM01] also employs Promela and SPIN as the core verification
technology, but its users work with UML descriptions. HUGO verifies
whether the desirable behavior described by a collaboration diagram
is feasible for a set of UML state machines (equivalent to our Phase
2.)</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">------------------------------</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">UML
formal semantics: lessons learned</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">OCL
usage examples</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
ppt: modelers typically choose a semantics which is considered
correct in a general, or convenient for their own purposes</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">fUML==
foundational UML: subset of computationally complete executable
models expressed in UML. ← disregards state machines and SDs?</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">end
users systematically discard any formal semantics for UML, because of
the accompanying complexity and lack of industry-scale tool support;
UML diagrams are not properly related with eachother and integrated;
consensus exists on the static UML semantics, still many challenges
with the dynamic UML sublanguages.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">UML
offers elements of a graphical concrete syntax to create visual
models of software-</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">intensive
systems. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
ppt:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">UML
aims to be a </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">standard
modelling language for concurrent and distributed systems. Though UML
is not a development method by itself, it was designed to be
compatible with the leading object-oriented software development
methods of its time. Development methods have been created based on
UML, the best known is the Rational Unified Process (RUP [8]) of IBM.
The UML rapidly gained popularity in industry, as it facilitated the
communication between most diverse stakeholders about a system at
different phases of development, on one hand, and, on the other,
several points of view onto that system, including its context. In
contrast to its popularity, there are severe reservations about the
UML in science and various domains of application. The most
fundamental criticism of UML made by the models-based engineering
community has been its lack of informal and formal semantics, i.e.,
the colloquial nature of UML’s semantic description in natural
language or in terms of UML itself; see [10,11]. Therefore, as
pointed out in [12], multiple and potentially contradictory
interpretations of one and the same model are not excluded, and
automatic interpretation must be hard coded in some way or another in
the tool chain. Another matter </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">is
whether object-oriented programming concepts provide the right
modelling concepts. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">However,
according to [16], the UML specification is highly technical, terse,
and very difficult for beginners to understand, and the question of
[17] Why are some specifications so hard to read? Needless to say, an
informal description unavoidably involves ambiguities and lacks
rigour, and thus precludes the reasoning,early simulation and
automated analysis of a system design expressed by a UML model. This
issue was speedily tackled by the research community as soon as the
potential of UML as a de facto standard was recognised.1 While (a
large portion of) the static semantics of UML seems to have promptly
reached a consensus,2 the dynamic semantics of the UML sub-languages,
such as activities, interactions and state machines, poses a major
challenge. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt: No reliable quality assurance can be undertaken as long as the
very language employed to describe the system under scrutiny is
deprived of a precise semantics. One consequence of these open issues
is the low level of automation in tool support for the UML.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
UML sublanguages are complicated as many constructs and features have
been put at disposal without the necessary fine tuning with each
other. The Object Constraint Language (OCL [18]), for example, is
used to formulate well-formedness rules in UML models, and is also
intended to be an adjunct to UML for modellers who wish to add to
their models more precision that cannot be otherwise (e.g.,
graphically) stated. OCL can be used as a navigation language, to
write class invariants and pre-/post-conditions of methods within
classes of a class diagram, guards of transitions of state machines,
and guards of communication between instances in a sequence diagrams,
among other uses.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
UML interactions describe possible message exchanges between system
instances, and make up a powerful language which, besides integrating
the standard operations like sequential, parallel, and iterative
composition of interactions, provide means to specify recursive
behaviour and negative behaviour, i.e., behaviour forbidden in system
implementations. These three interpretations of interaction negation
are based on manipulations of sets of event traces, such that the
universe opossible traces is partitioned into “valid,” “invalid”
and “contingent” traces. A further interpretation for negation is
given in [23], which treats negation as a modality rather than an
operator. UML interactions also put an operator for assertion at
disposal, whose meaning is closely related to that of negation; the
semantic discussion in relation to negation also applies to
assertion. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Compositionality
amounts to the meaning of a complex expression being determined by
the meanings of its constituent expressions and the rules used to
combine them.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">On
the one hand, a vague description of the UML sublanguages allows for
a “free” interpretation of them (e.g., negation of interactions).
This is in line with the observation</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">of
[15] cited above, that modellers typically ignore any normative UML
semantics and concoct a one which is considered correct in general or
convenient for their own purposes. ← a word of caution: not
everything is vague, in fact a small subset of the language is ←
for ppt</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">OMG
made a request for proposal in order to enable a chain of tools that
support the construction, verification, translation, and execution of
computationally complete executable models expressed in a subset of
UML; see [28].4 The current draft version of the official adopted
specification is called Foundational UML (fUML [29]). The semantics
of fUML is defined in fUML itself and using a base UML (bUML) in
order to break circularity. A base semantics provides an
interpretation of bUML as a set of first-order axioms over possible
execution traces; the base semantics specifies when particular
executions conform to a model defined in bUML, it does not generate
executions. The subset addressed by this proposal most noteworthy
disregards state machines and interactions (i.e., sequence diagrams).</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">On
the one hand, a semantic core denominated the System Model theory was
defined. In general, the System Model forms a foundation for
structure, behaviour and interaction</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">of
object-oriented, possibly distributed systems. The System Model is
abstract enough to be of general value, but also sufficiently
detailed to allow simulation and execution of UML models. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">What
these efforts inevitably left untreated is the fact that a particular
language may have different intended semantics when used at different
stages of development. But these interaction specifications, at
different stages, may be devised with a different intended semantics
in mind: during integration test, they are (at least desirably)
exhaustive, whereas during analysis they not necessarily are striven
for exhaustiveness. Indeed, as pointed out in [27], the claim of
universality of UML, meaning that (for ppt)?: </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">UML
is a notation suitable for analysis, design and documenting the
implementation, necessarily entails multiple interpretations.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
practice, mainly for description of structure and seldom for the
specification of behavior. As surveyed in [14], the reasons for this
situation are that the notations provided by the UML for describing
behaviour are complex, poorly defined and poorly integrated, that
round-tripping between code and model is far too lossy and error
prone, and that tools in general are poor in how they integrate
modelling artefacts into the lifecycle. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">deficits
of UML as, e.g., circular and contradictory definitions...UML which
is a result of tries, failures and successes that were never
theoretically justified.</SPAN></FONT></FONT></FONT></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
formal exploration of those accomplishments appear to be of no
interest to the tool vendors possibly for political reasons.
End-users, on their side, systematically disregard any formal
semantics for UML because of the accompanying intrinsic complexity
and lack of proper (i.e., at industrial scale) support.
Unsurprisingly, the reaction from academia, besides questioning
model-driven development methods for which UML was thought as a
vehicle (see [36,37]), is a shift of focus to other challenges.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">He
had the feeling that striving to give formal meaning to his graphical
formalisms would ruin the whole proposal.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
ppt? </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">On
the one hand, graphical notations are undoubtedly very useful, even
when they are</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">only
informal. They allow us to sketch ideas in early stages of
development, when many details need not be considered. Had those
notations a formal meaning, many of the graphical descriptions would
be actually false at least with respect to details in which nobody is
interested at that stage of development. &nbsp;What is needed is a
robust set of concepts with unambiguous meaning, clearly directed
towards the concepts used in engineering systems. However, this
characterisation does not apply to the UML. In many respects, </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">UML
is far too much triggered by specific concepts of programming like
object-oriented constructs, which are overly close to a explicit
execution model with some express operational meaning. T</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">he
UML sublanguages are not properly related to each other and
integrated. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">for
ppt: If one is interested in a formal modelling language, which
supports the seamless development process including round-trip
engineering and code generation with a great deal of automation by
means of tools, a formal semantics is indispensable. Such a modelling
language is thus close to a high-level design language and also to a
programming language. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">For
that modelling language, all formal semantic questions have to be
solved in order to achieve the essential goal of portability and
independence of particular implementations of tools.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
have understood that designing a full-blown modelling language as an
engineering tool has to be done from foundational principles and not
out of the amalgamation of a number of not completely understood
concepts.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">------------------------------</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">Large-Scale
Formal Verification in Practice: A Process Perspective</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">This
is for project managers; with Isabelle theorem prover [customized]</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Verification
here is: whether the software is consistent with the specification</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Our
analysis of the project is based on complete access to project logs,
meeting notes, and version control data over its entire history,
including its long-term, ongoing maintenance phase. The aim of this
work is to aid understanding of how to successfully run large-scale
formal</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">software
verification projects.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Formal
methods (FM) is the application of mathematical techniques to specify
programs (formal specification) and to prove that programs meet those
specifications (formal verification). The L4.verified project has
performed not just formal specification, but also formal
verification; not just at design level, but down to C source code;
and not just for lightweight properties, but for the full functional
correctness of a highly complex software system—the seL4 .</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
kernel is the part of the OS that runs in the privileged mode of the
hardware. It has direct access to all hardware resources and provides
the basic mechanisms for implementing the rest of the system. A
microkernel, as opposed to more common monolithic OS kernels, is
reduced to the bare minimum of functionality and code. This radical
reduction in size comes with a price in complexity. It is a challenge
to design a formally verifiable kernel while maintaining high
performance. To obtain high performance, kernel developers usually
take a bottom-up approach to design, focusing on low-level details
that allow efficient management of hardware. In contrast, formal
methods practitioners often prefer a top-down approach based on
simple models with a high level of abstraction.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">This
intermediate target is a prototype of the kernel written in the
functional language Haskell. It</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">is
translated automatically into the executable specification of the
kernel in the theorem prover Isabelle/HOL [9]. The prototype can be
used to directly exercise user-level programs that interface with the
kernel and thereby validate the API under development. The importance
of the use of executable specifications in formal verification in a
theorem prover has been recognized previously in the ACL2 community
[10], focussing on microprocessor verification in particular.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">ppt:
The abstract specification is a formal description of the
functionality of the kernel. It specifies the interface and effects
of system calls, but not the details of how these effects are
implemented. In other words it describes what is expected from the
kernel, whereas the executable specification describes how the kernel
will achieve its purpose.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
proof that the executable specification refines the abstract
specification (on the right in Fig. 2) was carried out first. This
proof can be seen as design verification. &nbsp;Then a low-level,
high-performance implementation of the kernel was manually written in
the C programming language. The second proof (on the left in Fig. 2)
shows that this C code correctly implements the executable
specification, which we will also refer to as code verification. Note
that the C code is translated automatically into the theorem prover
for verification </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">------------------------------</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">Verification
of Java Programs Using Symbolic Execution and Invariant Generation</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Technique
for loop invariant generation ← crucial for checking programs that
manipulate unbound data, such as arrays; not so relevant, maybe only
underlined; symbolic execution tree ← figure, nicely shows the
concepts;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">code
instrumentation for model checking with Java PathFinder is
demonstrated with an example;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">conclusions
section says it all; not sure how they prove a property just by
looking at the resulting invariant; examples they give are trivial
methods/algorithms; explains basics of symbolic execution; otherwise
it’s all about invariant generation which is only one of the issues
to be covered for symbolic execution;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
present a novel framework, based on symbolic execution, for the
automated verification of software. The framework uses annotations in
the form of method specifications and loop invariants. ...It allows
for checking universally quantified formulas. Our framework is built
on top of the Java PathFinder model checking toolset and it was used
for the verification of several non-trivial Java programs. ← how
about existential?</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Our
technique for loop invariant generation works backward from the
property to be checked and has three basic ingredients: iterative
invariant strengthening, iterative approximation and refinement.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Loop
invariant generation has received much attention in the literature A
recent paper [13] describes a loop invariant generation method for
Java programs that uses predicate abstraction. The method handles
universally quantified specifications but it relies on user supplied
input predicates. We show (in Section 5) how our iterative technique
discovers invariants for (some of) the examples from [13] without any
user supplied predicates. The main idea behind symbolic execution
[24] is to use symbolic values, instead of actual data, as input
values, and to represent the values of program variables as symbolic
expressions. As a result, the output values computed by a program are
expressed as a function of the input symbolic values.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
state of a symbolically executed program includes the (symbolic)
values of program variables, a path condition (PC) and a program
counter. The path condition is a (quantifier-free) boolean formula
over the symbolic inputs; it accumulates constraints which the inputs
must satisfy in order for an execution to follow the particular
associated path. The program counter defines the next statement to be
executed. A symbolic execution tree characterizes the execution paths
followed during the symbolic execution of a program. The nodes
represent program states and the arcs represent transitions between
states.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Our
symbolic execution framework automates test case generation and
allows model checking concurrent programs that take inputs from
unbounded domains with complex structure. To enable a model checker
to perform symbolic execution, the original program is instrumented
by doing a source to source translation that adds nondeterminism and
support for manipulating formulas that represent path conditions. The
model checker checks the instrumented program using its usual state
space exploration techniques — essentially, the model checker ex-</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">plores
the symbolic execution tree of the program. &nbsp;← usual
state-space exploration techniques; it’s always bounded to some
depth, right? </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Note
that performing (forward) symbolic execution on programs with loops
can explore infinite execution trees. This is why, for systematic
state space exploration, the framework presented in [23] uses depth
first search with iterative deepening or breadth first search. The
framework can be used for test input generation and for finding
counterexamples to safety properties. If there is an upper bound on
the number of times each loop in the program may be executed, the
framework can also be used for proving correctness, since the
corresponding symbolic execution tree is finite. However, for most
programs, no fixed bound on the number of times each loop is executed
exists and the corresponding execution trees are infinite. &nbsp;Our
framework uses the Java PathFinder(JPF) [30] model checker to analyze
the instrumented programs. Since it is built on a JVM, it can handle
all of the language features of Java, but in addition it also treats
nondeterministic choice expressed in annotations of the program being
analyzed — annotations are added to the programs through method
calls </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">As
an illustration of the instrumentation, consider the code from Figure
1. Figure 3 gives part of the resulting code after instrumentation
and Figure 4 gives part of the library classes that we provide. The
generation of loop invariants is an intricate problem We propose to
use a simple, but powerful approximation technique to help
termination.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">If
there is an error in the program, our method is guaranteed to
terminate, reporting the error. However, if the program is correct
with respect to the given property, this iterative method might not
terminate (and the refinement might continue indefinitely).</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Variable
oldPC stores the value of the path condition before the check of the
inductive step; the value of oldPC is used in the approximation phase
for invariant strengthening. Model checking the program using JPF
prints all the path conditions PC (together with oldPC) for the
assertion violations.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">We
have presented a method that extends the framework presented in [23]
with the ability of proving partial-correctness specifications. This
yields a flexible framework for checking Java programs. The general
methodology for using our framework is to first use it as a model
checker, using depth first search with iterative deepening or breadth
first search. ← </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">partial
correctness?</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">If
no errors are found up to a certain depth, then there is some
confidence that the program is correct (with respect to the given
property), and a proof of correctness can be attempted using the
method presented in this section. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Our
current system is not fully automated; although we discover all path
conditions that lead to an assertion violation automatically, we
combine the conditions by hand into a candidate invariant and add it
back to the code to check if it is inductive.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Most
of these methods use techniques that are domain specific. Our method
for invariant generation uniformly treats different kinds of
constraints. Our method could be viewed as an iterative-deepening
search of a sufficient set of constraints that could express an
invariant that is strong enough for verifying the property. Each step
in this search is guaranteed to terminate, but deepening (refinement)
may be non terminating.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">...This
invariant is sufficient to prove the property. … ← manually? how?</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Unlike
[13], our method works backward starting from the property to be
checked and it naturally discovers the necessary constraints over the
program’s variables, through symbolic execution and refinement.
There has been a lot of recent interest in applying model checking to
software. Java PathFinder [30] and VeriSoft [15] operate directly on
a Java, respectively C program. Other projects, such as Bandera [6],
translate Java programs into the input language of verification
tools. Our work would extend such tools with the ability to prove
partial-correctness specifications. &nbsp;The SLAM tool [1] focuses
on checking sequential C code with static data, using well-engineered
predicate abstraction and abstraction refinement tools.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
should note that tools like SLAM perform abstraction on each program
statement, whereas our method performs approximation (which can be
seen as a form of abstraction) only when necessary, at loop headers. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
framework uses annotations in the form of method specifications and
loop invariants. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">We
presented a novel iterative technique for discovering these loop
invariants automatically.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
technique works backward from the property to be checked and it
systematically applies approximation to achieve termination.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
illustrated the applicability of our framework to the verification of
several non-trivial Java programs. Although we made our presentation
in the context of Java programs, JPF, and the Omega library, our
framework can be instantiated with other languages, model checkers
and decision procedures. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">------------------------------</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">--------</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: #ffffff">Assert
and negate revisited: Modal semantics for UML sequence diagrams</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
future work: this paper has several nice figures of
accepting/rejecting automata based on scenarios (well not SDs but
Live Sequence Charts...close enough to be used!!)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">LSC
- multi-modal scenario-based properties: mandatory, possible and
forbiden scenarios.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Assert
and negate in UML for specifying mandatory and forbidden scenarios. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Main
point: assert and negate are </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><SPAN STYLE="background: transparent">modalities</SPAN></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">,
not </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><SPAN STYLE="background: transparent">operators.</SPAN></U></SPAN></FONT></FONT></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">But
are these operators the only problem blocking precise semantics for
UML?</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">they
define </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><SPAN STYLE="background: transparent">modal
interaction fragments</SPAN></U></SPAN></FONT></FONT></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Clearly
explains the problems with assert and negate, by quoting the spec. in
different places</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">constraints
are boolean expressions over attributes associated with participants
in the SD</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">essentially
they try to formally define a visual language sufficient for
expressing the design but also the requirements.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Live
Sequence Charts (LSC) extend Message Sequence Charts (MSC), mainly by
distinguishing possible from necessary behavior. They thus enable the
specification of rich multi-modal scenario-based properties, such as
mandatory, possible and forbidden scenarios. The sequence diagrams of
UML 2.0 enrich those of previous versions of UML by two new
operators, assert and negate, for specifying required and forbidden
behaviors, which appear to have been inspired by LSC. The UML 2.0
semantics of sequence diagrams, however, being based on pairs of
valid and invalid sets of traces, is inadequate, and prevents the new
operators</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">from
being used effectively. We propose an extension of, and a different
semantics for this UML language—Modal Sequence Diagrams (MSD)—
based on the universal/existential modal semantics of LSC.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
particular, in MSD assert and negate are really modalities, not
operators. We define MSD as a UML 2.0 profile, thus paving the way to
apply formal verification, synthesis, and scenario-based execution
techniques from LSC to the mainstream UML standard. While the
language of Message Sequence Charts (MSC), defined by ITU [18] is a
popular means for specifying interactions between objects or
processes, it is expressively weak, being based on a modest semantic
notion of a partial ordering of events. This is true also for most
proposed extensions of MSC, where despite enhancements with regular
expression constructs, the underlying semantics of a partial order
remains intact. Live Sequence Charts (LSC), introduced in [7], extend
MSC by allowing a distinction between possible and necessary
behavior, with, for example, a hot/cold modality for elements within
the charts. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">It
thus enables specification of rich multi-modal scenario-based
properties, such as liveness and safety, using mandatory, possible
and forbidden scenarios.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Since
its introduction in 1998, the LSC language with its formal
(operational) semantics has triggered much research both on the
requirements/specification level and as an executable programming
language for reactive systems.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
Unified Modeling Language (UML) includes a section on sequence
diagrams, which early versions of the standard adopted directly from
MSC UML 2.0 Sequence Diagrams specification is based on a revised
metamodel and has adopted additional important and useful features
from MSC and high-level MSC (HMSC) [18]. These include, for example,
the concept of InteractionUse (originally called MSC reference),
which allows referring to another interaction from within a diagram
(sharing portions of an interaction between several other
interactions), the notion of InteractionFragment, and its operators
for choice, sequential, parallel, and iterative composition.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">However,</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">the
most interesting addition to sequence diagrams in the UML 2.0
standard are two new and crucial operators, assert and negate, which
were probably intended to bring the </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">multi-modal
hot/cold essence of LSC into the new standard,</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">and
to allow the specification of </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">required
and forbidden behaviors, respectively. These two new operators
constitute the main mechanism adopted by the UML 2.0 authors for
increasing the actual expressive power of the language.
Unfortunately, in Sect. 2.3 we show that the semantics suggested in
the UML 2.0 specification document, which is based on pairs of valid
and invalid sets of traces, is inadequate, and does not lead to a
well defined semantics of these new features of the language. The
semantic confusion around the use of assert and negate prevents these
features from being used effectively, since the ability to specify
liveness and safety properties, e.g., via required and forbidden
behaviors, is a fundamental prerequisite for the use of sequence
diagrams in specification, testing and verification, and also, of
course, when executing the language and using it for actual
programming. ← why the most interesting? as property
specifications? liveness / safety? Thus, in this paper we propose
Modal Sequence Diagrams (MSD)2 , which is an extension of UML 2.0
Sequence Diagrams based on the universal/existential distinction that
is at the heart of live sequence charts. MSD allows denoting parts of
an interaction, such as messages and constraints, or a complete
interaction, as universal, i.e., mandatory, thus specifying that
messages have to be sent, conditions must become true, etc.
Technically, we do this by defining modal interaction fragments. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Thus,
assert and negate, we claim, are not to be viewed as operators but as
modalities. Still, we believe our version, MSD, is very close to UML
2.0 Sequence Diagrams as they are described in the standard
documents, yet has stronger expressive power and far more robust
semantics. The fact that MSD is defined as a UML profile makes it
possible to carry over to mainstream UML most of the recent results
and applications worked out for LSC, in formal verification, testing,
synthesis, and scenario-based execution. The LSC language [7] defines
two types of charts: universal (annotated by a solid borderline) and
existential (annotated by a dashed borderline). Universal charts are
used to specify restrictions over all possible system runs. A
universal chart typically contains a prechart that specifies the
scenario which, if successfully executed, forces the system to
satisfy the scenario given in the actual chart body. Existential
charts specify sample interactions between the system and its
environment, and must be satisfied by at least one system run. They
do not force the application to behave in a certain way</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">in
all cases, but rather state that there is at least one set of
circumstances under which a certain behavior occurs. &nbsp;← in OO
systems this is not very natural? Why would you say that some
scenario is mandatory? all the behavior is mandatory and optional at
the same time!!</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
message typically associates two OccurrenceSpecifications,
corresponding to sending and receiving events. CombinedFragment,
consisting of an operator and a number of operands, which may be
either plain interactions or, again, combined fragments. The semantic
domain for UML 2.0 Interactions consists of OccurrenceSpecifications,
which represent moments in time (with no duration) associated with
actions, such as the sending or receiving of a message. A trace is a
sequence of occurrence specifications. According to the standard, the
semantics of an interaction is given as a pair of sets of traces,
representing, respectively, the valid and invalid traces.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
addition to these high-level structural operators, the standard
defines a macro-like mechanism for modularity, using the ref
operator. If we forbid the use of recursive references (which, by the
way, the standard does not refer to at all, so there is no way of
knowing whether they are allowed or not. . . ), the semantics of a
fragment that includes ref is simply the semantics of the fragment
after syntactically substituting the references with copies of the
referenced interactions. We now briefly illustrate the inadequacy and
vagueness of assert and negate as they are defined in the standard
specification document [34]. As to assert, the standard explains that
“the sequences of the operand of the assertion are the only valid
continuations. All other continuations result in an invalid trace”
[34, p. 456]. This suggests that the invalid set of traces for an
asserted fragment is its complement, i.e., the set of all other
possible traces. Later however, the standard declares that “the
invalid set of traces are associated only with the use of a Negative
CombinedFragment”</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">As
to negate, according to the standard, it “designates that the
combined fragment represents traces that are defined to be invalid”
[34, p. 455], so neg seems a reasonable and a natural way to specify
counterexamples. However, “all interaction fragments that are
different from Negative are considered positive meaning that they
describe traces that are valid and should be possible”</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">These
semantic confusions are significant, in that they prevent these
important features from being used effectively. Indeed, assert is
defined in the standard specs but is not mentioned in recent works
such as [11], which discuss liveness in sequence diagrams, nor does
it appear in the popular UML user guide [2]. In fact, no tool seems
to exist which adequately supports a reasonable interpretation of
assert and negate as they are defined in the standard, nor have we
seen any paper with a satisfactory proposal for such an
interpretation. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">As
a basis for the extension, we start off with the so called
existential or positive fragment of UML 2.0 Interactions, i.e.,
without assert and negate. To allow the specification of modalities
over interactions, we define a stereotype modal with a single
attribute interactionMode, which, in the spirit of LSC, can be either
hot (universal) or cold (existential) (see Fig. 3). The new
stereotype is introduced as an extension of the abstract class
InteractionFragment, and hence</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">also
of its subclasses: Interaction, OccurrenceSpecification, and
StateInvariant.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
system-model satisfies an MSD specification if (1) every one of its
possible runs satisfies each universal diagram in the specification,
and (2) every existential diagram is satisfied by at</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">least
one possible system run. To conform to the standard’s notation, we
allow the use of assert in MSD, but we interpret it as syntactic
sugar &nbsp;&nbsp;for assigning a hot mode to all the
OccurrenceSpecifications inside the interaction fragment operand. &nbsp;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">!!
basics for semantics explained in continuation...formulas blabla</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
define the trace-language of a universal MSD using an alternating
weak word automaton (AWW)...</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Still,
the ability to explicitly specify forbidden scenarios is very
important in practice since in many cases, specifically in formal
verification, it is more natural and shorter to specify what should
never happen (a safety property; a counterexample) than to specify
all legal possibilities.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">To
use the standard’s notation, we allow the use of the negate
operator. As in the case of assert, we interpret it as syntactic
sugar for adding a hot constant FALSE constraint immediately after
the last OccurrenceSpecification (actually, all the last ones) in the
InteractionFragment operand;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">This
solution, however, keeps the important liveness requirements within
textual logical formulas outside the visual syntax of the modeling
language. If the extensive use of textual logical formulas outside
the diagrams is necessary, then one could use other appropriately
expressive formalisms (e.g., temporal logic) to specify a system’s
behavior. The challenge we try to meet in our own work is to formally
define a scenario-based specification language that is sufficiently
expressive yet intuitive and visually appealing.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
[11], it is shown how to derive liveness and safety automata from UML
2.0 Sequence Diagrams, but that paper employs a different
interpretation of the standard semantics, with no reference to the
assert operator. Validity is interpreted as “liveness”, as in
“each finite execution should be extendible to an execution where
the positive trace eventually</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">happens”
← find [11] “Safety-Liveness Semantics for UML 2.0 Sequence
Diagrams” </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">STAIRS
[17,30] is a requirements specification methodology based on UML 2.0,
where the semantics of interactions is given using interaction
obligations, which are pairs of sets of traces categorized as
positive and negative. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Roughly,
xalt means “for each operand one of the alternatives must be
possible”.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
STAIRS, a correct implementation “may only produce traces belonging
to the positive and inconclusive trace sets of the obligation, i.e.
no negative trace must be produced by the implementation”. Thus, we
claim that increasing the expressive power of sequence diagrams to
allow liveness and safety specifications requires a universal
interpretation: assert and negate are thus to be considered as
modalities, not as operators. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">←
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">this
means embedding desired properties into the system itself somehow?!</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
this paper we mainly considered synchronous messages and strict
sequencing, and did not explicitly address the semantics and use of
MSD in asynchronous settings. This may also be a topic for future
work.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Our
definition of MSD in the present paper precludes nesting of hot
fragments inside existential diagrams. Indeed, following the stated
justification given in [7], we judge that such nested quantification
is too complex for real world usage of sequence diagrams (in
particular, if hot fragments inside existential diagrams are allowed,
a single system run may no longer suffice to ensure the
satisfiability of an existential diagram). In addition, given the
fact that MSD is defined as a UML profile, our work paves the way to
apply recent work on LSC in formal verification [8,19,31,36] to the
UML. As a first step, one can formalize and implement a translation
from MSD to Temporal Logic, similar to the one suggested for LSC in
[22].</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">Automated
Formalisation for Verification of Diagrammatic Models</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">bullshit
mostly?</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">underlined
useful for ppt. Just intro, rest is BS. Just class and state machine
diagrams? experts create templates with EGL and FTL languages?? FTL
templates as model-transformation mappings? it’s like a meta-model
for defining transformation templates and meta-theorems.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
ppt:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">There
are challenges in applying formal analysis to these approaches,
either because the semantics is inadequately defined, or because the
level of detail of the semantics does not admit interesting or useful
formal analysis. Conversely, the formal notations used in
verification of critical systems and in academia are considered
inaccessible by many practical engineers. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">However,
few integrations have found favour, either because formalisation does
not meet engineeringneeds, or because engineers are exposed to the
formalisation and formal model.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">bringing
formalisms into practical engineering ← title for thesis?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Am
́lio demonstrates an instance of GeFoRME called UML+Z, comprising a
library of templates that capture the object semantics of UML.
Instantiating the templates with details from UML diagrams results in
a Z model that conforms to Am ́lio’s object-oriented (OO) Z
structuring, ZOO [4,7,3,10]. UML+Z has been used on small case
studies [3,9] of conventional object-oriented models including UML
class and state diagrams and Catalysis ...and traceability between</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">the
formal and diagrammatic models... ← for ppt, I have this </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
all the work with UML+Z, however, a major inhibiting factor is the
lack of tool support for management and instantiation of templates. ←
for ppt!!</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">model-driven
development (MDD) – the family of approaches to tool-supported
practical software development that focuses on the construction and
manipulation of primarily-diagrammatic models [29]. As in formal
translation, MDD model transformation defines a mapping from a source
model to a target model [11]. The mapping, or transformation defi-</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">nition,
comprises transformation rules which specify how each modelling
construct is transformed. In transforming diagrammatic models to
formal models, we apply a model-to-text (as opposed to
model-to-model) transformation. Model-to-text transformation is most
commonly used for code generation ← mapping a set of transformation
rules which specify how each modeling construct is transformed. Does
Z notation cover dynamic aspects? doesn’t seem to!</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">He
notes the need to model concepts that cannot be expressed
diagrammatically – constraints and model properties – and
considers the general problem of semantics.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">In
most cases, the semantics is clarified only when a diagrammatic model
is converted to code – thus, a class diagram that forms the basis
for a Java program assumes a Java semantics, but the same diagram
used to create a C++ program assumes a C++ semantics. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">In
practice, little attention is paid to consistency across model-views
or between diagrams and constraint expressions. ← for ppt: we take
consistency as assumption</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Most
attempts to associate formal semantics to diagrammatic modelling
assign a specific formal meaning to each diagrammatic concept. Whilst
this significantly reduces ambiguity, and admits formal analysis, the
formalisation assumes a single, fixed semantics for each concept [9]
– and the semantics that is assumed is often only apparent to the
formalist. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">By
contrast, Amalio’s approachs advocate a framework for rigorous, but
practical MDD [9]; concept semantics are captured explicitly in the
templates, so a different semantics simply requires use of a
different set of templates...allows the formalism to be completely
hidden from the developer.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Am
́lio devised the Formal Template Language (FTL) [3,8] as the
rigorous underpinning to the GeFoRME framework The tool needs to
catalogue the existing UML+Z templates efficiently and support the
addition of new templates and meta-proofs: there is potential to
extend the existing UML+Z templates with a wide range of alternative
concept semantics.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
AUtoZ tool is a framework on which different instance tools can be
built. The two instances that currently exist are AUtoCADiZ and
AUtoZ/Eves. AUtoZ is a plug-in for the Eclipse development
environment, which is used as the basis for many modelling and
model-management activities in software engineering. ← meta tool,
so! :P</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Common
MDD diagramming tools provide serialised XMI output, and are
underpinned by a metamodel that defines the abstract syntax
(concepts) of the notation. This allows concepts and their labels to
be automatically extracted from diagrams, to instantiate the FTL
templates. Here, we use the existing Eclipse modelling plug-in, UML2
(www.eclipse.org/uml2/), since it supports UML 2.x modelling, uses a
standard metamodel-based approach to abstract syntax, and sits within
the Eclipse development environment. However, in principle AUtoZ
could use XMI output from many other modelling tools. ← ppt?</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">FTL
templates as model transformation mappings EGL, the Epsilon
Generation Language, supports model-to-text transformation. An EGL
run configuration specifies a file containing the XMI source model,
and a file containing EGL transformation rules to be executed on the
source model, as described in [26] ← check? no, it’s template
based, no thanks, works well for static aspects! </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
AUtoZ Eclipse plug-in is a customised EGL run configuration that
executes the transformations on a UML2 XMI source model to generate Z
L TEX markup, which is then input directly to the formal support tool
for analysis. Figure 4 summarises the workflow of AUtoZ. A developer
provides the UML model; the tool calls an AUtoZ run configuration
file; Eclipse plug-ins convert UML to Z L TEX via EGL, and call the
relevant Z tool. The result of the formal analysis is returned to the
user.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">This
is necessary to support the basic user, a developer who is
well-versed in diagrammatic modelling but has little interest in
formal methods. ← for ppt</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
expert user needs to be familiar with formal methods and able to
interact directly with formal</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">notations
and tools, in order to develop new FTL templates and meta-theorems
and to write and edit EGL transformation rules corresponding to the
FTL templates</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">An
expert user needs some understanding of the template languages (EGL,
FTL), and the formalisation process. FTL maps readily on to EGL, and
we note that an expert user involved in template maintenance would
need to be familiar with both languages. FTL is also needed for
meta-theorems and proof work, because of its formal underpinnings</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">Transformation
and Verification of Executable UML Models (2004)</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Compositional
Temporal Logic of Actions = CTLA formal specification language</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">check
this → improvement in UML2 → Action Semantics → a metamodel for
action-based description language ← read it</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">I
don’t see any human-readable traces from their case study,
everything is blabla</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">and
how is this verification done? long paragraphs with proofs...</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
formal specification technique compositional Temporal Logic of
Actions (cTLA) provides for modular descriptions of behavior
constraints and its process composition operation corresponds to
superposition. Furthermore, cTLA facilitates the selection of an
arbitrary subsystem of a complex specification which is composed of
processes. &nbsp;In a first step of the verification, the abstract
and the detailed model are transformed to cTLA specifications.
Thereafter, we can prove that the cTLA specification of the more
detailed</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">model
implies the cTLA description of the more abstract one by application
of the model checker TLC (Temporal Logic Checker).</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">advantage
of model checker application to the frameworks is that the proofs can
be performed in a </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">highly
automated</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
←</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">(
for ppt) fashion. Since UML-based system descriptions tend to
describe systems in a relatively abstract manner, we expect that the
modeled state space of many real-life systems can be handled by a
model checker. Therefore we decided to apply the powerful checker TLC
(Temporal Logic Checker) [24,33], to perform the refinement proofs.
Tools for the transformation of UML specifications into cTLA [9,11]
and of cTLA specifications into TLA [19] exist. The transformation
utilizes the compositional features of cTLA extensively since a UML
diagram can be transformed into a separate cTLA process. Our approach
complements a lot of other approaches formalizing UML diagrams by
formal models (cf. [25,28,30,31]) which, however, do not use
compositionality in the way explained in this paper. We adapted our
formalization to the upcoming UML 2.0 standard since the improved
action semantics (which was introduced in UML 1.5) and the
compositional aspects of sequence diagrams facilitate the
transformation into cTLA processes. Based on these new semantical
features we redefined our transformation rules from UML diagrams to
cTLA processes fostering the generation of very compositional cTLA
system descriptions which facilitate the carrying out of suitable
refinement proofs by means of the model checker TLC. In order to stay
within the boundaries of this paper, we had to restrict ourselves
into sketching the process of transforming a UML model into the
corresponding cTLA processes and to verify some example properties.
In UML 2.0, transitions can be provided with a statement containing
an event name, a guard condition, and an activity identifier. By the
event name it is possible to specify a UML change event, call event,
send event or completion event. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Furthermore,
one can allow the deferral of events. If an event cannot be processed
in the current state, it is stored in an event queue and can be used
later. &nbsp;One can define so-called composite states from substates
which can contain substates as well. A composite state can be a
nested state corresponding to the OR-States in a statechart diagram.
If an incoming transition of the nested state is fired, exactly one
of its substates gets active. The other kind of a composite is a
concurrent state which corresponds to an</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">AND-state
in a statechart diagram. Here, the substates carry out transitions
concurrently. In UML 2.0, sequence diagrams are strongly influenced
by the current Message Sequence Chart (MSC) standard </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
occurrence of messages is described by the aid of traces. A trace
consists of sequences of event occurrences &lt; E1 , E2 . . . , En &gt;.
In UML 2.0, it is possible to incorporate traces of foreign sequence
diagrams into another diagram using the keyword ref and an identifier
which refers to another sequence diagram. Moreover, one can compose
sequence diagrams from other diagrams by application of so-called
CombinedFragments. A CombinedFragment may contain so called
InteractionOperands. That are special regions in the diagram where
events may occur in arbitrary orders defining a set of alternate
traces. In the following, we will introduce two of the currently 11
defined InteractionOperators:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">seq</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">:
This InteractionOperator determines that the CombinedFragment
provides a weak sequencing of the behavior of its
InteractionOperands. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Weak
sequencing</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">is
defined on a set of traces which fulfill the following three
properties. Firstly, the order of event occurrences of each
InteractionOperand &nbsp;&nbsp;is preserved in the result. Secondly,
event occurrences on different lifelines which stem from different
InteractionOperands may occur in an arbitrary order. Thirdly, the
event occurrences on the same lifeline stemming from different
InteractionOperands are sequenced with respect to the order of these
InteractionOperands.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">strict</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">:
The strict InteractionOperator implies that a CombinedFragment has </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">a
strict order</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">of
the event occurrences belonging to each InteractionOperand. The
strict sequencing, however, is only enforced on the uppermost level
of CombinedFragment with the operator strict. Thus, if the strict
CombinedFragment A contains another combined fragment B, the event
occurrences of B will not be directly compared with those of A.
Another major improvement of UML 2.0 is the new Action Semantics
defining a meta-model for action based description languages [32]. In
contrast to the traditional Object Constraint Language (OCL) it
facilitates the description of dynamic behavior enabling the
generation of implementation code from UML models. Actions are the
fundamental units of executable functionality. The Action Semantics
does not define a particular syntax for action statements but more
abstract class definitions which can be realized by applying various
different syntaxes. Two actions exchange data and object information
via special input and output pins. ← </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">check
this! I have mCRL2 which is also action-based; exactly like explained
here</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Invocation
Actions are used to perform operation calls and transmission of
signals between objects. A relevant derived action is the so called
CallOperationAction which transmits an operation call request to a
target object where it invokes an associate behavior. The operation
call is completed by a reply transmission which is performed by a
ReplyAction/ So called Object actions are responsible for the
creation and destruction of objects. &nbsp;← for ppt: </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">these
UML events I do not handle, but can be added</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">!!!!
FOR PPT:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Systems
and subsystems are described as compositions of concurrent processes.
As in the ISO/OSI specification language LOTOS [20], a set of
processes interact in a rendezvous-like way by performing actions
jointly, and the data parameters of the actions can model the
communication of values between processes. Each process encapsulates
its variables and changes its state by atomic execution of its
actions. The system state is the vector of the process state
variables. State transitions of the system correspond to
simultaneously executed process actions or to so-called process
stuttering steps (i.e., the process does not change its state). &nbsp;The
basic idea is to create a separate cTLA process for the state machine
of each UML class.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt structure random thoughts:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">&gt;
Why Sequence Diagrams?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">-
state machines are easier?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">-
but these are closest to actual code</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">In
the UML2.0, an activity is modelled by a kind of Petri Net. Since a
Petri Net corresponds with a state transition system, it can be
transformed relatively easily to corresponding cTLA variables and
actions. ← for ppt: activity diagrams are easily transformed into
state transition system </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Read
and Write Actions as well as Computation actions have only local
scope whereas invocation actions have access to other objects. For
each UML action with local scope it is sufficient to introduce a new
cTLA action transforming the semantics of the UML action and
describing its access to its input and output pins as well as its
incoming and outgoing control edges. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">CreateObjectActions
and DestroyObjectActions are supported by cTLA actions that change
the value of the state variable lifecycle if the creation and
destruction of objects is handled in the corresponding UML model. ←
for paper: how to implement create/destroy actions: object will have
a property lifecycle: dead or alive</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Invocation
actions have to reflect that they are coupled with other actions in a
peer object. In consequence, the corresponding cTLA action will be
coupled with another action in a different process modelling the peer
behavior. The two linked process actions have to carry identical
action parameters modelling the arguments of the operation call. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">PPT
(same with my approach):</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">In
the UML, however, an incoming reply transmission is accepted by the
same CallOperationAction which also triggered the initial call. Since
this non-atomic behavior cannot be specified by a single cTLA action,
we describe CallOperationActions by two cTLA actions modelling the
execution of an operation call resp. the acceptance of the reply
transmission. In the process Adapter the actions callControl and
callControlReply are both used to model a single CallOperationAction.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
the UML, sequence diagrams are used to describe the interaction of
objects. Thus, they form a link between the state chart diagrams
describing the (</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">individual!)
</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">behavior
of the objects.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">now
comes the fuzzy case study part:...</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Thus,
we have to prove that the call event passes the proxy and the adapter
in a lively manner and will be eventually enqueued in the message
queue of the detailed sensor object enabling the action
sensorDequeueCall. We have to find a sequence of system states which
are passed in the transmission process of the call event. &lt;- what
da fuck?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">UML
Automatic Verification Tool with Formal Methods (2005!!)</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Figure
1: tool overview useful</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">they
use SMs and ADs (good explanation of their relationship!) and
translate them to SMV model checker algebra. But no formulas or heavy
formalisation etc...;</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
property specification they take the 1999 paper as a starting point,
so they made a tool/wizard assistant with catalogue to choose; the
user does not need to understand the structure of the specification
to carry out verification.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">tja,
they claim everything is automated, but counterexample traces are not
in the UML domain</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
tool uses SMV [10] (Symbolic Model Verifier) like formal
specification, as it has the adequate characteristics for
representing the active behaviour of a specification in UML. The main
reason for this is that it is based on labeled transition systems and
because it allows the user’s own defined data types to be used,
thus facilitating the definition of variables. It also uses symbolic
model checking for the verification, which means that the test is
automatic, always obtains an answer and more importantly, should the
property not be satisfied generates a means of identifying the
originating error. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Focus
is mainly on reactive systems in which the active behaviour of the
classes is represented through state diagrams, while activity
diagrams are used to reflect the behaviour of class operations. &nbsp;←
the whole point of using them; for ppt mention why!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Three
kinds of diagram are taken into account when transforming the active
behaviour from UML into SMV: class, state and activity diagrams. The
first provides information concerning the elements that make up the
system and their relationships, while the second and third provide
information about the behaviour, through time, of each of those
elements.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">An
additional class called environment also has to be included. It has
no associated behaviour and contains details of the signals produced
outside the system and which are input signals. ← for ppt</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
addition, the fact that combined states, both sequential and
concurrent, may appear within a machine means that additional
variables are needed in order to deal with the submachines. These
will be dealt with following the same reasoning as for the main
machine, with the exception of the peculiarities they possess with
respect to activation and deactivation. The evolution of an active
object can lead to different actions, including sending signals and
modifying the value of class attributes.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">They
show below how SMs and ADs are related.cool.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Fundamentally,
show the control flow between activities. Its SMV specification can
be found in the module that reflects class behaviour. These activity
diagrams are activated whenever a call to an activity is produced
within a state using the notation do / &lt;activity&gt;.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Activity
diagrams can be considered as a special case of state diagrams where
the majority of states are activity states and most transitions are
fired by termination. So the mechanism used to represent them is
similar to that used for state machines. The only difference is that,
for concurrent evolution, the special states of division and union
(fork and join) are used. They are activated whenever any state which
has a call to this activity inside it is activated. Likewise, they
are deactivated whenever a transition is produced that deactivates
the state in which it is contained.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
our tool, verification is carried out using the SMV tool model
checker. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
property must be expressed in a temporal logic present in SMV 7 , CTL
(Computation Tree Logic) or LTL (Linear Temporal Logic). This
property writing is not a trivial problem. To write them correctly,
advanced knowledge of logics and the type of specification obtained
from the system is necessary. Our tool overcomes this problem as it
has an assistant that guides the user through the writing of
properties until the property to be verified is finally obtained
following the appropriate syntax. Our starting point was the pattern
classification proposed by Dwyer et al. [4] to which our own
cataloguing of the different properties to be automatically verified
has been added. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Property
patterns</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
property writing assistant is based on the pattern scheme proposed by
Dwyer et al [4] where it is established a first classification
between patterns of occurrence and order. Most of the properties of a
system to be verified in practice, fit in with one of these two
categories.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Occurrence</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">patterns
describe properties with respect to the occurrence of a state or
signal during the evolution of a system. These include absence
(never), universality (always), existence (sometimes) and bounded
existence (appearing a certain number of times). </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Order</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">patterns
establish properties with respect to the order in which they occur.
They include: precedence (s precedes p), response (s responds to p),
and combinations of both: chain precedence (s and t precede p or p
precedes s and t), chain response (s and t respond to p or p responds
to s and t), and constrain chain (s and t without z respond to p). </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">On
the other hand, each kind of pattern has a </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">scope</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">of
application which indicates the system execution on which it must be
verified. There are five basic scopes: Global (the entire program
execution), Before R (the execution up to a given property), After Q
(the execution after a given property), Between Q and R (any part of
the execution from a given property to another given property) and
after Q until R (like between but the designated part of the
execution continues even if the second property does not occur).
Figure 7 illustrates the portion of an execution that are designated
by the different kinds of scopes.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Most
works dealing with UML verification using formal method techniques
focus on state diagram verification. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
tools developed for verifying UML system specifications can be
classified according to the formal language used:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Promela:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">vUML
[9,13]. vUML is a tool for the automatic verification of UML &nbsp;models,
focusing on state diagrams. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">HUGO
[14,7]. This project includes a set of tools to apply model checking
to UML state diagrams and collaborating ones. The latter are used to
check whether the interaction represented in the collaboration
diagram can be performed using state machines. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Most
works do not carry out an automatic verification and vUML [9,13],
which does, does not use the potential of temporal logic,
implementing a limited verification based on checking that it is
impossible to reach error states. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">These
error states are introduced by the user in the diagrams, so the
diagrams are more complicated</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">.
← for future work: oh, so it’s limiting to check for reachability
error-states with monitors! think about: how many of the categories
can be expressed with an automaton? But in this case the error states
must be introduced by the user, in our case it is transparent.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">Applying
Software Model Checking Techniques for Behavioral UML Models</SPAN></I></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
translate UML to verifiable C code which preserves the high level
structure of the models, and abstracts details that are not needed
for verification. We combine of static analysis and bounded model
checking for verifying LTL safety properties and absence of
livelocks.We implemented our approach on top of the bounded software
model checker CBMC. We compared it to an IBM research tool that
verifies UML models via a translation to IBM’s hardware model
checker RuleBasePE. Our experiments show that our approach is more
scalable and more robust for finding long counterexamples. We also
demonstrate the usefulness of several optimizations that we
introduced into our tool.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt: Model checking [6] is a successful automated verification
technique for checking whether a given system satisfies a desired
property. Model checking traverses all system behaviors, and either
confirms that the system is correct w.r.t. the checked property, or
provides a counterexample demonstrating an erroneous behavior. Model
checking tools expect the checked system to be presented in an
appropriate description language. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Our
translation indeed preserves the high-level structure of the UML
system: event-driven objects communicate with each other via an event
queue. An execution consists of a sequence of Run To Completion (RTC)
steps. Each RTC step is initiated by the event queue by sending an
event to its target object, which in turn executes a maximal series
of enabled transitions. Model checking assumes a finite-state
representation of the system in order to guarantee termination with a
definite result. One approach for obtaining finiteness is to bound
the length of the traversed executions by an iteratively increased
bound. This is called Bounded Model Checking (BMC) [3]. BMC is highly
scalable, and widely used, and is particularly suitable for bug
hunting. We find this approach most suitable for UML models, which
are inherently infinite due to the unbound size of the event queue.
We emphasize that our goal is to translate the UML model into
verifiable C code that suits model checking, rather than produce
executable code. &nbsp;Recall that the verifiable C code will be
checked by BMC with some bound k. We choose k to count the number of
RTC steps. This implies that along an execution of size k only the
first k events in the queue are consumed, even if more were produced.
It is therefore sufficient to hold an event queue of size k. We thus
obtain a finite-state model without losing any precision. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">We
verify two types of properties: LTL safety properties and livelocks.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Safety
properties require that the system never arrives at bad states, such
as deadlock states, states violating mutual exclusion, or states from
which the execution can continue nondeterministically. LTL safety
properties can further require that no undesired finite execution
occurs. Checking (LTL) safety properties can be reduced to traversing
the reachable states of the system while searching for bad states. We
apply Bounded reachability with increasing bounds for finding bad
states. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Another
interesting type of properties is the absence of livelocks. Livelocks
are a generalization of deadlocks. While in deadlock states the full
system cannot progress, in livelock states part of the system is
“stuck” forever while other parts continue to run. Livelocks can
be hazardous in safety critical systems and often indicate a faulty
design. Scalable bounded model checking tools mostly handle safety or
linear-time properties. However, absence of livelocks is neither
safety nor linear-time property and is therefore not amenable to
bounded model checking. We identify an important subclass of
livelocks, which we refer to as cycle-livelocks, and show that they
can be found by combining static analysis and bounded reachability.
To the best of our knowledge, absence of livelocks has never been
verified in the context of behavioral UML models. We implemented our
approach to verifying UML models with respect to LTL safety
properties and cycle-livelocks in a tool called soft-UMC
(software-based UML Model Checking). Our tool is built on top of the
software model checker CBMC [8] which applies BMC to C programs and
safety properties. We ran it on several UML examples and interesting
properties, and found erroneous behaviors and livelocks. For safety
properties, we also compared soft-UMC with an IBM research tool that
verifies UML models via a translation to IBM’s haprdware model
checker RuleBasePE [24]. Our experiments show that soft-UMC is more
scalable and more robust for finding long counterexamples.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Our
experimental results also demonstrate the usefulness of the
optimizations applied in the creation of the verifiable C code.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">UML
objects process events. Event processing is defined by statecharts
[13], which extend conventional state machines with hierarchy,
concurrency and communication. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Objects
communicate by sending events (asynchronous messages). ← wha? they
communicate also with synchronous messages! But I guess this is fit
for a different purpose</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Events
are kept in an event queue (EQ), managed by an event queue manager
(EQ-mgr). When object A sends an event to object B, the event is
inserted into the EQ. The EQ-mgr executes a never-ending event-loop,
taking an event from the EQ, and dispatching it to the target object.
If the target object cannot process the event, the event is
discarded. Otherwise, the event is consumed and the target object
makes a run-to-completion (RTC) step, where it processes the event,
and continues execution until it cannot continue anymore. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">We
also place restrictions on the action language and disallow dynamic
allocation of objects and memory, dynamic pointers, unbounded loops,
and recursion. ← I also place a restriction on recursion! </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
Kripke structure is a tuple M = (S, I0 , R), where S is a set of
states, I0 ⊆ S is a set of initial states, and R ⊆ S × S is a
total transition relation. An execution of M is an infinite set of
states s0 , s1 , ... s.t. for every i ≥ 0, (si , si+1 ) ∈ R. &nbsp;The
Linear-time Temporal Logic (LTL) [21] is suitable for expressing
properties of a system along an execution path. We assume the reader
is familiar with LTL. In this work we restrict ourselves to a
fragment of LTL, in which only safety properties are expressible. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">These
are properties whose </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">violation
occurs along a finite execution</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
← </SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">for
meeting and future work: could this be the problem? That with some
properties the violation occurs along an infinite execution trace?
(livelocks?) And this cannot be captured with a monitoring automaton.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
general method for on-the-fly verification of LTL safety properties
is based on a construction of a regular automatonA¬ψ , which
accepts exactly all the executions that violate ψ. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Bounded
Model Checking (BMC) [3] is an iterative process for checking models
against LTL formulas. The transition relations for a Kripke structure
M and its specification are jointly unwound for k steps and are
represented by a boolean formula that is satisfiable iff there exists
an execution of M of length k that violates the specification. The
formula is then checked by a SAT solver. If the formula is
satisfiable, a counterexample is extracted from the output of the SAT
procedure. Otherwise, k is increased. The atomic unit in our
translation is a single RTC step, rather than a single transition.
(Run To Completion). The EQ is represented as a bounded array. The
main method of the program executes the never-ending loop of taking
an event from the EQ, and dispatching it to the relevant target
object. C code can be automatically generated by UML tools such as
Rhapsody, but this code would not be suitable for verification. We,
on the other hand, are interested in verifying only the user-created
behavior of the system, and therefore we can abstract the event queue
and the operating system. A behavioral UML model M can be viewed as a
Kripke structure M = (S, I0 , R), where S is the set of all possible
CONFs in M. R can be defined either at the RTC level (denoted RRT C )
or at the transition level (denoted Rt ). </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">We
now show how to verify safety LTL properties over behavioral UML
models using an automata based approach. We assume the atomic
propositions of the property are predicates over the CONFs of the
model. We extend the C program created from M with a method
representing the automaton A¬ψ . </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
method runs in lock step with the system, and identifies property
violations. ← for ppt: monitoring automaton </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">A
Livelock describes the case where part of the system cannot progress,
even though the other parts of the system do. In this section we
focus on finding livelocks in behavioral UML models. As mentioned
before, absence of livelocks in neither safety nor LTL property and
therefore cannot be handled by scalable bounded model checking tools.
For that reason, we identify a subclass of livelocks, and present a
method for finding </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">such
livelocks within our framework. This is done by a reduction to a
safety property, which requires a preceding syntactic analysis of the
UML </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">model.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Following,
we present a characterization for a subclass of livelock CONFs, which
we call </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">cycle-livelocks.
Intuitively, a CONF C is a cycle-livelock if there is a subset of
objects that are stuck at C, and for every object o in the subset all
of the producers of events that o is stuck on, and all of the
modifiers of the guards that o is stuckon, are in the subset as well.
his is because all objects that may “release” a stck object by
producing an event or changing a guard are in the same set. That is,
they are stuck as well. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">There
is one subtle point that still needs to be solved: We need a finite
epresentation of the queue. Recall that for verifying safety
properties, for k-bounded executions we bound the queue to k.
However, when searching for cycle-livelocks this is incorrect because
a configuration is cycle-livelock if there are </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">no
future</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">executions
that can release the stuck states. Thus, we must keep track of all
events inserted into the queue (within k RTC steps). </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
have implemented the algorithm described above in a tool called
Soft-UMC (software-based UML Model Checking). The implementation
reads a UML (version 2.0) model, and translates it to verifiable C
code. Static analysis is applied at this stage, according to the type
of property to be checked: (LTL) safety or livelock. We then apply
CBMC[8] (version 4.1) as our C verifier. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Our
approach to finding cycle-livelocks in UML models is novel. Static
analysis identifies syntactically potential cycle-livelock states. A
suitable finite representation of the event queue then enables to
apply BMC for finding reachable such states. We expect similar
approaches to be useful for proving additional non-safety properties.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">From
Interaction Overview Diagrams to Temporal Logic</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
this paper, we use UML Interaction Overview Diagrams as the basis for
a user-friendly, intuitive, modeling notation that is well-suited for
the design of complex, heterogeneous, embedded systems developed by
domain experts with little background on modeling software-based
systems. To allow designers to precisely analyze models written with
this notation, we provide (part of) it with a formal semantics based
on temporal logic, upon which a fully automated, tool supported,
verification technique is built. The modeling and verification
technique is presented and discussed through the aid of an example
system. Modeling-verification-code generation are three pillars in
the model driven development </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">of
complex embedded systems; they are most effective when (i) modeling
is based on user-friendly, intuitive, yet precise notations that can
be used with ease by experts of domains other than computer science;
(ii) rigorous, possibly formal, verification can be carried out on
the aforementioned models, though in a way that is hidden from the
system developer as much as possible; (iii) executable code can be
seamlessly produced from verified models, to generate implementations
that are correct by construction.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
plan is to exploit both “conventional” UML diagrams [15] and a
subset of the MARTE (Modeling and Analysis of Real-Time and Embedded
systems) UML profile [14]. We want to use Class Diagrams to define
the key components of the system. State Diagrams to model their
internal behaviors, and Sequence and Interaction Overview Diagrams to
model the interactions and cooperations among the different elements.
These diagrams will be augmented with clocks and resources taken from
MARTE. The result is a multi-faceted model of the system,
automatically translated into temporal logic to verify it. Temporal
Logic helps glue the different views, create a single, consistent
representation of the system, discover inconsistencies among the
different aspects, and formally verify some global properties.</SPAN></FONT></FONT></FONT></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">This
paper starts from Interaction Overview Diagrams (IODs) since they are
often neglected, but they provide an interesting means to integrate
Sequence Diagrams (SDs) and define coherent and complex evolutions of
the system of interest. IODs are ascribed a formal semantics, based
on temporal logic, upon which a fully automated, tool supported,
verification technique is built.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
choice of IODs as the starting point for a modeling notation that is
accessible to experts of different domains, especially those other
than software engineering, is borne from the observation that, in the
industrial practice, SDs are often the preferred notation of system
engineers to describe components’ behaviors [3]. However, SDs taken
in isolation are not enough to provide a complete picture of the
interactions among the various components of a complex system; hence,
system designers must be given mechanisms to combine different SDs
into richer descriptions, which is precisely what IODs offer.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">In
this article we provide a preliminary formal semantics of IODs based
on metric temporal logic. While this semantics is not yet complete,
as it does not cover all possible mechanisms through which SDs can be
combined into IODs, it is nonetheless a significant first step in
this direction. The provided semantics has been implemented into the
Zot bounded satisfiability/model checker [16]2, and has been used to
prove some properties of an example system. ← this Zot model
checker has two commiters in repository, it’s an italian project.
Blah.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">SDs
have been considerably revised and extended in UML2 to improve their
expressiveness and their structure. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">IODs
are new in UML2.</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">They
allow a designer to provide a high-level view of the possible
interactions in a system. IODs constitute a high-level structuring
mechanism that is used to compose sce</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">narios
through mechanisms such as sequence, iteration, concurrency or
choice. IODs are a special and restricted kind of UML Activity
Diagrams (ADs) where nodes are interactions or interaction uses, and
edges indicate the flow or order in which these interactions occur.</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Semantically,
however, IODs are more complex compared to ADs and they may have
different interpretations.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
control flow is a directed connection (flow) between two SDs (e.g.,
between diagrams delegateSMS and downloadSMS in Figure 2). As soon as
the SD at the source of the flow is finished, it presents a token to
the SD at the end of the flow. A fork node is a control node that has
a single incoming flow and two or more outgoing flows. Incoming
tokens are offered to all outgoing flows (edges). The outgoing flows
can be guarded, which gives them a mechanism to accept or reject a
token. In the IOD of Figure 2, there is one fork node at the top of
the diagram (between the initial node and SDs waitingCall and
checkingSMS ) modeling two concurrent execution of the system. The
dual operator is the join node, which synchronizes a number of
incoming flows into a single outgoing flow. Each (and every) incoming
control flow must present a control token to the join node before the
node can offer a single token to the outgoing flow. A decision node
is a control node that has one incoming flow and two or more outgoing
flows. In the IOD of Figure 2 there are four decision operators
(e.g., the one between SDs waitingCall and delegateCall ) with their
corresponding Boolean conditions. Conversely, a merge node is a type
of control node that has two or more incoming flows and a single
outgoing flow.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">TRIO
[7] is a general-purpose formal specification language suitable for
describing complex real-time systems, including distributed ones.
TRIO is a first-order linear temporal logic that supports a metric on
time. The TRIO specification of a system includes a set of basic
items, such as </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">predicates,
representing the elementary modeled phenomena. The system behavior
over time is formally specified by a set of TRIO formulae, which
state how the items are constrained and how </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">they
vary in time, in a purely descriptive (or </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">declarative</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">)
fashion. ← uhm, a set of formulae for describing system behavior?
Not convenient! ← declarative vs procedural</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
goal of the verification phase is to ensure that the system S
satisfies some desired property R, that is, that S |= R. In the TRIO
approach </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">S
and R are both expressed as logic formulae ← OY OY OY</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
formalization is organized into sets of formulae, each of them
corresponding to one of the SDs appearing in the IOD.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">They
assume total ordering of messages and blabla bullshit; But important
to take away is that Interaction Overview Diagrams are maybe useful,
rather than using a combo of Interactions and Activity Diagrams.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Finally,
if n is the number of occurrences of invocations involving object A,
in the IOD, formula (25) states that all executions involving A are
mutually exclusive. ← </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">BIGGEST
TRAP, DOES NOT HOLD IN DISTRIBUTED SETTING! ← maybe quote it for
ppt ? As an example of the faulty reasonings.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
property checks all seem to be in the format cause=&gt;effect.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">There
is no state space generation since it’s deduction formulas. Not
very useful.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
measure the complexity of the translation in terms of the number of
predicates and the size of the TRIO formulas that are produced </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 114%"><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">“</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Finally,
since every object is blocked while sending or receiving a message,
in every SD” &nbsp;← for ppt cite this as well!? Misconception.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Finally,
since every object is blocked while sending or receiving a message,
in every SD every execution occurrence cannot be true at the same
time instant as another execution occurrence. This can only happen if
the execution occurrences are inside diagrams that can be executed in
parallel (because of fork operators). ← okay they do mention it
here ...</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Many
works focus on the separate formalization of sequence diagrams and
activity diagrams. St ̈rrle analyzes the semantics of these diagrams
and proposes an approach to their formalization [18]. More recently,
Staines formalizes UML2 activity diagrams using Petri nets and
proposes a technique to achieve this transformation [17]. Also, Lam
formalizes the execution of activity diagrams using the π −
Calculus, thus providing them with a sound theoretical foundation
[13]. Finally, Eshuis focuses on activity diagrams, and defines a
technique to translate them into finite state machines that can be
automatically verified.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Other
works investigate UML2 interaction diagrams. Cengarle and Knapp in
[6] provide an operational semantics to UML 2 interactions, and in
[5] they address the lack of UML interactions to explicitly describe
variability and propose extensions equipped with a denotational
semantics. Knapp and Wuttke translate UML2 interactions into automata
and then verify that the proposed design meets the requirements
stated in the scenarios by using model checking. ← I have the
paper, it’s “Model checking of UML 2.0 interactions”</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">When
multiple scenarios come into play, like in IODs, there is the problem
of finding a common semantics. Uchitel and Kramer in [19] propose an
MSC-based language with a semantics defined in terms of labeled
transition systems and parallel composition, which is translated into
Finite Sequential Processes that can be model-checked and animated.
Harel and Kugler in [10] use Live Sequence Charts (LCSs) to model
multiple scenarios, and to analyze satisfiability and synthesis
issues. To the best of our knowledge very little attention has been
paid to IODs. Kloul and K ̈ster-Filipe [11] show how to model
mobility using IODs and propose a formal semantics to the latter by
translating them into the stochastic process algebra PEPA nets.
Tebibel uses hierarchical colored Petri nets to define a formal
semantics for IODs [4]. Our work is quite different, because it uses
metric temporal logic to define the semantics of IODs; as briefly
discussed in Sections 1 and 6, this opens many possibilities as far
as the range of properties that can be expressed and analyzed for the
system is concerned.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">They
don’t show InteractionFragments at all.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">A
Logic-based Semantics for the Verification of Multi-diagram UML
Models &gt; Same authors as above, with this italian Zot model
checker where the system is translated in a set of formulas. B.S.!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">This
paper addresses a significant and consistent set of UML diagrams,
called MADES UML, and uses a metric temporal logic to ascribe a
formal semantics to them. It also introduces a prototype verification
tool based on a bounded model/satisfiability checker. &nbsp;← their
case study is different only; used to be a telephone system, now it’s
a car collision avoidance system</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">If
we think of UML as a graphical representation of a well-known
programming language (e.g., Java), the subset of the notation usually
considered is limited, and the actual semantics is borrowed from the
target language. In contrast, if we considered UML as a “pure”
modeling notation, a more precise definition of the meaning of its
elements would allow users to reason on designed models. ← for ppt?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">To
this end, this paper proposes a semantics based on a metric temporal
logic to provide a significant subset of UML with a consistent and
coherent interpretation. This subset is called MADES UML, after the
project in which it was defined. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">MADES
deals with model- based development of reactive, (time) critical
embedded systems, hence MADES UML is particularly well-suited for
modeling this category of systems.</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
&nbsp;← </SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">actually,
good to know that this methodology is suitable only for reactive
embedded systems. for ppt: maybe I should describe the category</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">It
includes: (a) Class diagrams and Object diagrams, to model the static
parts of the system and define the alphabet of the specification, (b)
State diagrams, to model the behavior of the different elements, &nbsp;</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">for
ppt: </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">(c)</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Sequence
diagrams, to model the “local” interactions among the components,
and (d) Interaction Overview diagrams, to relate the different
sequence diagrams, and describe more complete, general, and
system-wide interactions </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">[OMG10b].
Clocks, taken from MARTE [OMG09], add the time dimension and
constrain the behavior of components. Designed models are rendered in
terms of predicates and axioms written in &nbsp;TRIO [CCC+ 99], which
is a first-order linear temporal logic that supports a metric on
time. &nbsp;The use of a logic formalism for ascribing the semantics
to UML diagrams. We believe that, unlike more common notations like
Petri nets, automata, and transition systems, logics offers the
flexibility and scalability we need to formalize a wide and rich
notation like MADES UML. ← really?</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">A
prototype verification tool that translates UML models (we are
currently experimenting with the UML Modelio modeler) into the input
language of Zot [PMS08], a bounded model/satisfiability checker, to
provide users with a complete specification and verification
environment. Zot has been preferred to tools like Isabelle/Hol
[NPW02] because it is completely automatic and transparent to the
user. The majority of the approaches that address the deisgn notation
solely focuses on the structural aspects (namely, on the class
diagrams), and the dynamic semantics of its behavioral diagrams such
as activities, interactions and state machines, is still an open
problem [BC11]. T</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">he
existing work on the verification of OCL constraints against class
diagrams [CCR08] is orthogonal to the formalization problem.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
OMG recently released fUML, which identifies a subset of the UML 2
meta-model to provide a shared foundation for higher-level UML
modeling concepts. &nbsp;It does not address “advanced” UML
diagrams such as sequence and state diagrams, and the fUML execution
model is itself a model, written in fUML, that specifies how fUML
models are to be executed. This circularity is broken by the separate
specification of a base semantics for the subset of fUML actually
used in the execution model. The execution model specifies how fUML
models should be executed but it does not specify how to verify
user-defined properties over all the possible execution traces.
Moreover fUML does not analyze the semantics of time, concurrency and
inter-object communication. If we consider multi-diagram UML models,
the number of proposals is limited. The UML Semantics Project [BCD+
06] developed a mathematically-formalized semantic definition of UML
organized in three layers. The bottom one defines a universe of
interacting state machines that describe the behavior of objects and
their relationships with each other. Inter-object and intra-object
behaviors are defined on top of these diagrams. Finally UML
activities, state, and interaction diagrams rely on
previously-defined actions to modify the state of the objects.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Class
diagrams (CD) provide the static definitions of the elements in the
system. Attributes and method parameters can be defined over the
integers, over the reals, or finite subsets thereof. ← for ppt:
mention that you use class diagrams as well (for types/arguments of
class operations)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">State
diagrams (STD) can be used to describe the behavior of (significant)
system objects. Sequence diagrams (SD) describe partial behaviors of
the system. They describe the messages exchanged between the objects
defined in the OD. The messages should be instances of the operations
defined in the CD for that object. Interaction Overview diagrams
(IOD) constitute a high-level structuring mechanism that is used to
compose SDs through standard operators such as sequence, iteration,
concurrency or choice. The different diagrams share a common set of
events. Interrupts, beginnings and ends of messages, clock ticks,
execution occurrences of SDs, and states entered and exited are only
some examples of all the events considered in MADES UML; To this end,
our approach supports the analysis of partial models by simply
avoiding the translation of the diagrams the user is not interested
in. This results in a “lightweight” approach, in which the user
can focus the verification on the parts of the model that are really
involved in the properties to be proved, without the need for
translating the entire UML model.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
semantics of MADES UML is defined in TRIO [CCC+ 99], which is a
first-order linear temporal logic (</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">LTL)</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">that
supports a metric over time. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Objects
which are inside an execution occurrence must be considered busy. ←
but what if multiple processes execute the same operation. is it
twice busy? :D</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
IOD is a special type of Activity Diagram where the activity nodes
are SDs. &nbsp;The formalization in temporal logic of STDs (SMs) is
fairly standard.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Time
Constraints. Both SDs and STDs can include time constraints between
pairs of events included in the diagram (Figure 1). Time constraints
are included in the UML/MARTE specification [OMG09]. A time
constraint is an inequality between two events. For reasons of
brevity we do not show the entire axiomatization of time constraints.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">SD
parameters are useful to create a correspondence between values
exchanged by the objects of an SD, typically through the actual
parameters of the operations invoked; </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">In
the MADES UML notation, parameters (of SDs or of operations) can be
arbitrary integers, and the semantics describes some rules for their
evolution, something that in literature is mostly lacking ← for
ppt, I deal with them!!!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">To
implement in practice this kind of semantics, which includes
arithmetic constraints such as v = Past(v, 1), which states that the
value of v in the current instant is the same as the value at</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">the
previous instant, we use the features offered by Satisfiability</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Modulo
Theories (SMT) solvers; ← with process algebra keeping the value
from one instant to another is natural;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">To
carry out these activities in practice, a prototype tool has been
implemented to produce formulae written in the input syntax of the
Zot bounded model/satisfiability checker </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
capabilities of the Zot tool have been used also to validate the
semantics proposed in Section 4, for example by producing traces
compatible with snippets of the diagrams that we checked for
conformity with the desired dynamics. ← for ppt definitely, to
check the validity of the transformation</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
CCAS is modeled with one CD, one OD, one IOD, two SDs
(sendSensorDistance, sendBrakeCommand), and three STDs (corresponding
to the objects declared in the OD). ← for ppt: trivial example!? </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
fact, it can be the case that different UML diagrams are inconsistent
because, for example, the information provided in a view violates the
constraints imposed by another view. To answer this first question,
it is enough to feed Zot with the formal model, then ask the tool to
check its satisfiability; in case the model is satisfiable, Zot
produces a valid trace of the system; otherwise, in case of
inconsistencies, Zot indicates that the model is unsatisfiable. ←
CASE tools like RSA have already this built in</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
paper proposes a complete and coherent semantics (based on a metric
temporal logic) for MADES UML. In contrast to most existing
proposals, which focus on limited sets of diagrams, our approach
addresses a significant set of modeling elements and diagrams, and
provides users with a solution usable for the design and analysis of
a wide family of software systems. The proposed semantics is
presented through its predicates and axioms, while a first assessment
is based on an example car collision avoidance system.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Again,
InteractionFragments not tackled. Also, how about larger models?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">On
the relationship between modeling and programming</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Model
checking of UML 2.0 interactions (2007)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">-
good explanation of an observer automaton</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">-
this should be my CORE starting point for future work, inspiring!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">We
describe a translation of UML 2.0 interactions into automata for
model checking whether an interaction can be satisfied by a given set
of message exchanging UML state machines. The translation supports
basic interactions, state invariants, strict and weak sequencing,
alternatives, ignores, and loops as well as forbidden interaction
fragments. The translation is integrated into the UML model checking
tool HUGO /RT. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">We
propose a translation of UML 2.0 interactions into automata. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">This
synthesised operational behaviour description can be used to verify
that a proposed design meets the requirements stated in the scenarios
by using model checking. On the one hand, the translation comprises
basic interactions of partially ordered event occurrences, state
invariants, the interaction combination operators for weak and strict
sequencing, parallel and alternative composition, as well as a
restricted form of loops, which can have potentially or mandatorily
infinitely many iterations. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">On
the other hand, besides these uncontroversial standard constructs, we
also handle a classical negation operator [3], which avoids the
introduction of three-valued logics as suggested by the UML 2.0
specification by resorting to binary logic. A system of message
exchanging UML state machines together with the generated automaton
</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">representing
a UML interaction for observing message traces is translated into the
input language of an off-the-shelf model checker, which then is
called upon to check satisfiability. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Currently,
we support interaction model checking over state machines with S PIN
[6] and, partially, with U PPAAL [7]. ← brilliant, try this really!
Especially see how it goes with SPIN, what the automata looks like!</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Vertical
juxtaposition of interaction fragments implies</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">weak
sequencing</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">,
such that in the second operand of the alternative the sending of c,
active on obj1, comes before any event on obj1 inside the not
fragment, and the receiving of c before any event on obj2. Both
operands to alt are guarded by conditions, which determine which
operands can be chosen at “runtime”. ← weak sequencing is for
interaction fragments; The primitive interaction fragments we
consider are basic interactions, consisting of a set of event
occurrences with a </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">partial
order </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">[1,
p. 410], and state invariants for a single or several lifelines that
has to hold if the state invariant is reached. Of the interaction
operators [1, p. 410–412], we consider weak (seq) and strict
sequential composition, parallel composition (par), alternative
(alt), weak and strict sequencing loop, ignore of messages not
mentioned, and a binary negation (not). ← partial order is for
message occurrences, or “primitive interaction fragments”</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">ppt:
We interpret a UML 2.0 interaction as an observer of the message
exchanges and state changes in a system. Whenever the system under
observation sends or receives a message or one of its objects
terminates successfully, the observer is notified and can act
accordingly by making a move accepting the event or by producing a
failure. However, it may also refrain from doing so, if it does not
deem the state change relevant. Taking such an observer to be an
automaton accepting words of system changes, i.e. state changes or
events, </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">the
acceptance conditions for finite and infinite runs can be rendered as
the corresponding ones in finite state machines and B ̈ chi automata
[8].</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Interaction
automata, realising such an observer from an interaction by a
state-transition system, are defined over an interaction alphabet (L,
E, Σ) of a finite set of involved lifelines L, a set E of
termination, send and receive events from messages exchanged between
the lifelines, and a set Σ of system states. The transitions
outgoing from a state define a set of events that, when occurring,
enable the transition. Moreover, transitions may be guarded by
conditions arising from the conditions in the interaction. Finally,
an interaction automaton may also use and manipulate a set of
counters V that allow to record how often lifelines in loops have
executed. A run of an interaction automaton N: N accepts a finite
run, if this run reaches a state in the accepting states A of N , and
it accepts an infinite run if this run reaches one of N ’s
recurrence</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">states
R infinitely often. It may be noted that although we define
interaction automata to be finitely represented, the configuration
space may be infinite due to unbounded increases of counters.
However, for bounded interactions, in which no lifeline in a loop is
allowed to proceed arbitrarily in advance with respect to another
lifeline in the loop [9], the configuration space can be kept finite,
and even for unbounded interactions, the system under observation may
not produce runs that exhibit unbounded differences between counters.
← WTF? </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">We
translate UML 2.0 interactions into interaction automata </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">following
the generally agreed upon semantics of basic interactions, state
invariants, and the interaction operators seq, strict, par, alt,
ignore, and, in a restricted form, loop [3,4]. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Furthermore,
we handle a binary logic not operator; not and loop are restricted to
basic interactions ← we don’t restrict </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">loop</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">to
basic interactions..</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
contrast to other approaches (e.g. [10,11]) we propose not to
generate one automaton for every object in an interaction, but to use
only a single observing interaction automaton for the entire
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">interaction.
This single automaton represents the property to be checked by a
model checker. Our translation of basic interactions is a simplified
version of the construction for Live Sequence Charts </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">(LSCs)
given by Brill et al. [12], the handling of weak sequencing cuts down
techniques of Alur and Yannakakis for bounded MSCs [9]. These
interaction fragments form the primitive blocks in our translation
procedure and have to be represented as interaction automata
directly. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">←
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Entire
section 4.1 on translating the basic building blocks.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Negation.
We replace UML 2.0’s notorious negation operator neg by a binary
logic variant not which simply accepts all those traces that are not
valid for its operand. However, an algorithm for negating general
interaction automata is out of reach. ← this is the problem, I need
the negation of an automaton </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
negation operation on these interaction automata basically means that
all accepting states become non-accepting states and all
non-accepting states become accepting states in the negated
automaton. A new recurrent state is added, and from all complemented
states transitions to this accepting state are added to accept all
events that were not accepted in the corresponding state of the
original automaton.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">This
additional accepting state is also equipped with a self-loop
accepting all possible events.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
apply interactions as observers in model checking by translating the
generated interaction automata into observing processes in the model
checker S PIN. The system to be observed are message exchanging UML
state machines. S PIN is called upon to check whether there is a run
of the UML state machines that is accepted by the observer
interaction automaton. The translation of UML state machines into S
PIN, the translation from UML 2.0 interactions into interaction
automata, and the translation of interaction automata into S PIN are
integrated into the UML model checking tool H UGO /RT.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">for
pp: The counters of an interaction automaton are represented as
variables of the observing process. For recording events </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">the
system is instrumented to communicate with the observer via
rendezvous channels: Each time a message is sent or received, or a
state machine terminates successfully the observer is notified. </SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Over
time there have been various approaches to formalising scenario
descriptions</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Klose
[17] proposes an automaton-based interpretation of LSCs and gives a</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">n
algorithm to create automata out of basic LSCs</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">.
Harel and Maoz [19] propose to port the semantics of LSCs to UML 2.0.
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">With
CHARMY, Autili et al. [20] present a tool based on an approach
similar to ours. The focus of C HARMY are architectural descriptions
and the verification of their consistency. The semantics of
interactions, given by their translation rules, however, deviates
substantially from what can be gleaned from the UML 2.0
specification. Furthermore, in the program version we tested,
combined fragments are not supported. ← for future work, try all
actual tools for support of all!</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
future work below:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Since
in the current implementation loop and not are restricted in terms of
operands, one direction of future work will be to detail to which
extent these restrictions can be removed. We also intend to integrate
the remaining operators specified by the UML 2.0 specification, which
we have disregarded so far. Furthermore, the specification patterns
for scenarios described by Autili et al. [20] should be combined with
our approach. Finally, we plan to integrate timing constraints and to
enhance the translation of interactions into the real-time model
checker U PPAAL.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt!! Entire Section 2:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">UML
2.0 interactions consist of interaction fragments. These fragments
can be occurrence specifications, specifying the occurrence of events
within an object that is participating in the interaction. Sets of
occurrence specifications, which we call basic interactions, and
combined</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">fragments
aggregate occurrence specifications into bigger interaction
fragments. A combined fragment comprises an operator, defining the
meaning of the particular fragment, and one or more operands. The
operands are interaction fragments themselves, and can be guarded by
an optional condition, limiting the possibilities for when this
operand may be executed. The example in Fig. 1 shows instances of the
important aspects of a UML 2.0 interaction. The two objects obj1 and
obj2 exchange messages, specified by message occurrence
specifications on their respective lifelines.3 Weak sequencing is
implicit in the second operand of the alternative, such that the
sending of c, active on obj1, comes before any event on obj1 inside
the not fragment, and the receiving of c before any event on obj2.
Both operands to alt are guarded by conditions, which determine the
operand that needs to be chosen at “runtime”. Furthermore, the
two operators (alt and not) occur on different levels of nesting,
showing how larger, nested interactions can be composed.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
primitive interaction fragments we consider are basic interactions
and state invariants. A basic interaction consists of a set of event
occurrences with a partial order subject to the following
constraints: The dispatch of a message, the send event, occurs before
the arrival of the message, the receive event; all event occurrences
active for the same lifeline are totally ordered; and a termination
event (cross), if any, must be the last event on its lifeline. A
state invariant defines a condition (in a rounded box) for a single
or several lifelines that has to hold if the state invariant is
reached.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
← </SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">ppt:
great definition of partial ordering of events</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Moreover,
UML 2.0 puts a number of interaction-building operators at the user’s
disposal. In sequential composition, the behaviour of the resulting
interaction is the behaviour of the first operand followed by the
behaviour of the second operand. There are two kinds of sequential
composition, which differ in the meaning of the word “followed”.
Strict composition, denoted by the operator strict, requires the
behaviour of the first interaction to be completely performed before
starting with the behaviour of the second interaction. Weak
composition (implicit or explicitly with seq) only requires the
behaviour specified for an object in the first interaction to be
completely performed before starting with the behaviour for that
object in the second interaction.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Other
operators currently supported by our implementation are parallel
composition (par), alternative (alt), loop, ignore, and negation
(not). Two parallel interactions are to be executed by interleaving.
An alternative means to execute one of two given interactions; this
may be a non-deterministic choice if the conditions of the alt
fragment overlap. A loop repeatedly executes its operand between
bounds m and n, where it has to iterate at least m times and at most
n times. Standardly only the upper bound may be infinity. We,
however, also handle loops where also the lower bound is infinite. If
a loop requires k iterations, this amounts to the k-fold weak
sequencing of the operand. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">We
restrict the use of weak sequencing loops to contain only a basic
interaction, </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">but
we also support an unrestricted operator sloop, which enforces strict
sequencing of the operand.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
negation operator not is intended for the specification of forbidden
behaviour and presents a simpler variant of the </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">controversial
neg operator of UML 2.0:</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Everything
but the precise behaviour of its operator is valid for not. Finally,
ignore allows additional messages to occur besides the ones specified
in its operand. ← </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">for
ppt: the loop restriction is somewhat too restrictive, this means you
can’t straightforwardly present a code like this: … </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Interaction
automata are defined over such an interaction alphabet and realise a
finite description of an observer by a state-transition system. The
transitions outgoing from a state define a set of events that, when
occurring, enable the transition. Moreover, transitions may be
guarded by conditions arising from the conditions in the interaction.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
order to reflect weak sequencing of interactions, the events and the
guard of a transition show a set of lifelines, which are active when
making a move by this transition. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Finally,
an interaction </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">automaton
may also use and manipulate a set of counters that allow to record
how often lifelines in loops have executed. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
concrete representations of interaction automata, we show states as
ellipses and transitions as arrows. Accepting and recurrence states
are doubly and triply outlined, respectively. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Transition
inscriptions show (a description of) the set of accepted events η,
the guard condition g, and the action a in the format η[g]/a; any of
these parts may be omitted and the active lifelines are left
implicit.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
contrast to other approaches (e.g. [3, 16]) we propose not to
generate one automaton for every object in an interaction, but to
generate only a single observing interaction automaton for the entire
interaction. This single automaton represents the property to be
checked by a model checker.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Brill
et al. [17] discuss the generation of automata for basic LSCs. Our
translation of basic interactions is inspired by their algorithm. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Loops.
The UML 2.0 defines loops which have a lower and an upper bound for
the number of iterations their operand has to perform; the lower
bound has to be finite, while the upper bound may be infinity. We
change this and also allow the lower bound to be infinity. This way
we can specify loops that must not terminate. However, we restrict
loops to contain only a basic interaction. For finite or infinite
loops of a basic interaction the algorithm for unwinding a basic
interaction can be reused. As weak sequencing is used for loops, the
lifelines in the underlying basic interaction can make different
progress. Thus the history stored in a phase for a basic interaction
becomes insufficient for loops, as not all prerequisite events for a
given event will be present in the history if the lifeline’s event
is lagging behind the lifeline of one of its prerequisites. We
introduce counters for recording the separate progress of each
lifeline. It remains to ensure that the number of iterations of the
loops indeed is between its lower and upper bound. If the lower bound
is finite, a phase becomes accepting if the counters for all
lifelines are equal and the counters are greater than or equal to the
lower bound. If the upper bound is finite a new cycle of a lifeline
may only be started, if the counter of the lifeline has not reached
the upper bound. Finally, if either the lower or the upper bound of
iterations is infinite, we also have to introduce a recurrent state
which is run through every time the lifeline counters are equal. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Negation.
We replace UML 2.0’s notorious negation operator neg by a binary
logic variant not which simply accepts all those traces that are not
valid for its operand. However, an algorithm for negating general
interaction automata, in particular involving counters, is out of
reach. Thus we restrict the application of not to basic interactions,
such that the interaction automaton to be negated is deterministic
and does not involve counters. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
negation operation on these interaction automata basically means that
all accepting states become non-accepting states and all
non-accepting states become accepting states in the negated
automaton. ← not really the correct interpretation? you negate
actions (events). not states. The expressive power of the translation
of not fragments could be greatly enhanced by adopting a general
negation construction for non-deterministic B ̈ chi automata [19];
however, the size of the resulting automaton would be exponential in
the size of the input automaton.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Parallel
Composition. The parallel composition N1 N2 uses a construction very
similar to the parallel composition of B ̈ chi automata [15], where
a special counter k is employed to record if first N1 and then N2 are
running through a recurrent state and only if both automata have run
through a recurrent state, N1 N2 goes through a recurrent state. This
construction only has to be adapted to cover that both or one of the
interaction automata do not show recurrence states.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Weak
Sequencing.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">A
slight modification of the construction for parallel composition can
be used for </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">obtaining
the weak sequential composition ← for ppt if they ask? </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Strict</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Sequencing</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">.
The strict sequential composition N1 ; N2 is achieved by building an
automaton </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">which
appends N2 at every accepting state of N1 &nbsp;</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Alternatives</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">.
Thus, given interaction automata for each operand of an alt fragment,
we integrate them into a single automaton with guarding transitions
from a new initial state. The guards of these transitions show the
conditions of the operands. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
translation of UML state machines into SPIN, the translation from UML
2.0 interactions into interaction automata as well as the translation
of interaction automata into SPIN are integrated into the UML model
checking tool HUGO /RT [12].</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">For
recording object terminations and the messages exchanged in the
observed system, the system is instrumented to communicate with the
observer via rendezvous channels: Each time a message is sent or
received, or a state machine terminates successfully the observer is
notified.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">These
optimisations are done on the fly without constructing the product
automaton. What is more, the unwind algorithm produces rather large
automata, even with sharing: For n independent events on n lifelines
the resulting number of states will be 2^n ; for n consecutive
messages from one lifeline to another the number of states is (n +
2)(n + 1)/2. Thus it is beneficial to encode a phase not into the
states of an interaction automaton, but to employ an external
bit-array which encodes the progress of the phases and to use tests
on this bit-array for checking whether an event can be accepted </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
case study seems to be smallish, only 3-4 diagrams! ← for future
work!</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">We
have presented a translation from UML 2.0 interactions into a special
class of automata showing features of finite state automata, B ̈ chi
automata and counter automata. These interaction automata have been
further translated into concrete programs for model checkers. &nbsp;←
so the tool allows just creation of the automata, not the concrete
SPIN code directly. Investigate!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
added expressiveness allows the use of our approach to specify
properties which before would have required formalisms other than UML
interactions. Furthermore, many of the operators now also allow
shorter diagrams, because the new syntax makes explicit unwinding or
repetition unnecessary.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Checking
Properties Described by State Machines: On Synergy of
Instrumentation, Slicing, and Symbolic Execution</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Finite
State Machines as a formalism for describing properties</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">static
analysis is flexible and scales well, but due to the
overapproximation, many false positives. =&gt; better to use slicing</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">symbolic
execution does not suffer from false positives, but the “program”
is run on symbolic input. Drawback - they detect low-level violations
of programing language semantics. No idea about “the design”
(agnostic?)</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">they
propose in the end a combination to get the best of both, using
slicing</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">they
instrument code that implements the state machine of the porperty</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">symbolic
execution executes real program paths, only on symbolic input. They
show that slicing makes it feasible</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Case
study in C, only limited to locking errors state machine;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">they
use symbolic executor called KLEE. Case study is functions of the
Linux kernel;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">symbolic
execution is the bottleneck in the chain, results show</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">There
are several successful formalisms for description of program
properties. One of the most popular is a finite state machine (FSM).
This formalism is simple and still flexible enough to describe many
often studied program properties including locking policy in
concurrent programs, null-pointer dereferences, resource allocations,
and resource leaks.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">To
sum up, static analysis tools like xgcc, ESP, and Stanse are highly
flexible, fast and thus applicable to extremely large software
projects (e.g. the Linux kernel). It examines all the code and finds
many error reports. Unfortunately, many of the reports are false
positives.1 As manual sorting of error reports containing a pile of
false positives is tedious work, the practical applicability of such
tools is limited.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
contrast to static analysis, test-generation tools based on symbolic
execution do not suffer from false positives, since the checked
program is actually executed (but on symbolic input instead of
concrete one). In this paper, we introduce a new fully automatic
program analysis technique offering flexibility of FSM property
specification with zero false positive rate of symbolic execution.
The technique symbolically executes only parts of the analysed
program having impact on the checked property. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
our algorithm, the purpose of the instrumentation is to insert a code
implementing a state machine into the analysed program. Nonetheless,
the semantics of the program being instrumented must not be changed.
A result of this phase is therefore a new program that still has the
original functionality but it also simultaneously updates
instrumented state machines. &nbsp;The instrumentation starts by
recognizing code fragments which manipulate with locks in the
analysed program. The input of the slicing algorithm is a program to
be sliced and a so-called slicing criteria. A slicing criterion is a
pair of a program location and a set of program variables. The
slicing algorithm removes program statements that do not affect any
slicing criterion. More precisely, for each input data passed to both
original and sliced programs, values of the variable set of each
slicing criterion at the corresponding location are always equal in
both programs. It might be the case for some program and checked
property, that the sliced code still contains loops. Then the
subsequent symbolic execution can be very costly due to the
well-known path explosion problem. Fortunately, there have been done
some work tackling the problem. The framework provides us with a C
compiler clang. We also use an existing symbolic executor for Llvm
called Klee.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">A
Formal Semantics of UML Sequence Diagram (2004)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Formalisation
is based on classic computational model of transition systems (?)</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Useful
for explaining “partial order” of messages in an SD </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">most
informal parts of UML are links between different UML diagrams ←
for ppt: some claim this is the blurries thing, others claim nesting
of peculiar fragments like negation strict etc.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Need
to formalize Class diagrams first</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">PA
is natural for some aspects, not so natural for other aspects;
example are </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">State
Machines which are natural to model with PA, but barely used as the
basis for large scale general-purpose OO systems; for concurrent
systems even less</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
abstract syntax form, a well-formed sequence diagram corresponds to
an ordered hierarchical structure tree. The static semantics of a
sequence diagram is to check whether it is consistent with the class
diagram declaration as well as with its well-formed tree structure.
Meanwhile, the dynamic semantics is defined in terms of the state
transitions that are carried out by the method invocations in the
diagram. When a message is executed, it must be consistent with
system state, i.e., object diagram and the state diagrams of its
related objects. The semantics clearly captures the consistency
between sequence diagram with class diagram and state diagram.
Therefore, it is useful to develop the model consistent checking
functions in UML CASE tools.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
Unified Modeling Language (UML) [6, 21] is a general-purpose visual
modelling language that is used to specify, visualize, construct, and
document the artifacts of a software system. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
motivation is to provide a natural and intuitive formal semantics of
UML sequence diagram based on the people’s general understanding of
object-oriented programming language</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">How
can we check that a model of design correctly realizes a model of
system requirements? ← for ppt</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">For
example, if a sequence diagram uses an object, the class (or type) of
the object should be defined in class diagram. As for the second, we
must guarantee that each use case can be realized by its
corresponding sequence diagrams in the context of the design class
diagram. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">←
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">for
ppt: this is a thing of the past, UML tools have this built in</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Since
we only consider the synchronous method call, the event of sending
and receiving signals is ignored in this paper. We directly interpret
the interaction between objects into object method invocation in
object oriented programming language sense. Concurrency with
asynchronous communication can be considered in an extension of this
semantic model for component-based development [11]. Therefore, the
object, method call and other concepts of object-oriented programming
language can be used as basic concepts for defining the semantics of
sequence diagram. The dynamic semantics of a sequence diagram in this
paper is interpreted as a trace-based terminated process (thread) of
CSP. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
class diagram ∆ of an application identifies the environment in
which the sequence diagrams</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">operate.
&nbsp;The dynamic semantics of a sequence diagram is to be defined in
terms of state changes of the system. A state of the system with a
given class diagram is in fact a UML object diagram of the class
diagram. An object diagram is a snapshot of the class diagram which
consists the information about what the current objects are, what the
current links by associations among these objects are, and what the
state of the objects are, i.e. the values of their attributes.
Sequence diagrams are used to present the dynamic behavior of system
design while class diagrams are system static structure. As one of
two kinds of UML interaction diagrams, a sequence diagram shows
interactions between objects arranged in a time sequence.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Before
defining the semantics of sequence diagrams, we need to give the
formal syntax of sequence diagrams. We introduce an ordered
hierarchical structure tree to present well-formed sequence diagram
for a thread with synchronous method calls. For the complex
concurrent system with multithreads and asynchronous method calls can
be defined based on this work.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">On
the relationship between modeling and programing languages</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Software
developers create and use models for a variety of purposes. For
example, the following are three common forms of uses:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">=
Models as sketches: Developers find it useful to sketch descriptions
of requirements, design or deployment concepts on whiteboards or
paper when discussing their ideas with other developers or customer
representatives. This promotes communication?</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">=
Models as analysis artifacts: Developers build analyzable models to
check specified properties (e.g., consistency and satisfiability
properties), to predict implementation qualities (e.g., performance),
or to simulate implemented behavior. Included in this category of
models are formal, non-executable specifications that can be
statically analyzed, and executable models that support more dynamic
forms of analysis. These models typically contain only the
information needed to analyze target properties, and thus may not
include information that is needed to generate full implementations. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">=
Models as the basis for code generation or synthesis of software
artifacts: Models can be built for the purpose of generating
implementations, test cases, deployment or software configuration
scripts, or other software artifacts. These models must contain all
necessary information in a form that allow a generator to
mechanically synthesize software artifacts.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">One
of the most important uses of modeling techniques and languages is to
build executable models. Executing a model often involves code
generation. From a practical standpoint</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">it
makes a difference whether the developer’s intent is to produce
industrial-strength code when executing a model, or to produce code
that animates modeled behavior to provide the developer with feedback
on the adequacy of the model. Modeling languages that support the
building of executable models can be viewed as approximate forms of
very high-level programming languages, that is, languages above the
current high-level general-purpose programming languages (GPL). We
use the term “approximate forms” because we do not consider that
current modeling languages can completely replace or mask out GPLs;
there may be particular</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">algorithmic
elements that probably cannot and should not be</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">modeled
in a more abstract way than through statements in a GPL. The term
“very high-level” is used to reflect our view that models are
more abstract and compact than implementations expressed in a GPL.
For example, technical details (e.g., details related to efficient
implementations of complex data structures) and domain-specific
functionality can be added through intelligent code generators and
therefore need not be present in the model used to generate the code.
First, there is currently no successful tight integration between
modeling and programming technologies. Another major problem that the
modeling community currently encounters is the lack of modularity.
Good modularity allows a developer to encapsulate strongly related
design concepts in a single code module (e.g., a procedure or class)
and to expose only the information needed by other modules through an
interface. This is the major driving force for incremental
compilation, reuse, use of code libraries, dividing work amongst team
members, and therefore provides the means to scale development
projects. With the exception of Matlab/Simulink, today’s modeling
languages do not support the definition of an “interface” for a
model. The lack of interfaces leads to a different handling of models
during the development process. Tools typically load a single large
model in their workspace (we can be glad that we have enough space to
actually do this) and therefore expose developers to all the details
of the model. Any change in the model, no matter how small, typically
enforces a complete regeneration. Models are thus monolithic entities
that expose all details to developers. This makes reuse of models
challenging and gets in the way of developing libraries of reusable
model fragments. As long as we are not able to deal with models in a
modular way, the cost of developing and using models of complex
systems may outweigh the benefits of using the models in the
development process.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
hidden models of model checking</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">What
made this shift possible and what roles did models play in this? That
is the main question we consider here. We survey approaches that
transform domain-specific input models into alternative forms that
are invisible to the user and which are amenable to model checking
using existing techniques—we refer to these as hidden models. We
observe that keeping these models hidden from the user is in fact
paramount to the success of the domain-specific model checker.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
ppt: (google trends screenprint)</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Model
checking, since its introduction in the late 1970s, has become hugely
popular, so much so that Clarke, Emerson and Sifakis received the
2007 Turing award for their pioneering work in the field. Although
much of the early work on model checking focused on manual creation
of models in the notation of the model checker’s input, as the
field matured there was a shift to model checkers that directly take
domain-specific notations as input. We believe this shift is what
made model checking such a successful technique, since it not only
allowed domain experts that do not know how a model checker works to
use one, but also allowed the model checkers to exploit domain
knowledge to become more efficient. We argue that the key to making
domain-specific model checking possible is the use of hidden models
that are used during the transformation of domain notations to model
checking input to support efficient analysis and to allow
domain-specific output to reach the user.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">To
make the intermediate model both hidden and efficient, are two very
difficult goals Model checking is an algorithmic verification
technique that is particularly effective for finite-state systems. It
was co-invented by Clarke and Emerson [22] and Queille and Sifakis
[86] over three decades ago</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">for
ppt, visualise the stuff below, but also, show the modeling code to
state transition system phase:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Model
checking involves two inputs: a state transition system (S) that
encodes a set of behaviors to be reasoned about and a temporal logic
formula (φ) that encodes a set of desirable behaviors. The model
checking problem asks whether S is a logical model 1 of φ, i.e.,
whether the behaviors encoded by S satisfy φ. Algorithms for model
checking are able to answer this question and when the answer is
negative they produce a counterexample, i.e., a behavior encoded by S
that falsifies φ. Counterexamples provide valuable information for
locating errors in the transition system model or in the temporal
logic formula.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">These
approaches can be characterized in several dimensions, of which we
consider three: (1) the language features of the models S, (2) the
logics that can be used for describing properties over the models
(φ), and (3) the algorithms used to perform the analysis.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">With
symbolic algorithms, the model and set of explored states are
represented symbolically as Boolean formulae. For symbolic
approaches, there are two main “engines” that are used to solve
the generated Boolean formulae: SAT/SMT solvers [38] and
Binary-Decision Diagram solvers [12]. The choice of solver leads to
different classes of algorithms for model checking.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">There
are many model checkers available, but two of the most popular are
Spin2 [54] and </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">NuSMV.
</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">On
the upper right in Fig. 1 is a formula written in Spin’s syntax for
LTL. This specification assumes that boolean variables are present in
the system indicating when the system is initialized, when a resource
is open and when it has been closed. The LTL formula states that
after initialization a call to open will eventually be followed by a
call to close. The open, close, and init must be defined in terms of
the transition system model; they could capture the calls to a file
open method, a file close method, and the creation of a file instance
for a file API. Researchers have collected a variety of models from
the literature [30,31] that illustrate the diversity of specification
languages and properties targetted with model checking. &lt;- Dwyer</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Here,
we will assume all translations between models are correct, but it
should be acknowledged that proving such translations correct are
non-trivial. Environment model As stated in Sect. 2, model checkers
analyze a closed system, i.e. a system composedwith its execution
environment. The so-called Environment Model is often an abstraction
(both under- or overapproximation) of the actual environment</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">When
using an analysis technique such as model checking there is a system
whose behaviors are the subject of the analysis. While a system might
be expressed in any number of notations, typically, when working in a
particular problem domain there are notations that are both familiar
and convenient. For example, tele-communication protocols are often
specified in SDL [60], software is expressed in its source language,
such as Java, or C, and hardware components might be expressed as
VHDL </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
Fig. 2, this semantic gap is addressed by “(2) Intermediate Models”
that transform the domain model to the input of the model checker. A
successful domain specific model checker, bridges this semantic gap
in a fully automated fashion. Requiring user assistance to construct
this model means that only model checking specialists can use the
system. Equally important, this effort must be repeated every time
the system changes and is to be re-analyzed, significantly increasing
the cost of analysis.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Historically,
model checkers have been designed with problems in a specific domain
of application in mind. For example, Spin was developed to reason
about network protocols and, consequently, PROMELA is well-suited for
expressing such problems. When applying model checkers beyond their
originally intended domain of application, one often encounters
significant semantic mismatches between domain-specific notations and
model checker notations.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
achieving an efficient and effective translation. Initial efforts to
model check Java programs using Spin [26,51] had to address the lack
of heap allocated data, references, garbage collection, inheritance,
and exception handling. It is widely accepted that automated
techniques were needed to bridge the gap between domain models, e.g.,
Java programs, and model checker inputs, e.g., PROMELA, since relying
on human users to express their problems in model checker notations
is costly and error prone. Moreover, when counterexamples are
produced they describe property violations in terms of the model
checker’s input not the original</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">domain-specific
model. Thus, a kind of reverse translation must be performed and not
just once, but for every counterexample generated.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">for
ppt: </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Finally,
model checking tools are built to support the semantics of their
input language. When expressing a domain model in such a language the
semantics of the domain model are lost. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Creating
the environment model is one of the most difficult parts of model
checking [92], and we argue this is because there are no hidden
models readily available to simplify the process for a domain expert.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
areas where there have been significant industrial success with
software model checking systems, it is often the case that the domain
has been limited to the extent that environment models can be created
and packaged with the model checking system.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Unlike
domain or environment modeling, the process of describing a desirable
system property is much more focused. For example, after several
decades during which competing temporal logics were used for
specifying hardware properties in 2005 IEEE standardized the property
specification language (PSL).</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">When
a model checker detects a violation of a property it generates a
representation of the ways in which the system’s behavior violates
the specified property—a counterexample. The nature of the
counterexample depends on the type of specification. For example, the
violation of a property stating that variable x is always positive
would be described as a sequence of steps in the system execution,
starting at the initial state and interacting with the environment
model as appropriate that ends in a state in which x ≤ 0.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">When
a property is true of a domain model and its environment, there is
the option that the wrong property was specified (or the property was
specified incorrectly)</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">When
resource limits are exceeded, coverage data can also give an
indication of the extent to which the model checking was able to
explore the set of system behaviors. &nbsp;← yeah, would be good
for mCRL2</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">During
the application of these reductions, models are created that preserve
relevant behavior of</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">the
original model, but simplify the model checking. Since those models
only exist during the model checking run they are referred to as
transient. Many reduction techniques can be viewed as constructing a
transition system model that preserves the ability to answer the
model checking question (or at least to answer it in the
affirmative). For example, property directed model slicing [50]
eliminates portions of the transition system that are provably
unrelated to the temporal logic formula under analysis. Partial order
reductions (POR), e.g., [41] and symmetry reductions [58] effectively
ignore behaviors of the input transition system that are provably
equivalent relative to the temporal logic formula under analysis.
Essentially, they construct a reduced model on-the-fly during
analysis. Predicate abstraction [44] techniques transform the
transition system model by selectively replacing non-deterministic
choice with abstracted branch predicates to sharpen the precision of
analysis results while minimizing the cost of analysis.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
addition, as the formulae are being solved, it is often &nbsp;the
case that the solver changes the formula encoding to make it more
efficient to solve. For example, a Binary Decision Diagram (BDD) is a
directed acyclic graph representation of a Boolean formula that is
ordered by the Boolean variables in the formula. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">It
became quickly apparent that the semantic gap could not be easily
bridged and custom model checkers were developed instead
[4,40,87,95]. These custom checkers took the original source code as
input and were able to exploit the domain knowledge captured within
the models to improve the model checking.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">An
interesting case is the SPIN model checker [54] that in its early
form only allowed PROMELA models, i.e. custom notation for modeling
protocols, but now supports also the analysis of C code. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
Verisoft model checker [40] was one of the first to target source
code and used an underlying logical model based on interleavings of
concurrent statements. The C library code for threading was
instrumented to allow all possible enabled actions to be executed.
Furthermore, it was the so-called stateless model checking since no
states were stored and executions were replayed from the start rather
than use a backtracking based search. The logical model was thus a
tree of concurrent transitions (or code segments) rather than the
more common graph of states. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">JPF
[95] and BOGOR6 [87] also support concurrent programs, but in this
case Java programs. The logical model used in both cases is a graph
of reachable states that allow one to check both safety and liveness
properties However, the hidden models used here are more complex and
based on executing Java bytecode.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">SLAM
[4] and CBMC8 [21] only focus on sequential programs</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">,
but use very different logical models: SLAM uses boolean programs
derived from abstractions of C code and CBMC encodes the reachability
problem for C/C++ programs as a satisfiability problem and uses a
technique called bounded model checking to do the analysis.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Note
that all software model checkers augment the classic programming
languages they analyze with the capability of expressing
non-deterministic choice. This capability allows one to specify
(among other things) the range of possible inputs to be used when
analyzing the program. Without a non-deterministic choice operation,
useful environments cannot be generated and in some sense model
checking degenerates to testing (in the sequential case at least; for
concurrent programs the scheduler is still non-deterministic in
general). For example, JPF has a highly user-customizable
ChoiceGenerator framework that allows all forms of non-determinism,
including custom data choices, scheduling choices, etc.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">Although
model checking is historically focused on using temporal logic
properties for analysis, software model checking tends to use only
safety properties and not liveness properties. Stateless model
checkers cannot handle liveness by definition since they cannot
detect cycles</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">,
but even model checkers like JPF and BOGOR do not support liveness;
SPIN </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">does
support liveness but when using C code in the models, one must
specify which part of the state must be tracked during model checking
(exposing the hidden model). </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">The
most </SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">common
types of properties are simply local safety properties in the form of
assertion violations</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">(including
contracts) or uncaught runtime exceptions (for example null pointer
dereferences). </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">Another
class of property is finite-state machine properties, such as every
open should be followed by a close operation. </SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
internal optimizations used in software model checking are numerous,
but essentially two techniques stand out: partial-order reductions
[41] and predicate abstraction [44]. Partial-order reductions reduce
the number of interleavings that need to be analyzed during model
checking of concurrent programs, by not considering interleavings of
independent transitions. The dependency information was traditionally
determined by a static analysis before model checking, but due to the
dynamic nature of software, dynamic partial-order reduction [37] is
more popular in software model checking. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Where
partialorder reduction is a precise abstraction of the original
program (i.e. no behaviors are added or removed) the boundedcontext
switching approach is an under-approximation that</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">could
miss errors.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
underlying technology required for predicate abstraction (as well as
symbolic execution) is decision procedures for satisfiability that
can reason over the domain of the program instructions, e.g. linear
integer arithmetic, strings, arrays, bitvectors, etc. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Hardware
designers use hardware description languages (HDLs) to describe the
design of electronic circuits. The two most popular languages are
Verilog [89] (and its superset SystemVerilog [88]) and VHDL [56],
though there are a wide range of notations that are used.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Synthesis
revisited: Generating statechart models from scenario-based
requirements</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">mind
you, this is for reactive systems / embedded systems...not sure if it
fits</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
this paper we describe a methodology for synthesizing statechart
models from scenario-based requirements. The requirements are given
in the language of live sequence charts (LSCs), and may be played in
directly from the GUI, and the resulting statecharts are of the
object-oriented variant, as adopted in the UML. We have implemented
our algorithms as part of the Play-Engine tool and the generated
statechart model can then be executed using existing UML case tools.
Scenario-based inter-object specifications (e.g., via live sequence
charts) and state-based intra-object specifications (e.g., via
statecharts) are two complementary ways to specify behavioral
requirements. In our synthesis approach we aim to relate these
different styles for specifying requirements. The main motivation for
suggesting the use of LSCs as a requirement language in [10] is its
enhanced expressive power. LSCs are an extension of message sequence
charts (MSCs; or their UML variant, sequence diagrams) for rich
inter-object specification. One of the main additions in LSCs is the
notion of universal charts and hot, mandatory behavior, which, among
other things, enables one to specify forbidden scenarios. Synthesis
is considerably harder for LSCs than for MSCs, and is tackled in [10]
by defining consistency, showing that an entire LSC specification is
consistent iff it is satisfiable by a state-based object system. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt: There are several issues that have prevented the approach
described in [10] from becoming a practical approach for developing
complex reactive systems. A major obstacle is the high computational
complexity of the synthesis algorithms, that does not allow scaling
of the approach to large systems. Additional problems are more
methodological, related to the level of detail required in the
scenarios toallow meaningful synthesis, the problem of ensuring that
the LSC requirements are exactly what the user intended, and a lack
of tool support and integration with existing development approaches.
We suggest a synthesis methodology that is not fully automatic but
rather relies on user interaction and expertise to allow more
efficient synthesis algorithms. One of the main principles we apply
is that the specifier of the requirements provide enough detail and
knowledge of the design to make the job easier for the synthesis
algorithm. The algorithm tries to prove, using verification methods,
that a certain synthesized model satisfies all requirements; if it
manages to do so, it can safely synthesize the model. We have
developed a prototype statechart synthesis environment, that receives
as input LSCs from the Play-Engine tool [13] and generates a
statechart model that can then be executed byRhapsody [15], and in
principle also by other UML tools</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">An
important usage of scenario notations is for communicating ideas and
for documentation. For such purposes sketching an inter-object
scenario on a blackboard or diagram editor can be very helpful. When
our goal is synthesizing a statechart model and eventually production
code from the scenarios, we need a powerful and expressive
inter-object scenario-based language with rigorously defined
semantics. The language should still retain the simplicity and
intuitive feel that made scenario-based languages popular among
engineers. In our approach we use the language of live sequence
charts (LSCs) introduced in [7]. LSCs extends classical message
sequence charts, which have very limited expressive power. Among
other things, LSCs distinguish between behaviors that may happen in
the system (existential) from those that must happen (universal).
According to this argument it is not possible to beneficially apply a
synthesis approach for deriving a system implementation since the
requirement model provides insufficient details. We attempt to
overcome this challenge by using the play-in/play-out approach
introduced in [13, 14]. In play-in the user starts with a graphical
representation of the system and specifies various scenarios by
interacting with the GUI and demonstrating the required behavior. As
this is being done, the Play-Engine tool constructs the LSC that
captures what was played in. ← weird We try to address this
challenge in several complementary ways. First, the requirement
language of LSCs, being an extension of classical MSCs, has intuitive
semantics, and allows users who are not very technical to express
complex behavioral requirements, while other formalisms, e.g.,
temporal logic, may prove to be trickier even for advanced users.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Scenario-based
inter-object specifications (via LSCs) and state-based intra-object
specifications (via statecharts) are two complementary ways for
specifying behavioral requirements. In our synthesis approach we aim
to relate these different styles for specifying requirements.
According to the play-in/play-out approach the user specifies
behavioral requirements by playing on a GUI representation of the
system, as this is being done the Play-Engine automatically
constructs corresponding requirements in LSCs.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">specifies
a formalized representation of objects and classes and methods, via
tuples with mathematical notations...not very complex,
understandable, but then what?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">LSCs
as a declarative, inter-object behavior language, enables formulating
high level requirements in pieces (e.g., scenario fragments), leaving
open details that may depend on the implementation. The partial order
semantics among events in each chart and </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">the
ability to separate scenarios in different charts without having to
say explicitly how they should be composed </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">are
very useful in early requirement stages, but can cause
under-specification and nondeterminism when one attempts to execute
them. ← bold for ppt, ADs come to the rescue</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
order to apply the synthesis approach we encode play-out in the form
of a transition system and then apply model-checking techniques. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">We
construct a transition system which has one process for each actual
object.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
← </SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">another
paper constructs a single automaton for the property, </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">isn’t
that more convenient? </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
state in this system indicates the currently active charts and the
location of each object in these charts. The transition relation
restricts the transitions of each process only to moves that are
allowed by all currently active charts. We now providesome more of
the details on how to translate LSCs to a transition system. The
encoding of the transition relation was developed as part of our work
on smart play-out. We use the asynchronous mode, in which a send and
a receive are separate events, but we support the synchronous mode
too. The details of encoding the transition relation are rather
technical, for more information see [11]. The basic synthesis scheme
generates a statechart for each of the participating objects, using
orthogonal states for implementing different scenarios and making use
of additional events to guarantee synchronization of the distributed
objects along each behavioral scenario. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
Antenna object, which is now in the sub-state P 1 of the OpenAnt
component, takes the null</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">transition
to state S0. Null transitions are transitions with no trigger event,
and are taken spontaneously. ← wtf?</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">here
are several points were the synthesis algorithm can be optimized to
produce more efficient and readable models, and indeed we have a
first version of such an improved algorithm. When sending an event to
all other objects to notify them of some occurrence (for example when
taking the transition from state P0 to state P1 in orthogonal
component OpenAnt of the Antenna) it is enough inour case to send the
event only to the Display object, since the objects Cover</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">and
Speaker do not participate and are not affected by the opening
Antenna scenario.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
idea of deriving state-based implementations automatically from
scenario-based requirements has been the subject of intensive
research efforts in recent years; see, e.g., [17, 18, 20, 19, 29].</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
latest versions of the UML recognized the importance of
scenario-based requirements, and UML 2.0 sequence diagrams have been
significantly enhanced in expressive capabilities, inspired by the
LSCs </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">behavioral
descriptions: ← for ppt!</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">intra-object
== all pieces of stories for one object</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">inter-object
== one story for all relevant objects</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Generating
statechart designs from scenarios ← NASA paper, but old one :-/
2000?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">for
ppt:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Each
UML notation represents a particular aspect of a software system from
a particular viewpoint. However, there exists a good deal of overlap
between many notations. ← give visual example of overlap between
Class,Sequence,State Machine diagram</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">This
paper presents an algorithm which supports the design process by
generating statechart designs automatically from scenarios. In what
follows, scenarios will be expressed as UML sequence diagrams and the
design model will consist of a class diagram and UML state-charts</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Since
scenarios only give a partial description of a system, we expect the
use of this algorithm to be similar to that of a code generator -
i.e., the algorithm produces a skeleton design which the user then
has to modify/complete. Since the user needs to modify the generated
statecharts, they must be readable. This means that the statecharts
must include sensible use of hierarchy and orthogonality. We have
devised a number of ways of introducing hierarchy into the generated
state-charts. We believe that the use of hierarchy is crucial to the
success of design generation tools.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Statecharts,
introduced originally by D. Hare1 [6], are finite state machines
extended with hierarchy and orthogonality (parallelism), allowing a
complex system to be expressed in a more compact and elegant way.
Conflicts between multiple sequence diagrams: There are two extreme
ways to overcome this problem. First, insist that the user provides a
complete, formal domain theory providing semantic information about
the messages. Second, assume no additional semantic information but
interpret scenarios based on some heuristic. Neither of these is
sufficient, however. The provision of a complete domain theory is
overly burdensome and an algorithm with no semantic information
ultimately produces incorrect results. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Once
conflicts have been resolved, we are ready to generate a statechart.
Our strategy is to generate a number of flat statecharts (in fact,
finite state machines (FSMs)) for each individual SD, one for each
object in the SD. &nbsp;Messages directed towards a particular
object, 0, are considered events in the FSM for 0. Messages directed
away from 0 are considered actions. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Figure
8 shows how a single SD is translated into a FSM for each object. A
FSM, as generated by Figure 8, is a 6-tuple ( N ,SO,V,p, L, 6) where
N is the set of nodes, SO E N is the initial node, V is the set of
state vectors, p : N + V is a labelling of the nodes with state
vectors, L is the set of transition labels and 6 N x L x N is the
transition relation. Transition labels are either events, denoted
(ev,m), or actions, denoted (ac,m), where m is a sequence of
messages. ← </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">the
algorithm is pretty understandable. But is it useful? Is every Stat
Machine Buchi automaton?</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
algorithm that we use subsequently is a variant of a standard
algorithm for transforming a non-deterministic finite automaton (NFA)
into a deterministic finite automaton (DFA) [l]. Each state in the
DFA is a set of NFA states which simulates “in parallel” all
possible moves the NFA can make on a given input string. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Transitions
between states have labels of the form e[c]/a . If event e occurs and
guard c holds, then the transition may be selected to fire which
results in action a being taken and a state change occurring. &nbsp;←
leverage this form event[condition]/action when creating a monitoring
process.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">what
follows is a heuristics for making the state charts
hierarchical...blabla</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Most
other approaches assume the correctness of the input scenarios. In
practice, the scenarios will contain ambiguities and inconsistencies.
Our algorithm detects conflicts which may correspond to such
ambiguities and hence can be used as a guide for refining the
scenarios. ← for ppt; well...</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-left: 0.03in; margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Synthesizing
hierarchical state machines from expressive scenario descriptions !!
(2010)</SPAN></B></FONT></FONT></FONT></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-left: 0.03in; margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
motivation for these is to automate the transition from
scenario-based requirements to early behavioral design models. To
date, however, these synthesis algorithms have tended to generate
flat state machines which can be difficult to understand or adapt for
practical systems. One of the reasons for this is that relationships
between scenarios are often not taken into account during
synthesis—either because the relationships are not explicitly
defined or because the synthesis algorithms are not sophisticated
enough to cope with them. If relationships are not considered, it is
impossible for a synthesis algorithm to know, for example, where one
scenario stops and another continues. ← for ppt!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-left: 0.03in; margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">With
the introduction of interaction overview diagrams (IODs) in UML2.0,
relationships such as continuation and concurrency can now be
specified between scenarios in a way that conforms to the UML
standard. But synthesis algorithms do not currently exist that take
into account all of these relationships. This article presents a
novel synthesis algorithm for an extended version of interaction
overview diagram. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">This
algorithm takes into account not only continuation and concurrency</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">,
but also preemption, suspension and the notion of a negative
scenario. &nbsp;</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-left: 0.03in; margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Furthermore,
the synthesis algorithm generates well-structured state machines.
These state machines are executable and can therefore be used to
validate the scenarios. The hierarchy generated aids readability and
so the state machines are more amenable to subsequent design steps.
Our IOD extensions have a formal semantics and are supported by a
synthesis and execution tool, UCSIM, which is currently provided as a
plug-in to IBM Rational Software Modeler.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-left: 0.03in; margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
UML [OMG 2007], scenarios can be described using interaction diagrams
(e.g., UML sequence diagrams). For reactive systems, it is also
important to model state-dependent behavior using some form of finite
state machine (FSM).</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-left: 0.03in; margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">[Many]
have tried to automate this transition from interaction diagrams to
FSMs. This is important research for the following reasons. First, it
automates a key activity of many OOAD processes and therefore can
save developers valuable time. Second, it transforms scenarios into
an executable form (namely, FSMs). Since FSMs are executable, they
can be simulated. Hence, automation of the transformation is a way of
simulating scenario-based requirements. This simulation can be used
in requirements validation.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-left: 0.03in; margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
transition from interaction diagrams to finite state machines is
essentially from a global view of object interactions to a local,
object-based view. Each interaction diagram contributes to the
state-based definition of one or more objects participating in the
interaction, and each object may participate in multiple interaction
diagrams. It is this fundamental mismatch between the global and
local view that makes synthesis nontrivial. A synthesis algorithm
must not only consider the behavior of a given object in one
scenario, but must unify all of the object’s behavior from multiple
scenarios. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-left: 0.03in; margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Before
UML2.0, scenario-based specifications often did not make explicit the
relationships between scenarios. In other words, scenarios were
written in isolation and their associations (e.g., continuation,
overlapping, parallelism) were not specified. This was partly because
early versions of UML did not support the specification of these
relationships. In the absence of scenario relationships, synthesis
algorithms have taken one of two approaches to elicit them. Either
the algorithm infers the relationships or the algorithm requires the
scenario writer to explicitly give the relationships in some form
(e.g., by explicitly identifying overlapping states [Kruger 2000]).
The inference approach is problematic because it results in false
positives. Specification of explicit relationships is problematic
because it may rely on a nonstandard methodology with which users are
not familiar.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-left: 0.03in; margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">With
the introduction of interaction overview diagrams (IODs) in UML2.0
[OMG 2007], developers were given standard ways for specifying
relationships between scenarios, in much the same way that high-level
Message Sequence Charts (hMSCs) [ITU 2004] had been used in the
telecommunications industry. There remain, however, fundamental gaps
in synthesis algorithm technology. First, existing synthesis
algorithms do not yet consider the full range of relationships that
can be specified in IODs. Some works [Uchitel et al. 2003b, 2004]
presented a synthesis algorithm for hMSCs but they include only
continuation. IODs allow concurrency to be specified and, in fact,
this article will introduce new relationships not currently available
in IODs. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-left: 0.03in; margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">This
article addresses both of these limitations of current synthesis
algorithms. It presents a novel synthesis algorithm for an extension
of IODs that includes not only relationships such as continuation and
concurrency, but also additional relationships found to be useful in
specifying distributed, concurrent systems, namely, preemption,
suspension, and the notion of negative scenario.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-left: 0.03in; margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
synthesis algorithm presented generates hierarchical state machines
that make use of UML’s structuring mechanisms for state machines,
namely, composite states and orthogonal regions. This makes the
generated state machines easier to read and, therefore, means that
they can be used in subsequent design steps.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-left: 0.03in; margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
synthesis algorithm presented in the article works on an extension of
IODs that was first introduced in Whittle [2005] and given a formal
semantics in Whittle [2007]. The key contribution of this article is
the synthesis algorithm. The main application of this algorithm to
date has been to simulate scenarios, but the generated FSMs could
also be used in test generation and automated verification.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-left: 0.03in; margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">In
summary, our synthesis algorithm goes beyond previous synthesis
algorithms because:</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-left: 0.03in; margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">-
it takes into account a rich set of relationships between scenarios
such as preemption, parallelism, and negation;</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-left: 0.03in; margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">-
it synthesizes hierarchical state machines which can be built upon in
subsequent analysis and design steps.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
synthesis algorithm has been implemented in the UCSIM tool [Jayaraman
and Whittle 2007; Whittle and Jayaraman 2006]. This tool allows its
users to describe scenarios for a system under development, including
complex and rich relationships between scenarios. The tool
synthesizes a set of hierarchical state machines from the scenario
description—in particular, one hierarchical state machine is
generated for each state-dependent object. UCSIM comes with an FSM
simulator so that the generated state machines can be simulated,
which helps the user to debug the scenarios. Finally, UCSIM is
designed as a vendor-independent tool that can be integrated with
existing UML modeling tools. So far, </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">UCSIM
has been integrated with IBM Rational Software Modeler (RSM) [IBM
2008]. Users draw scenarios in RSM, generate state machines from
within RSM, and simulate those state machines in RSM. The
architecture of UCSIM is such that integration with other modeling
tools is straightforward. ← check rational software modeler!! </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">We
briefly review IODs and then motivate extensions to IODs that both we
and other authors have found to be useful. This extended scenario
description language will be called EIODs (extended IODs).
Furthermore, we advocate a particular way of modeling with EIODs and
introduce that in this section also. Finally, we give an overview of
the semantics of EIODs so that it can be compared with the semantics
of the state machines generated by our synthesis algorithm. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
2.0 release of </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">UML
introduced interaction overview diagrams (IODs), a notation based on
activity diagrams, for specifying relationships between interactions.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">IODs
are based on high-level message sequence charts (hMSCs) [ITU 2004], a
well-established notation for specifying interactions originally
developed for the telecommunications domain. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
UML standard interprets the semantics of messages in terms of send
and receive events, corresponding to the sending or receipt of a
message by a participant. Events are partially ordered by weak
sequential composition that defines the following: (1) events on the
same lifeline are ordered according to their vertical location; (2) a
message’s send event always comes before its receive event. Weak
sequential composition means that sometimes the intuitive vertical
ordering of messages is not respected in the semantics. For example,
two messages without a common lifeline may occur in any order
irrespective of their vertical positioning when drawn graphically. ←
for ppt</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">UML
includes state invariants as a way of defining states in sequence
diagrams. State invariants are essentially labels that can be used to
identify different points along the lifeline of a participant (or
participants). Before their introduction into UML2.0, they were
called state labels by other authors. State invariants are useful to
capture the fact that two points along a lifeline are meant to be the
same. For example, they are an easy way to define loops (see Figure
1(b)) or to identify points in different sequence diagrams. State
invariants allow very fine-grained connections between sequence
diagrams. In this article, we do not allow state invariants to be
drawn across multiple lifelines. UML2.0 defines other operands as
well but they will not be considered here. Neither will this article
consider any of the other many modeling constructs for UML sequence
diagrams, such as dynamic creation and destruction of participants,
timing constraints, and the modeling of data. ← for ppt</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Interaction
overview diagrams are a restricted form of UML activity diagram for
capturing some kinds of relationships between interactions ← </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">for
ppt!</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">However,
activity diagrams are extremely rich in expressiveness and some
concepts do not necessarily make sense when applied to interaction
modeling.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Specifically,
EIODs allow those additional constructs from activity diagrams: </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">-
an interruptible activity region. The dotted box is an activity group
that scopes nodes and edges. An interruptible activity region is an
activity group that can be interrupted—shown by the lightning bolt.
If an interrupting event occurs, all activities within the region are
stopped.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">-
an activity with the keyword &lt;&lt;singleCopy&gt;&gt; which denotes
that all invocations of the activity are handled by the same
execution. This is in contrast to allowing a separate copy of the
activity to handle each new invocation of the activity. The latter is
the default semantics if the &lt;&lt;singleCopy&gt;&gt; keyword is
not shown. If an activity is marked with &lt;&lt;singleCopy&gt;&gt;,
then a new invocation of the activity may have to wait until a
previous invocation has completed. For example, a Process Order
activity marked as &lt;&lt;singleCopy&gt;&gt; would only allow one
order to be processed at a time, whereas if separate copies are
allowed, then multiple orders can be processed simultaneously. The
UML activity semantics is token-based (as in Petri Nets) and so
activity invocation corresponds to the receipt of a new token. As we
shall see, there are no tokens in the usual semantics for
interactions, so the notion of &lt;&lt;singleCopy&gt;&gt; must be
reinterpreted for interaction diagrams. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">-
a final flow node which terminates the current flow but does not
terminate the activity diagram. EIODs have a formal semantics
[Whittle 2007] which builds upon the semantics of Haugen et al.
[2005] for IODs. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">←
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">todo:
see if they exist in RSA!</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
main extensions are given below:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Nodes
in EIODs may have single or multiple concurrent executions—that is,
&lt;&lt;singleCopy&gt;&gt; is allowed in EIODs. For convenience, we
prefer the UML1.x notation for single/multiple copies over that of
UML2.x—that is, we define the default to be a single execution and
mark activities with multiple executions with an asterisk. Most
interactions tend to be single copy so this way turns out to be more
convenient. In addition, we extend the notion of multiple copies to
sets of nodes and borrow the concept of activity group from
interruptible regions to allow this. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">EIODs
allow interruptible regions, but define two types of interrupt—one
for preemption and one for suspension. The type is denoted by a
stereotype &lt;&lt;preempted&gt;&gt; or &lt;&lt;suspended&gt;&gt;
attached to the lightning bolt for an interruptible activity region.
The difference between preempt and suspend is that, for preempt, the
interrupted interaction is never returned to, whereas, for suspend,
once the suspending interaction is complete, control returns to the
interrupted interaction at the point where it was interrupted.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">EIODs
also include a notion of scoped negation. Although negation can be
modeled in IODs by referencing a sequence diagram which includes a
neg fragment, we allow a negative scenario to be scoped over an
activity group. That is, the scenario is negative only if it occurs
during the execution of activities in the activity group. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">EIODs
include the notion of a flow final node which can be used to show
that a scenario results in failure EIODs may have two types of final
nodes—a final node represents successful completion of </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">the
scenario and a</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">flow
final node</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">represents
completion but with failure. We restrict EIODs to those with
well-nested fork/join branches and such that there are no recursive
interaction </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">references.
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
full formal definition is too lengthy to include here but more
details can be found in Whittle [2007]. The following definition
gives the interpretation of an EIOD in terms of a pair of positive
and negative trace sets. A trace is a sequence of events where an
event may be the sending or receipt of a message. For a message m,
the event of sending a message will be denoted as !m and the event of
receiving a message will be denoted as ?m. A trace is well defined
if, for each message, the trace contains both a send and receive
event for the message, and, furthermore, the send event comes earlier
in the sequence than the receive event.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Positive
traces define potential behaviors in any implementation of the EIOD.
Negative traces may never occur in a valid implementation of the
EIOD. ← for ppt: so we don’t need cold/hot traces, this is a good
definition, </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">potential</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">behaviors!
</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">For
multiple concurrent executions, a traversal may choose to replace the
asterisk by any positive number of parallel executions—that is, by
a term with any number of par operators. &nbsp;← how about if you
have “n” parallel executions in the design?</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">As
is usual, we define parallel edges by interleaving. ← wtf? why?</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
novelty of the algorithm, over that of previous synthesis algorithms,
is as follows:</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">-
A range of sequence diagram interaction operators, namely alt, opt,
seq, par, neg, all, exist are included in the algorithm. Previous
algorithms have generally been limited to basic sequence diagrams
without interaction fragments</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">-
Additional IOD constructs are taken into account, namely preemption,
suspension, multiple concurrent executions, flow final nodes, and
negation scoped over IOD nodes.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">-
The generated state machines incorporate hierarchical states and
orthogonal regions.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Note
that a sequence diagram without interaction fragments composes its
messages using weak sequential composition. This is equivalent to
having a single seq fragment surrounding the entire sequence. Hence,
we consider the case for seq fragments here. ← ppt?</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
algorithm generates a HFSM for each participant in the sequence
diagram. It starts by creating an empty HFSM for each participant.
Then, for each participant, O, its HFSM is constructed by proceeding
vertically down the participant’s lifeline and creating new states
and transitions in the HFSM as messages (and state invariants) are
encountered. A message m directed away from O to another object
becomes an action, !m, in the HFSM for O to send that message to the
target object. A message directed toward O becomes a triggering
event, !m, in the HFSM and results in a new transition. If a state
invariant is encountered, a named state is created, where the state
has the same name as the state invariant. All references to the state
invariant result in a transition to this named state. If a state
invariant is reached and the corresponding named state already
exists, a transition is created to this state. Otherwise, a new named
state is created. ← ftw good algorithm for converting into a SM!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">This
straightforward algorithm ensures that all traces in the sequence
diagram are also traces of the generated HFSM. There could be
additional traces in the HFSM not present in the sequence diagram.
These are the so-called implied scenarios [Uchitel et al. 2001] and
are a well-known issue for this type of synthesis algorithm. Implied
scenarios arise because the global behavior in</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">sequence
diagrams must be distributed across a set of objects, each with local
behaviors. It is not generally possible to avoid implied scenarios
unless all objects agree to synchronize. However, such a solution
would be inefficient or may not even be implementable. Therefore, we
do not enforce synchronization in this paper but leave implied
scenarios as a recognized issue that is being dealt with by other
authors.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">A
par fragment is handled by introducing an orthogonal region into the
generated HFSMs. This preserves the sequence diagram traces because
the UML semantics for orthogonal regions is interleaving of events
from different regions. For an opt fragment (see Figure 12), two
branches are created in the generated HFSMs—one for the optional
messages and one for mandatory messages. Note that, if the opt
fragment is followed by additional messages, these messages will
appear in both branches. Hence, in Figure 12, m2 appears in both the
optional and mandatory branches. This correctly captures the
semantics of opt. An alt fragment is handled simply by introducing a
branch in the generated HFSMs.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Figure
14 illustrates an example for neg. The construction is similar to the
case for opt in that two branches are created—one for the positive
behavior and one for the negative behavior. The negative behavior
results in a branch containing error states. Similarly to opt, if the
neg fragment is followed by additional messages, according to the neg
semantics, these messages form part</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">of
the negative trace and so appear in both branches. In Figure 14,
according to the semantics of neg (as defined in Section 2.2.6),
there are three negative traces: a trace from just the neg fragment,
and two traces from joining the neg fragment with what follows it. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Parallel
fork/join edges lead to orthogonal regions in the generated HFSMs.
Since fork/join edges are well nested, there is no ambiguity in
deciding where the orthogonal regions should be placed</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Negative
edges result in orthogonal regions in the generated HFSMs. Negation
is handled by monitoring for the negative events and transitioning to
a special error state if they occur. The negative events under
monitor are placed into an orthogonal region so that, if the sequence
of negative events ever occurs (even with other events interleaved),
then the error state will be entered. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">It
is also important to note that the generated HFSMs are highly
nondeterministic—in that the HFSM for a in Figure 21 autonomously
decides to send any number of m1s. This, of course, results in an
infinite stream of m1s. Developers typically require more control
over such nondeterminism. However, to maintain consistency with the
EIOD semantics, we expect that the HFSM simulator would provide an
option to control nondeterminism if so required. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
algorithm is compositional in the sense that combinations of edges
and/or fragments are translated by applying the synthesis rules
recursively. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">UCSIM
is implemented as an Eclipse plug-in and EIODs can be created using
IBM Rational Software Modeler (RSM) using standard UML notations and
stereotypes where necessary. Although UCSIM currently works with RSM,
it is designed in a vendor-independent way and can be adapted to
other modeling tools in a relatively straightforward manner. UML
deliberately marks some semantic decisions as semantic variation
points. These variation points can be defined differently by
different tools. This can cause problems because a state machine
designed and tested in one tool may not behave identically in another
tool. To help alleviate this problem, the user can configure the
semantic variation points in CSMS and the execution of the state
machine then changes to match the new semantic definition.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">These
examples demonstrate (1) that </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">realistic
specifications can be captured using EIODs and that our extensions
are useful in practice</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">,
and (2) that readable HFSMs can be generated for realistic examples.
← </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">for
ppt: realistic specifications can be captured?</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
first is a weather update subsystem of an air traffic control system
developed at NASA [Denery et al. 1997]. The illustrative example used
earlier in this article is a much simplified version of this
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">subsystem.
This particular example was used in an earlier article on synthesis
[Whittle et al. 2005b]. Our particular contribution here is that we
were able to use the extended features of EIODs to </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">generate
hierarchical state machines for the example. We gave the same
scenarios as were used in Whittle et al. [2005b]. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">However,
in Whittle et al. [2005b], heavy use of state invariants was made to
connect scenarios together.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
essence, each sequence diagram used state invariants to label the
states at the beginning and end of the sequence, and these state
invariants were used to “paste together” the sequences. State
invariants were also used within sequences to mark where, for
example, a scenario was interrupted by another. This worked but did
require the modeler to provide these state invariants. The constructs
of EIODs provide a more elegant solution. The examples showed that
the three-level structure of use case charts allow a wide range of
behavior to be specified in a controllable way. If UML sequence
diagrams alone had been used to capture the same information, the
number of modeling elements needed would have been at least an order
of magnitude larger. Indeed, it would have been extremely difficult
if not impossible to capture some of the more complex behavior, such
as preemption. Simply specifying the examples, of course, does not
provide any evidence of how easy it is to develop the use case chart,
nor how readable the generated HFSMs are. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Scalability
and Usability. The three case studies conducted so far were of a
reasonable size. As an indication, the shuttle system consisted of 7
use case nodes (level 1), 10 scenario nodes (level 2), an average of
7.2 participants per sequence diagram, 23 interaction fragments, and
144 messages. There were seven state-dependent objects for which
HFSMs were generated. This resulted in a total of 117 generated
states, four of which were composite states and nine of which were
orthogonal regions. The studies showed that the new relationships in
EIODs—preemption, suspension, negation—were used infrequently but
their application was crucial when used. This is to be expected. One
would not expect, for example, preemption to be used as frequently as
simple control flow. ← for ppt</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Even
for examples of medium size such as these, three factors were found
to be crucial in making the generated HFSMs readable. First, the use
of composite and orthogonal regions was essential. Hierarchical
states allow the result to be viewed at different levels of
abstraction. &nbsp;</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">importance
of hierarchy is a key point. It is relatively straightforward to
generate flat state machines that have equivalent behavior to an
EIOD. In fact, this is basically the approach taken by research that
defines the semantics of IODs in terms of automata or Petri Nets
(see, for example, Grosu and Smolka [2005]). &nbsp;</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Such
approaches are fine for a formal semantics definition or for when the
result is not meant to be human-readable, but if the generated state
machines are to be used in further development, readability is
critical. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
formal semantics of EIODs have no problem in interpreting such cases,
but, in general, branches that are not well nested are not supported
by UCSIM yet. However, the general solution is still under
investigation. ← for ppt</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Methodological
Considerations. Our experiences with UCSIM raise a number of
methodological considerations. We do not yet offer any in-depth
guidelines on how to construct EIODs. In fact, there are very few
works in the literature that address how best to use IODs. This is an
especially important consideration when synthesis is being used,
because the structure in the EIODs has a direct effect on the
structure generated in the HFSMs. In Whittle et al. [2005a], we
offered some initial hints on how to define a process for analyzing
requirements with EIODs. ← for future work, use/cite this article,
it’s actually one of the few that uses IODs.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Currently,
users of UCSIM must develop a complete EIOD in order to generate
HFSMs—in the </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">sense
that, if a scenario S2 follows S1 and if a scenario S4 follows S3,
then the user must also specify a relationship between S2 and S3.
Otherwise, there is not enough information </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">for
UCSIM to decide how flow continues after S2. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">At
the level of requirements analysis, specifying such detailed
information could be overly restrictive. It would be interesting to
investigate synthesis based on partial information. This could lead
to nondeterminism in the generated models but could be a useful way
of supporting exploration of requirements.</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
← </SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">for
ppt, for future work also!</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">There
have been many papers on synthesizing state machines from
scenariobased notations such as UML sequence diagrams [Whittle and
Schumann 2000], message sequence charts [Kruger 2000; Uchitel et al.
2003b], and LSCs [Harel et al. 2005]. See Saiedian et al. [2005] and
Amyot and Eberlein [2003] for recent surveys on this topic. For the
most part, these works have considered a more limited set of scenario
relationships than are considered in this article. The algorithm in
Uchitel et al. [2003], for instance, takes into account simple
control flow given in a hMSC but does not consider parallelism or
preemption.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">One
key distinguishing feature between these synthesis algorithms is how
they decide on the relationships between different scenarios. There
have been two broad classes of approaches—to derive the
relationships or to assume that the user provides relationships
explicitly. In the former case, the user may specify a set of
unconnected scenarios. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Approaches
to specifying scenario relationships explicitly differ in the amount
of detail they expect from the user. At one end of the scale are
approaches that use state invariants to label the start and end
points of each scenario. Other approaches (e.g., Som ́ [2005];
Whittle and Schumann [2000]) derived relationships from formally
defined pre- and postconditions on scenarios. Once again, these
approaches require a significant additional modeling effort from</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">the
user. ← for ppt: we like to keep it as simple as possible in this
case.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">To
the authors’ knowledge, there is no existing synthesis algorithm
that takes into account as wide a range of relationships as in this
article. We have seen no previous algorithms that incorporate
preemption, suspension, scoped negation, and parallelism. ← do we
really need preemtion? </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
algorithm in Harel et al. [2005] also makes the perfect information
hypothesis, that is, that</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><U><SPAN STYLE="background: transparent">
</SPAN></U></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">each
object synchronizes with all other objects when an event is received.
Although this does alleviate the problem of implied scenarios—which
occur because an object’s local view of the system state, as
captured in the generated FSM, is insufficient to enforce the global
view captured in the scenarios</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">—</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">it
appears to be overly restrictive and does not lead to efficient or
modular implementations. ← for ppt!</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Currently,
simulation is done at the state machine level. This is advantageous
because it allows the user to examine each subsystem independently.
However, for stakeholders not familiar with state machines, the
results of the simulation may be difficult to understand. We plan on
implementing a visualization tool on top of UCSIM so that the
simulation results can be viewed using graphical icons which are much
closer to the domain language of requirements engineers. In addition,
one could investigate simulation of the scenarios directly without
first translating to state machines. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">So
far, research has focused on technical issues such as how best to
derive connections between scenarios or how best to ensure the
correctness of the transformation. We feel the time is ripe for these
algorithms to be put through their paces and to undertake in-depth
studies on how they can most effectively support software engineers ←
for ppt, actually, by using the simulator of mcrl2, you’re
basically a creating an executable specification...that’s pretty
intuitive (contains object/class/method call, poseible steps)
important for modeling, otherwise it’s like coding without
compiler.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
currently generate HFSMs with error states for negative scenarios.&lt;--
see how?</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">DETECTING
EMERGENT BEHAVIOR IN DISTRIBUTED SYSTEMS USING SCENARIO-BASED
SPECIFICATIONS</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">An
effective approach for the design of distributed systems is to
describe system requirements using scenarios. A scenario, commonly
known as a message sequence chart or a sequence diagram, is a
temporal sequence of messages sent between system components.
However, scenario-based speci ̄cations are prone to subtle de
̄ciencies with respect to analysis and validation known as
incompleteness and partial description. In this research, a method
for detecting emergent behavior of scenario-based speci ̄cation is
proposed. The method is demonstrated and veri ̄ed using a
mine-sweeping robot as an example A widely accepted model for
behavioral modeling of individual system elements is the state
machine. Several studies have already been conducted to facilitate
the procedure of converting a set of scenarios to a behavioral model
expressed by state machines [3À10]. In the synthesis process, one
state machine will be built for each system element. The state
machine includes all the messages that are received or sent by that
element. Then the behavior of the distributed system is described by
the product (parallel execution) of all the state machines of the
system elements.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
[8] an algorithm for safe realizability is proposed but there is no
method to directly check whether implied scenarios exist in the &nbsp;̄rst
place. In other words, so far there is no formalized and precise
representation for the cause of implied scenarios, so that by
capturing that cause during the design phase, emergent behavior can
be detected and removed. A main contribution of this paper is to give
a de ̄nition for indeterminism in behavior of distributed systems,
so that by identifying indeterminism, one can detect the potential
emergent behavior.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">ppt:
still a lot of emergent behavior in distributed systems, that is not
explicitly modeled with the scenarios (because of the partial order
of events, partial view of the system interactions within a scenario)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Although
MSCs and sequence diagrams vary in notations, they are both capable
of representing scenarios in an e±cient and intuitive manner. In
this research the prime focus is on MSCs. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">There
are several reasons for choosing MSCs over sequence diagrams in this
research. First, the notation of MSCs is simpler than sequence
diagrams; which comes as no surprise as sequence diagrams are
utilized in object oriented design [2, 24]. Sequence diagrams include
additional notations to support illustrating the design.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Recall
that upon building the behavior model of a system component,
different states of the model need to be identi ̄ed. This is a very
crucial step and in fact it is where the methodologies di®er from
one another. This step is important since the detection of emergent
behavior is a direct result of &nbsp;̄nding identical states in
behavioral models. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">OCL
is part of the UML standard and is a side-e®ect free and set-based
constraint language [25]. The OCL specifīcations include the
declaration of state variables. A state variable represents some
important aspect of the system such as whether or not a component is
coordinating with other components. Moreover the OCL speci ̄cations
enable the detection of con°icts between di®erent scenarios and
allow scenarios to be merged scenario-based speci ̄cation is an
e±cient and e®ective way to represent system requirements for
distributed systems. However as each scenario only partially
describes system's behavior, scenario based speci ̄cations are
subject to deficiencies such as incompleteness and contradictions.
Thus having a methodology which can systematically discover system
design errors prior to implementation is most beneficial and will
lead to huge savings in time and cost. In this section, the &nbsp;̄rst
part of this systematic approach, which is the synthesis of state
machines from message sequence charts is described. As demonstrated
in the previous section, by assigning state values based on semantic
causality, the basis for comparing states and consequently
discovering identical states is established. A goal in this research
is to identify possible design flaws that might lead to runtime
problems in distributed systems by analyzing the system speci ̄cation
expressed by scenarios. Unfortunately, manual review may not
e±ciently detect all the design °aws due to the scale and
complexity of the system. In this research we have provided sound
techniques to automate the speci ̄cation and design review of the
distributed system and detect a subset of unwanted run time
behaviors, including implied behaviors.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
this paper, we provided a method to identify the exact cause of
implied scenarios, so that by capturing it, implied scenarios can be
detected and removed. This method is novel in the sense of
formalization of the cause of implied scenarios. Furthermore, this
technique can be modi ̄ed to take the UML's sequence diagrams as
input and thus incorporate the analysis and design of distributed
object oriented systems.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Facilitating
the Construction of Specification Pattern-based Properties (2005)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Formal
specification languages are often perceived as difficult to use by
practitioners, and are therefore rarely used in industrial software
development practices. Numerous researchers have developed
specification pattern systems to facilitate the construction of
formal specifications of system properties. Feedback indicates that
these patterns are considered helpful, but many practitioners prefer
capturing properties using informal notations, such as natural
language, instead of formal specification languages. This paper
describes a project that addresses this technology gap. First, we
introduce a stepwise process for deriving and instantiating system
properties in terms of their natural language representations. The
key components of this process are structured natural language
grammars and specification pattern systems. Second, we describe S
PIDER, a prototype implementation of a tool suite supporting this
specification process. Temporal logics, in particular, real-time
temporal logics, are often perceived by practitioners as difficult to
understand and apply. Feedback from industrial collaborators
indicates that, typically, only developers with extensive training in
formal methods are inclined to make use of temporal logics. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">To
promote the use of formal specification techniques, we previously
developed real-time</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">specification
patterns [19] to be used in combination with the already established
qualitative specification patterns by Dwyer et al. [8].</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
order to further enhance the accessability of these specification
patterns and their analysis tools, this paper introduces a
syntax-guided approach to deriving and instantiating qualitative and
real-time specification patterns in terms of their natural language
representations.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Specifically,
the domain experts use natural language to capture appropriate
properties identified for a given domain. The formal methods experts
decide how to best represent these properties in terms of appropriate
target specification languages. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Overall,
our approach combines the completeness of a pattern system for
specifying qualitative and real-time properties with the
accessibility of a natural language representation. ← the essence
of the work</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Dwyer
et al. [8] developed several patterns applicable to software
properties specified in different formalisms, such as LTL [23],
computational tree logic (CTL) [5], graphical interval logic (GIL)
[32], and quantified regular expressions (QRE) [28]. Specification
patterns are categorized</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">into
two major groups: occurrence patterns and order patterns. While a
given specification pattern may have several scopes of applicability
(e.g., globally, before an event/state occurs, after an event/state
occurs), the original specification patterns do not include timing
information. Therefore, we refer to the specification patterns by
Dwyer et al. as qualitative specification patterns as they specify
qualitative properties that are not amenable to quantitative
reasoning about time.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
our preliminary work with requirements of embedded systems, it became
clear that many of the requirements were often timing-based, which
could not be specified in terms of Dwyer et al.’s specification
patterns. Using our specification approach, the user follows a
step-wise process to derive a structured natural language sentence
capturing the requirement. This sentence can then be instantiated
with UML model elements (from Figure 1) and then be mapped to a
temporal logic formula in the specification pattern system.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Mapping</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">:
Map the instantiated natural language sentence to the temporal logic
required by the targeted formal validation and verification tool and
analyze.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Currently,
SPIDER includes a grammar and specification patterns for the
specification patterns by Dwyer et al. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">[8],
as well as a grammar and specification patterns for an extended
specification pattern system (used in this paper) that also includes
our real-time specification</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">patterns
[19]. ← find it??</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Figure
5 shows a screen capture of </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">the
Property Instantiator. The Sentence instantiation field</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">contains
elements that are used to instantiate the derived natural language
sentence. The Property Instantiator extracts model-specific
information from formal system models (displayed in the Current model
elements fields). To accomplish this task, the Property Instantiator
potentially uses several Formal Model Interpreters, each of which has
the ability to read a certain input format of a formal model. These
elements can be inserted into boolean propositions to be used in the
placeholder variables of a property. Next, the Property Instantiator
is used to replace P and S with boolean propositions describing the
appropriate states. SPIDER displays all the classes, with
accompanying signal, state, and variable names, from the system
model. In</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">this
case, we are interested in the variables of the Fault-Handler and
MalfunctionIndicatorLight classes...This instantiated sentence can
then be mapped to a temporal logic representation. The following
temporal logic property, automatically generated by SPIDER, denotes
the LTL representation of the property captured in natural language
in Expression (6), which can be analyzed by the model checker Spin
Fantechi et al. [9] use natural language constructs that map directly
into ACTL, an action-based variant of CTL. User input is used to
resolve ambiguities that might be encountered in the input phrase.
While this approach is directly related to ours, it restricts the
source language according to the structure of the targeted temporal
logic</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Smith
et al. developed Propel [35], where they extended the specification
patterns by Dwyer et al. [8] to address important and subtle aspects
about a property, such as what happens in a cause-effect relation if
the cause recurs before the effect has occurred. These extended
specification patterns are specified in terms of finite-state
automata instead of temporal logic formulae. ← find? “An approach
supporting property elucidation”</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Mondragon
et al. developed a tool called Prospec [26] for the specification of
properties based on Dwyer et al.’s specification patterns. The tool
offers assistance in the specification process and extends the
specification pattern system by Dwyer et al. with compositional
patterns. Differing from our tool suite, they do not include support
for natural language representations or real-time information. ←
find this also!!! “Supporting elicitation and specification of
software properties through patterns and composite propositions” </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
idea is that instead of structured natural language templates, I
offer SD templates. Or maybe not? </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">PROPEL:
An approach supporting property elucidation (2002) ← !!! Important,
VERY!!)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Property
specifications concisely describe what a software system is supposed
to do. It is surprisingly difficult to write these properties
correctly. There are rigorous mathematical formalisms for
representing properties, but these are often difficult to use. No
matter what notation is used, however, there are often subtle, but
important, details that need to be considered. PROPEL aims to make
the job of writing and understanding properties easier by providing
templates that explicitly capture these details as options or
commonly-occurring property patterns. These templates are represented
using both &quot;disciplined&quot; natural language and finite-state
automata, allowing the specifier to easily move between these two
representations. These properties may be written in a number of
different specification formalisms, such as temporal logics,
graphical finite-state machines, or regular expression notations,
depending on the finite-state verification system that is being
employed. Although there are sometimes theoretical differences in the
expressive power of these languages, these differences are rarely
encountered in practice. A serious problem that is frequently
encountered in practice, however, is expressing the intended behavior
of the system correctly. Even though properties usually focus on some
restricted aspect of a system's behavior, it is still surprisingly
difficult to capture this behavior precisely</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Recent
work on property patterns [8-10] recognized that the properties used
in formal verification often map onto one of several basic property
patterns. These patterns can be instantiated with specific events or
states and then mapped to several different formalisms. When we tried
to employ these property patterns to represent some actual natural
language requirements, however, we found that they were not adequate.
They failed to represent some of the subtle differences in
interpretation that we encountered. In the work presented here, we
build upon the property patterns in several important ways. First, we
extend the patterns so that they are represented by pattern
templates. Thus, instead of just parameterizing the pattern in terms
of the events or states, we extend the patterns with alternative
options that are explicitly shown to the specifier. Second, we
represent these pattern templates using two different notations: an
extended finite-state automaton (FSA) representation and a
disciplined natural language (DNL) representation. Third, the
instantiated FSA representation is mathematically well-defined and
thus can be used as the basis for verification, as well as for
testing the acceptance of event sequences. Although the input
formalisms of the various finite-state verification tools, such as
the temporal logics LTL and CTL [3] are very expressive, Dwyer et al.
observed that nearly all the properties found in the finite-state
verification literature could be classified into a small number of
basic types, and suggested that a collection of patterns, which they
described as &quot;high-level, formalism-independent, specification
abstractions,&quot; could assist finite-state verification
practitioners in formulating most of the properties they wanted to
check.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Each
of the patterns describes an </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">intent</SPAN></I></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">(the
structure of the specified behavior), a </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><I><SPAN STYLE="background: transparent">scope</SPAN></I></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">(the
extent of program execution over which the pattern must hold),
mappings into the input formalisms for some finite-state verification
tools, examples of known uses, and relationships to other patterns.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">[good
overview of the paper...]</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
specifier who wishes to modify a pattern, however, must have
significant expertise with the particular specification formalisms
utilized by the finite-state verification tool being applied. Indeed,
the property patterns themselves do not highlight the choices made
and the notes do not attempt to point out all plausible
modifications. It is assumed that the analyst who wants to verify a
particular property can identify the ways in which it might differ
from the particular forms in the property pattern system and, with
some assistance from the notes, make the necessary modifications.
Since the target audience for the property patterns system is users
of finite-state verification tools, and expertise with the
specification formalisms is a prerequisite for effective use of such
tools, this is not an unreasonable requirement. In our previous work
with finite-state verification systems, we have found that
finite-state automata, with their corresponding graphical depictions,
are some of the more accessible notations for representing
properties. We have also observed that many of the &quot;shall&quot;
phrases found in requirements and specification</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">documents
seem to almost take on a template form. Thus, we wanted to see if we
could marry these two notations via the property patterns. While the
property pattern work included both state- and event-based
formalisms, here we assume an event-based formalism.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
property pattern template is fully instantiated when all the optional
choices have been resolved and partially instantiated if only some of
the options have been resolved. An optional transition in an FSA
template will either resolve to a regular transition or it will not
exist in the instantiated property. A multi-label on a regular
transition will resolve to only one of its label choices in the
instantiated property. A multi-label on an optional transition will
resolve to at most one of its label choices; an optional transition
disappears if all of the label choices in its multi-label have been
eliminated from consideration. An optionally accepting state will
either resolve to an accepting state or a non-accepting state. After
fully instantiating an FSA template by resolving all of the options,
the specifier is left with an FSA property.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
illustrate how a property pattern is represented as an FSA template
using the Response pattern. As noted above, the Response pattern is
concerned with expressing the concept of a stimulus event that must
be followed by a response event. An example of this property pattern
as written in natural language might look something like this: After
the elevator button is pushed, the elevator closes its doors.
Questions arise: for example, should the doors close repeatedly if
the button is pushed repeatedly? What, if anything, is allowed to
occur after the button is pushed, but before the doors are closed? We
find that these questions can be captured by using the extended FSA
property notation with six options. These options in the Response
pattern template combine to produce a total of sixty-four distinct
variations on this property pattern. When all of the options have
been decided, an FSA that represents only one of the sixty-four
possible variations is created. The six Response pattern template
options are as follows: </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Pre-arity,
which determines whether action may occur one time or many times
before response does; Post-arity, which determines whether response
may occur one time or many times after action does; Immediacy, which
determines whether or not other intervening events may occur between
action and response; Precedency, which determines whether or not
response is allowed to occur before the first occurrence of action;
Nullity, which determines whether or not action must ever occur; and
Repeatability, which determines whether or not occurrences of action
after an occurrence of response are required to be followed by
response. Since we assume that the alphabet may include more events
than just action and response, Immediacy deals with whether or not
these other events may occur at the second state. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Figure
2</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">shows
the other FSA templates developed for PROPEL, based on the property
patterns proposed by Dwyer et al. These three patterns and the
Response pattern are the basic patterns that do not use any
composition to express their concepts. The first pattern, Precedence,
states that an action cannot occur until it has been preceded by the
enable event. The second pattern, Existence, states that action must
occur in the system execution. The last pattern, Absence, states that
action must not occur in the system execution. Note that the Absence
FSA template does not have any options. ← see figure 2, very
useful!</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">During
the process of instantiating an FSA template, the specifier must
define the alphabet and associate the appropriate events with their
related pattern parameters. The FSA template structure is designed to
assist the specifier in asking and answering the appropriate
questions and in understanding the meaning of the decisions that are
made. The specifier instantiates a property pattern template until
all of the options have been resolved and anFSA property
representation results.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">DNL
is a restricted subset of natural language that is intended to
capture meanings unambiguously. This representation is not intended
to stand by itself; it is meant to be used in conjunction with the
FSA template representation. Like FSA templates, DNL templates are
designed to elucidate the decisions associated with a property
pattern. Therefore, the same options that must be decided in the FSA
template are options in the DNL template representation. A
fially-instantiated DNL template results in a paragraph of natural
language text that is grammatically correct, readable, and maps to
one, and only one, fully-instantiated FSA property. The relationship
between the options in a pattern's DNL template and those in a
pattern's FSA template is not necessarily one-to-one, however, since
some DNL options affect the FSA templates in more than one location.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">So
far, we have discussed how to develop the intent (the structure of
the behavior specified) of a property. In this section, we discuss
the definition of a scope and how it is applied to the property</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">pattern
template. As mentioned above, the patterns of Dwyer et al. have
scopes that describe the extent of system execution over which the
pattern must hold. For example, a specifier might want to say:
Between pushing the button and arriving at the requested floor, the
elevator does not change direction.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">A
scope can be used to specify when it is important that the property
holds. ← future work!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Dwyer
et al. identified five basic scopes and defined whether the scope was
closed or open on either end for each pattern. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Most
event-based formalisms use some version of an interleaved model of
concurrent computation. In such formalisms, two events cannot
coincide.</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">In
the property patterns system, therefore, event-delimited scopes are
open at both ends; an event that occurs within the scope cannot occur
at the same time as an event that marks the beginning or end of the
scope. We make the additional restrictions that the set of delimiter
events defining the scope is disjoint from the alphabet of the FSA
defining the intent and that, if the scope has both starting and
ending delimiters, these are distinct. These restrictions seem
reasonable and greatly simplify the application of a scope to an
intent. Thus, the five basic scopes become: </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Global</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">,
which is over the entire system execution. This scope does not have
delimiters, and it is not repeatable; </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Before
P</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">,
which is concerned with the event sequence up</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">to
the first occurrence of P. This scope only has a ending delimiter,
and it is not repeatable; </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">After
Q</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">,
which is concerned with the event sequence after the first occurrence
of Q. This scope only has an starting delimiter, and it is not
repeatable; </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Between
Q and P</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">,
which is concerned with the event sequence after an occurrence of the
starting delimiter, Q, and before an occurrence of the ending
delimiter, P. P is required to occur for this scope to exist. This
scope may occur repeatedly over the course of the system execution;
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">After
Q Until P</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">,
which is concerned with the event sequence after an occurrence of the
starting delimiter, Q, and before an occurrence of the ending
delimiter, P. P is not required to occur for this scope to exist.
This scope may occur repeatedly over the course of the system
execution; </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">A
scope can be applied to an intent by adding additional states that we
call &quot;scope states&quot; and by adding transitions between the
scope states and the states of the FSA that represent the intent.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
the remainder of this section, we explain the additions needed to
apply each scope to the Response pattern. Scopes are added to the
intents of the other property patterns in much the same way. We
interpret the Before P scope to mean that the scope begins at the
start of the program execution, so there is no starting delimiter,
and that the ending delimiter is the first occurrence of P in the
program execution. Subsequent occurrences of P are ignored since this
scope is not repeatable. When we apply the Before P scope to the
intents, we must determine at each state what the effect will be of
encountering the ending delimiter at that point in the sequence.
Recall that the intent of the Response property is that an occurrence
of action must be followed by an occurrence of response. An
occurrence of P results in a scope that has been ended before the
intent of the property has been entered. This is called an empty
scope. An empty scope is handled differently for each of the property
patterns. For instance, the Absence property holds if the scope is
empty, since that is actually the meaning of the Absence property</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">pattern.
Whether or not a Response property holds if the scope is empty,
however, depends on the setting of the Nullity option, which
determines whether or not action must occur at all. If action is not
required to occur, then the first state, which is also the start
state, will be an accepting state. If P occurs at this point and
action is not required to occur, then this sequence is not a
violation of the property and the empty scope does not prevent the
property from holding. When the FSA is in the second state, an action
has occurred that is not yet followed by a response. At this point,
response must occur before a P ends the scope, or the property is
violated. An occurrence of P when the FSA is in the second state
therefore puts the FSA into a non-accepting trap state (not shown!).
&nbsp;We interpret the After Q scope to mean that the scope is not
started until the first occurrence of the starting delimiter, Q, in
the system execution. Subsequent occurrences of Q are ignored since
this scope is not repeatable. The scope is not ended until the
execution ends, so there is no ending delimiter. As with the Before P
scope, when we apply the After Q scope to the intents, we must
determine at each state what the effect will be of encountering the
ending delimiter at that point in the sequence. An occurrence of Q at
this (first!) state would begin the scope and after this point the
intent of the property would be required to hold. As is shown with
the self-loop that is labeled &quot; ~ Q &quot; on state 1, all
events that occur before the starting delimiter are ignored. An
occurrence of Q at any of the other states would have no effect on
the property, because after the occurrence of the starting delimiter
all subsequent occurrences of Q are ignored. We interpret the After Q
Until P scope to mean that the starting delimiter is an occurrence of
Q and the ending delimiter is an occurrence of P. This scope can be
repeated; whether or not it is repeatable is an option for the
specifier to determine. For now, consistent with Dwyer et al., we
assume that a scope with multiple occurrences of Q is ended by a
single occurrence of P. Given this interpretation, when we apply the
After Q Until P scope to the intents we must determine at each state
what the effect will be o f encountering the ending delimiter at that
point in the sequence. An occurrence o f Q at this (first!) state
would start the scope and after this point the intent o f the
property would be required to hold. As is shown with the self-loop
that is labeled &quot; ~ Q &quot; on state 1, all events that occur
before the starting delimiter are ignored. An occurrence o f P at
state 1 would also be ignored, since an occurrence of Q has not yet
started the scope. The Between Q and P Scope is identical to the
After Q Until P scope except for one important difference. Figure 5d
shows the difference: state 3 is accepting. The reason for this
change is that the definition of the Between Q and P scope requires
that both delimiters occur, whereas the After Q Until P scope does
not. The Between Q and P scope does not exist unless both o f its
delimiters occur. What this means is that if P does not occur, the
intent of the property could be violated and yet the property as a
whole would not be violated because it is not within an existing
scope when the violation happens. &nbsp;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
PROPEL approach described in this paper builds directly on the
property patterns. </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">For
instance, these patterns form the basis of the extensible
specification language in the Bandera system [5, 6], and Paun and
Chechik [23] have extended the patterns to deal with events in a
state-based formalism. ← how about dealing with states in an
event-based formalism? for future work</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">With
PROPEL, users are provided with templates for the most common
property patterns described in Dwyer et al. These templates are
presented in an extended finite-state automaton notation and as
natural language phrases, both of which explicitly indicate the
options that must be considered. We hypothesize that this two-pronged
approach will help specifiers elucidate the precise meaning of the
properties that they are expressing. We are currently implementing
the PROPEL system so that specifiers are presented with both
notations and can move between them while instantiating the property
templates incrementally. We believe that this approach is an
effective way to achieve both accessibility ← todo!! FIND
IMPLEMENTATION </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; line-height: 114%"><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">(</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><A HREF="http://laser.cs.umass.edu/tools/propel.shtml"><SPAN STYLE="font-variant: normal"><FONT COLOR="#1155cc"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">http://laser.cs.umass.edu/tools/propel.shtml</SPAN></B></U></SPAN></FONT></FONT></SPAN></FONT></SPAN></A><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="font-weight: normal"><SPAN STYLE="background: transparent">
← </SPAN></SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">java
bljak)</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Although
we have applied this approach to several properties and been pleased
with the results, we need to undertake a careful evaluation. ← for
ppt!</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">From
UML 2 Sequence Diagrams to State Machines by Graph Transformation
(2011) ← find the actual toolset, if there is one?</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">This
paper explores how we can specify graph transformation-based rules
for a classical problem of transforming from sequence diagrams to
state machines. The specification of the transformation rules is
based on the concrete syntax of sequence diagrams and state machines.
Although sequence diagrams and state machines are used in different
phases and are made with different diagram types, there is a great
deal of overlap between the two specifications. The behavior defined
by the sequence diagrams should also be recognized as behavior by the
state machines.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">There
has been a lot of efforts to transform from sequence diagram-like
specification languages to state-based languages (e.g. [KGSB99, WS00,
ZHJ04, Sun07]). None of the previous approaches takes full advantage
of the combined fragments that were introduced in UML 2. ← main
point why it should be done</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Our
approach differs from the traditional model and graph transformation
approaches, where transformations are specified in relation to the
abstract syntax. We claim that concrete syntax-based rules are more
user-friendly since the specifier does not need to have knowledge of
the metamodels and the associated abstract syntax. This is
particularly useful for sequence diagrams where the abstract syntax
is complicated and quite different from the concrete syntax. We
introduce a fragment operator that allows us to specify the matching
and transformation of combined fragments with an unknown number of
operands. Our rules are mapped to traditional graph transformation
rules and the transformation takes place in the AGG tool.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">In
this paper we only use sequence diagrams with asynchronous messages,
although our transformation apparatus works for both synchronous and
asynchronous messages. Asynchronous messages fits nicely with the
event-based nature of state machines, unlike sequence diagrams with
synchronous messages that have a procedural nature. We omit the
optional rectangles to visualize when a lifeline is active, since
these are more relevant for synchronous messages. ← tja....</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
set of sequence diagrams describing a system will normally have a
non-empty set of inconclusive traces, which we call a partial
specification. An actual implementation may choose to implement the
inconclusive traces as either positive or negative. A state machine
on the other hand, has no inconclusive traces and is thus a complete
specification.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Generate
State Machine. Our automated generation sd2sm, in step 3, makes a
state machine that accepts all positive traces from the sequence
diagrams. Inconclusive traces are not implemented, and these traces
become negative. Hence, step 3 performs a negative supplementing. We
provide the known formal foundation of algebraic graph
transformation...[definitions, graph morphisms...injective
mappings..]</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Graph
transformation rule consists of three graphs: LHS (left hand side),
Interface (I) and RHS. And a pair of injective graph morphisms. In
the graph transformation rules throughout this paper we only
explicitly display the LHS and the RHS graphs, while the interface
graph is given by shared identifiers of elements in the LHS and the
RHS/NACs. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">In
this section we present the transformation rules, and we show how the
rules gradually</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">transform
from a sequence diagram into state machines. ← rules gradually
transform an SD into a set of process descriptions..</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Each
lifeline corresponds to a state machine. When producing a state
machine, it is sufficient to look at the single corresponding
lifeline with its events and how these events are structured within
the combined fragments. A prerequisite to this claim is that each
lifeline occurs only in one sequence diagram.. The rule Alt in Figure
10a pops an alt fragment and makes the current state into a composite
state by adding internal behavior: an initial state, an Idle state
and a final state. For each alt operand we make an inner composite
state. We produce a transition from the Idle state to each inner
composite state, where the transition guard is equal to the
corresponding alt operand guard...When we have mapped and removed all
events from a lifeline, then we use a rule called FinalState (Figure
11a). The rule replaces the current state (indicated by the state
edge) by a finalnode. We have now reached a state machine
corresponding to the GasPump lifeline. It is possible to optimize the
produced state machine by flattening some of the composite states.
For our example we need three flattening rules which are shown in
Figure 12a-c. The FlattenIntoChoice rule flattens the composite state
holding all the internal choices corresponding to the alt operands.
We are able to flatten the state by introducing a choice node with
outgoing branches to the choices and finally a merge node with
incoming branches from all the choices. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
Loop rule (Figure 13a) makes the current state into a composite state
with an idle state inside. The GasPump lifeline of the loop operand
gets a state-labeled edge to the idle state. Furthermore, the
composite state has a reflexive transition with the guard condition
taken from the looping condition of the loop operator. A transition
with a negated loop guard leaves the composite state into a newly
created state, which becomes the current state of the remaining
sequence diagram. The Par rule (Figure 13b) makes the current state
into a composite state with one region state machine for each par
operand. These region state machines each have an idle state that
becomes the current state of the sequence diagram of the
corresponding par operand. &nbsp;</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
transformation rules are implemented in the graph transformation tool
AGG. The transformation is tested on some examples, including the
GasPump example shown in this paper, with success. The AGG tool only
supports abstract syntax rules, and we have manually translated from
concrete syntax to abstract syntax rules. We have also used multiple
collection free rules to simulate each rule with collection operators
by following the algorithm defined in [GKMP09]. This paper defines
semantics for concrete syntax-based rules of sequence diagrams which
can be used to automate the translation to abstract syntax rules, as
we have implemented previously for activity models [GMP08]</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Ziadi
et al. [ZHJ04] define their transformation by pseudocode operating on
algebraic definitions of sequence diagrams and state machines, while
our transformation is based on graph transformation. Our support for
guards in alt/loop and support for par/opt/neg is new compared to
their approach. With our fragment operator and the collection
operator, we can define the transformation rules completely by
graphical models. Sun, on the other hand, needs to use relatively
complicated textual pre- and post-conditions associated with the
rules.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">We
have shown how concrete syntax-based graph transformation rules can
be used to specify a transformation from sequence diagrams to state
machines. These rules are much more concise than traditional graph
transformation rules which are specified in abstract syntax.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">It
is a great advantage that the user can specify rules in the well
known concrete syntax of sequence diagrams instead of the complicated
and less intuitive abstract syntax version. On the other hand, in our
approach we need to implement a translation from concrete syntax to
abstract syntax-based rules. The extent to which there is a need for
sequence diagram transformations in general decides if the
implementation effort pays off in practice.</SPAN></FONT></FONT></FONT></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Formal
Verification of UML Sequence Diagrams in the Embedded Systems Context
(2011)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">This
paper shows a method for translating UML sequence diagrams to Petri
nets and verifying deadlock-freeness, reachability, safety and
liveness properties by using a model checker. In this proposed
method, the user has not to know about temporal logics to describe
the property to be</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">verified.
Instead, the user may adopt a high-level properties specification
interface, which is automatically translated to a suitable temporal
logic. We show the application of the proposed method in an embedded
control application. The proposed method provides the Petri net in
three</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">different
formats: APNN (Abstract Petri Net Notation), PNML (Petri Net Markup
Language), and SMV (Symbolic Model Verifier). The APNN and SMV
formats can be checked using the MCKit1 and SMV2 , respectively. Such
translations are the first contribution of this paper. Several types
of properties can be checked, e.g., deadlock-freeness, reachability,
safety and liveness properties. These properties can be expressed
with so-called state formula, which is a propositional logic formula
consisting of atomic propositions and logical operators. Another
contribution is that the user has not to know about CTL (Computation
Tree Logic) to describe reachability, safety, or liveness properties.
We propose a high level properties specification interface, which is
automatically translated to CTL. Petri net model [6] is a kind of
state-oriented model, specifically defined to model systems that
comprise interacting concurrent tasks. The Petri net model consists
of a set of places, a set of transitions, and a set of tokens. Tokens
reside in places, and circulate through the Petri net by being
consumed and produced whenever a transition fires. Petri nets are
useful because they can effectively model a variety of system
characteristics, and may be used to check several useful properties.
Petri nets is used in this work because it is a well-consolidated
technique for specifying concurrent systems.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Model
checkers are capable of finding errors that are not likely to be
found by simulation or test. The reason for this is that unlike
simulators, which examine a relatively small set of test cases, model
checkers consider all possible behaviors or executions of the system.
Another feature of the proposed method is that it provides a
mechanism for specifying the properties to be verified in the models
at high level and using natural language. After this, such
specification is automatically translated into a CTL formula,
suitable to be run in several model checkers. The modeled system can
consider systems distributed across multiple processors, where tasks
may communicate via a shared bus. The result of applying the proposed
method can be considered as the junction of the best of both worlds:
(i) UML, which is considered an industry standard, it is a
semi-formal model, and it is comprehensive approach; and (ii) Petri
nets, a mathematical model and suitable for formal verification.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">The
translations rules considered in this work are based on an extended
sequence diagram as proposed by Jeng and Lu [5]. The extension has
the aim to improve the behavior of the systems, including
concurrency, choice, synchronization, and confluence. Fig. 6 shows
the concurrency, which is denoted by a solid line with hollow
endpoints at the arrows, where all messages are considered as being
concurrently executed. &nbsp;choice: Fig. 7 shows the choice, which
is denoted by a dashed line with hollow endpoints at the arrows,
where in each time only one message can be triggered to execute. ←
bullshit, ignore paper! In the end it’s translated to LTL which
doesn’t work for me! horrible English btw.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Supporting
elicitation and specification of software properties through patterns
and composite propositions</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Prospec
is a tool that assists practitioners in the elicitation and
specification of system properties. Practitioners are guided by
questions, definitions, and graphics. Prospec is built upon the
Specification Pattern System. The tool assists the analyst in making
informed decisions about aspects of a specification that may have
multiple interpretations. The end product of the tool is a formal
specification in Future Interval Logic, Linear Temporal Logic, or
Meta Event Definition Language. Two recent approaches that assist in
the specification of properties are the Specification Pattern System
(SPS) [6], [7] and a tool called </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Propel</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">[8].
Prospec, the tool introduced in this paper, extends patterns and asks
the practitioner a series of questions to assist him or her in the
specification process. The end product is a formal specification.
Property patterns are classified based on the following structure of
behavior: the occurrence of events or states (universality, absence,
and existence) and the order of the events or states (precedence,
response, chain of precedence, and chain of response). Universality
properties are true in every point of the execution; absence
properties are never true during the execution; existence properties
are true at some point in the execution; precedence properties
require that &nbsp;given state or event always occurs before a
designated state or event occurs; and response properties require
that the occurrence of a given state or event be followed by a
designated state</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">or
event. In SPS, the abstraction that handles multiple states or events
is called chain. Chain precedence and chain response specify
properties on sequences of states or events and are generalizations
of precedence and response, respectively. SPS provides mappings of
the specification patterns with its associated scopes sto formal
languages. This is accomplished by defining a pattern and scope and
their associated parameters. For instance, universality, absence, and
existence patterns have a single parameter that defines the
proposition to be considered. The precedence and response patterns
have two parameters. With respect to scope, global scope has no
parameters; scopes before and after have one parameter; and scopes
between and after-until have two parameters. The mappings to formal
languages consider only one state or event for each of the patterns
or scopes parameters. SPS defines non-consecutive sequences of states
or events (referred to as chains in SPS) only for response and
precedence patterns. Composite propositions (CP) define relations
among multiple propositions. The composite proposition taxonomy
(refer to Fig. 7) categorizes and defines the structure of multiple
propositions. The CP taxonomy has twelve classes; each class defines
a detailed structure for either concurrent or sequential behavior.
With the identification of a CP class, Prospec facilitates
specification of ordered sequences, non-deterministic sequences, and
concurrency. For instance, an ordered sequence may define the left
boundary of an after L scope, and multiple events that represent the
synchronous start of multiple tasks may define the effect part of a
response pattern. Prospec uses guided questions to distinguish </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">the
types of scope or relations among propositions when more than one
proposition is considered. By answering a series of questions, the
analyst is led to consider different aspects of the property. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">The
View Formula button enables the bottom window, which depicts the
formal specification in FIL [11], LTL [12], or MEDL of the selected
property. ← </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Bullshit
obviously</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">,
some weird property specification formalism Future Interval Logic</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Manna
and Pnueli [12] identified response properties as one of the most
common in concurrent systems, and a study [7] revealed that the
response pattern is the most commonly used pattern. By using
composite propositions in either part of the response pattern (the
cause or effect), it is possible to represent common behavior
associated with concurrent systems, such as synchronized join and
fork, concurrency, non-determinism, and sequences.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Prospec
also supplements the work of SPS by generating Future Interval Logic
(FIL) and Meta-Event Definition Language (MEDL) formulas. FIL
provides basic interval constructs that enhance the readability of
formulas requiring nested intervals. FIL specifications can be
verified by a theorem prover [11]. Prospec generates MEDL formulas
from FIL specification [14]. MEDL is the specification language of
the runtime monitoring system called Java Mac [15].</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">...some
of the formulas for Consecutive CP classes are not expressible in
FIL...</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Required
Behavior of Sequence Diagrams: Semantics and Refinement (2011)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">An
SD is partial in that it describes a number of alternative
obligations that an implementation may choose to fulfill. </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">For
instance, the fragment operator par does not mandate that an
implementation must be distributed, concurrent or multi-threaded. It
rather indicates that the implementation can realize any interleaving
of the behaviors of its operands. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">That
SD Login2 is a correct reuse of SD Login can be informally checked as
follows. SD Login3 may be obtained from SD Login2 by hiding messages
key and chkK(replacing them by tau which stands for all unobservable
messages), using default value true for kOK and changing the names
back. We have shown that verification of SD refinement is important
in software development such as in model driven, pattern-based and
aspect-based software development. Refinement verification requires a
formalization of a refinement relation between SDs which in turn
requires a formal trace semantics that captures precisely required
behaviors of SDs.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
existing behavioral semantics an SD denotes a set of all possible
traces that the specified system may produce and a set of proscribed
traces that the specified system must not produce. They are useful as
a semantic base for verifying SDs against safety properties. However,
they are not useful as a semantic base for defining a refinement
relation between SDs since they do not tell which possible traces are
required in that the specified system must produce. Semantics of SDs
has also been given in terms of translations to these state machines
such as statecharts, Buchi automata, labelled transition systems and
modal transition systems. Since a state machine accepts one set of
positive traces and one set of negative traces in the case of a Buchi
automata and a modal transition system, a semantics based on
translation to state machines does not capture precisely alternative
but incomparable minimal required behaviors specified by an SD. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">This
paper gives a trace semantics that characterizes required behaviors
specified in an SD and formalizes a refinement relationship between
SDs. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Refinement
is defined in terms of a simulation relation between traces. The
notion of one trace simulating another will be made clear later.
Roughly speaking, a trace t1 simulates another trace t2 if all events
in t2 are simulated in t1 in the order in which they occur and there
are no observable events in t1 other than those that simulate events
in t2 . An SD D1 refines another D2 if an implementation of D1 is
also an </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">implementation
of D2 . In other words, D1 preserves the required behaviors of D2 but
may specify more required behaviors. These concepts will be made
clearer in Section V. The main contributions </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">of
this work are as follows.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
novel trace semantics is formulated for a subset of UML SDs. Unlike
the trace semantics proposed in literature [11], [32], [50] that
capture possible behaviors of SDs, our trace semantics captures
precisely required behaviors of SDs and forms a basis for a semantics
based refinement relation. While those trace semantics for possible
behaviors of SDs ignore guard conditions, our trace semantics encodes
guard conditions in SDs as elements of traces.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
refinement relation between SDs is defined based on the semantics.
The refinement relation is transitive, implying that the correctness
of a multi-step refinement can be checked by verifying the
correctness of each individual refinement step. The refinement
relation also possesses substitutivity, implying that an SD can be
refined compositionally. An SD has also been translated to a Petri
net (e.g., [8], [17], [19]) with lifelines translated to processes,
actions to transitions and messages to communication places and to
abstract state machines. An LTS is a finite state machine with each
transition labelled with an action (event) or τ. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
summary, there does not exist a suitable semantic basis refinement of
required behavior of SDs because direct style semantics do not
precisely capture required behaviors of SDs and translations to other
formalisms disregard essential features of SDs such as guard
conditions and critical regions.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">In
this work, we do not consider interaction operators ignore, consider,
assert, neg or break. Since we are concerned with checking if the
behaviors described by one model are found in another model, ignore
and consider fragments play no role and thus can be removed. Despite
prior effort in clarifying assert and neg operators [29], [51], no
commonly accepted interpretation for these operators has been
established. The UML 2.0 standard states that “a break fragment is
a breaking scenario that is performed instead of the remainder of its
enclosing fragment”. It is not clear whether the enclosing fragment
means the innermost enclosing fragment or the innermost loop
fragment. We assume that all references to SDs through interaction
operator ref have been eliminated via syntactic unfolding since SDs
are non-recursive.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">[...tons
of formulas/lemmas/..]</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">User
Guidance for Creating Precise and Accessible Property Specifications
(follow up on the PROPEL paper)</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Ideally,
property specifications should be precise enough to support automated
validation techniques and accessible enough to be readily understood
by system developers. Automated validation tools typically accept
property specifications represented in mathematical formalisms, such
as temporal logic. Such formalisms have not been widely adopted by
developers, in part because their use requires significant expertise
[21]. In practice, developers tend to write requirements and design
specification documents in natural language [16]. While natural
language may offer accessibility, properties written with such
informality are often ambiguous and thus are of limited value when
doing rigorous analysis of the system. Additionally, accurately
representing a property, even one that focuses on a very limited
subset of the system’s behavior, can be surprisingly difficult
because of all the subtle details that should be considered.
Overlooking these details often leads to inaccuracies that are not
revealed until verification or testing, or perhaps even deployment. ←
for future work</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">In
previous work, we proposed a property-specification approach [20]
that aims to guide users through the process of creating property
specifications that are both accessible and mathematically precise.
Propel, for “PROPerty ELucidator,” is a tool that supports this
approach by providing users with a set of property templates that
explicitly indicate the variations that must be considered, thereby
ensuring that important subtle details are not overlooked by users.
Each template can be represented as a set of natural language phrases
or as an extended finite-state automaton (FSA). Users can select the
appropriate variation using either or both representations. Users do
not need to have expertise in a particular specification formalism to
use the natural language representation. The associated FSA
specification, however, can be used as the basis for verifying system
behaviors and other types of analyses. ← for future work! </SPAN></B></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Our
previous work did not attempt to address the issue of how to guide
users in selecting the appropriate template. In this paper, we
describe the Question Tree (QT) representation, which is designed to
provide this additional user guidance. The QT representation is
basically a decision tree, a representation that has often been used
in requirements engineering. The content of the QT is based on
natural language and its hierarchical format guides users through the
elaboration of intended properties by asking questions and, for each
question, providing a set of alternative answers for users to select
from. The QT breaks up the problem of deciding which template is most
appropriate by asking users to consider only one differentiating
attribute at a time. The hierarchical structure of the QT supports
this isolation of concerns, only presenting questions to the users
that are relevant in the context of their previous answers.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Dwyer
et al. observed that nearly all the properties found in the FSV
literature could be classified into a small number of what they
described as “high-level, formalism-independent, specification
abstractions.” Each of the specification abstractions, or property
patterns, is composed of two parts: a behavior (or “intent,” as
it is called in the property patterns work) and a scope. A behavior
describes the restrictions on occurrences of states or events, and a
scope describes the parts of the state- or event-sequences within
which those restrictions apply. The property pattern work identifies
eight behaviors and five scopes that can be combined to create forty
different properties. Dwyer et al. recognized, however, that other
variations of the behaviors and scopes might be required, and their
website [7] includes notes on how to modify the formal specifications
associated with the property patterns to obtain some of these
variations.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">These
property pattern templates are each composed of a scope template,
which contains options related to the selected scope, and a behavior
template, which contains options related to the selected behavior. By
making decisions about these options, users can create 32 possible
scopes and 139 possible behaviors, which can be composed into over
4,400 different possible properties. As with the property patterns
work, however, the space of properties available is not intended to
cover all possibilities, just variations on the most
commonly-occurring properties. Like the property patterns, the
property pattern templates have up to four predefined placeholders,
or parameters, that can be associated with user-defined event names:
at most two for the property’s behavior and at most two for the
property’s scope. One representation is a graphical, extended FSA
template that resolves to an FSA. The FSA template representation
helps developers see the options that need to be considered by
representing those choices with optional versions of FSA states,
transitions, and transition labels. In addition, since the
fully-instantiated form of this representation is an FSA, which is
mathematically well-defined, this representation offers the precision
necessary for many types of analysis, including FSV. &nbsp;second
representation is a disciplined natural language (DNL) template that
is intended to appeal to those users who prefer a natural language
description. The QT is a third representation. As mentioned, this
representation was originally designed to help users select which
property pattern template to use when elaborating their properties.
We soon discovered, however, that this representation was useful not
only for helping users to select the appropriate property pattern
template, but also for helping them to resolve the options associated
with that selected template. In Propel, we break the QT
representation into two separate parts, one for the scope templates
and another for the behavior templates. ← for future work, I can
build up on this paper! Because they don’t translate them to any
formalism, only structured natural language and FSA(M)? </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Note
that the “¬” shorthand notation in this representation is a
set-complement operator for all (i.e., both primary and secondary)
events in the alphabet. We have used Propel to represent the
properties encountered in four case studies we are undertaking in the
medical domain. We have encountered a total of 84 properties thus far
and were able to use Propel to express 83% (70 of 84) of them. We
found that 63% of the behaviors are some form of Precedence, where
one event cannot occur until after another event occurs (e.g., the
checks that must be done before a treatment), and 21% of the
behaviors are some form of Response (e.g., the necessary response to
a patient’s negative reaction to a treatment). It is interesting to
note that the relative prevalence of these two behaviors differs from
what was reported in [8]; there, 5% were some form of Precedence and
44% were some form of Response, the most prevalent of the behaviors
surveyed in that work. It is likely that this difference is due to
the fact that these two collections of properties are drawn from
different domains; Of the 14 properties that cannot be handled in
Propel, we expect that all but two can be handled by fairly
straightforward extensions that we plan to make, such as adding
support for chain property patterns, for a pattern where one event
blocks another event from occurring, and for disjunction. The tool
automatically keeps the DNL, FSA, and QT representations consistent
with each other and is thus designed to help users resolve
misunderstandings by making it possible to compare the
representations. Many property specification approaches aim to
provide either accessibility or precision; few approaches try to
provide both. For example, structured natural language
recommendations (e.g., the NL templates in [5]) provide accessibility
but not precision, and formal specification languages (e.g., the
temporal logics in [3]) provide the opposite.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">While
the NL descriptions in Prospec map to the underlying formal logics
that the tool supports, the NL descriptions are not intended to be
used as property specifications; they are mainly just expansions on
the Dwyer et al. NL descriptions. </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">While
creating properties for the case studies, we soon discovered that we
needed support for collections of properties. Propel provides two
capabilities that support property collections. One is a project
directory hierarchy, where users can define projects and subprojects
and then associate each property with a project in the hierarchy. As
noted previously, there are some other patterns that we plan to
support, since these patterns have arisen several times in our case
studies. Some of these patterns, such as chains, are included in the
property patterns and some are not, such as the concept of one event
blocking the subsequent occurrence of another event and the concept
of alternation. Properties that involve a conjunction or disjunction
of events also merit further scrutiny.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">-----------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Pattern-Based
Modeling and Analysis of Failsafe Fault-Tolerance in UML</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Furthermore,
some existing analysis methods for fault-tolerance assume that a
specific fault-tolerance design mechanism (e.g., exception handling,
redundancy) will be used and specify analysis requirements within
those design constraints, which may overly constrain and preclude
useful fault-tolerance solutions. We introduce an object analysis
pattern, called the detector pattern, that provides a reusable
strategy for eliciting and specifying the requirements of error
detection in UML object models for embedded systems.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Our
pattern-based method comprises fault modeling, fault-tolerance
modeling, and automated analysis of the UML models of fault-tolerant
embedded systems. Intuitively, failsafe fault-tolerance requires that
nothing bad ever happens even in the presence of faults. The general
UML to-Promela formalization approach of Hydra is to map objects to
processes in Spin that exchange messages via channels. Nested and
concurrent states are also formalized as processes. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">An
executable object-oriented semantics and its application to firewall
verification</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">This
paper presents a formal executable semantics of object-oriented
models. We made it possible to conduct both simulation and</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">theorem
proving </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">on
the semantics by implementing it within the expressive intersection
of the functional programming language ML and the theorem prover HOL.
In this paper, we present the definition and implementation of the
semantics. We also present a prototype verification tool ObjectLogic
which supports simulation and theorem proving on the semantics. The
internal representation of the semantics is a heap memory structure
to store objects. The HOL system is a theorem prover of higher-order
logic which is implemented in Moscow ML. In HOL, the semantics is
implemented as a theory which is a module containing types,
constants, operators, and axioms. (examples resemble the data type
definitions in mCRL2). </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Seems
that only classes, attributes and their relationships (inheritance
etc..) are presented in the semantics...how about behavior? So
semantics of the class model is defined.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Figure
4 shows its architecture. OML is the input language which consists of
classes, methods, and assertions (method contracts and class
invariants). It is input to the OML parser which extracts the class
model and abstract syntax trees for methods and assertions. The class
model is input to the semantics generator and the semantics is
constructed in ML and HOL.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">OML
is designed to facilitate the modeling of software applications. It
supports classes, attributes, methods, single inheritance. The
expressiveness is close to UML sequence diagrams, i.e., it contains
conditional branches and finite loops. &nbsp;← still not as
expressive as UML fragments from what I can see...</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">The
advantage of ObjectLogic is that it enables us to perform theorem
proving on the level of objects which is close to our intuition. This
makes the proof easy to read compared with the proof on the level of
primitive theories such as pairs and lists. It also makes it easy for
us to debug the model, i.e., as the abstract level is the same as
that of the model, we can easily identify which part of the model was
wrong when a proof failed. ← close to our intuition for ppt</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">ACL2
is well known as the tool to combine a programming language and a
theorem prover. It is based on an applicative subset of Common Lisp.
It is often used as the semantics for both simulation and theorem
proving. We followed the approach of combining a programming language
and a theorem prover using ML and HOL. The reason for the use of HOL
is to construct the OO semantics conservatively by definitional
extension. To derive our semantics from the definitions, it requires
the expressiveness of the higher-order logic. Specifically, we need
the induction theorem on lists to derive the properties about the
heap memory operations. &nbsp;Interactive verification tools for OO
specification: The KeY tool [1] is a software development system
based on UML. It supports construction of the specification in OCL
and the implementation in Java Card. It also supports verification of
both of them by generating proof obligations in dynamic logic, an
extension of Hoare logic. The HOL-OCL tool [6] is an interactive
proof environment for UML/OCL.</SPAN></FONT></FONT></FONT></P>
<P><BR><BR>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">------------------------------</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Tool
support for learning Buchi automata and linear temporal logic </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">←
</SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">VERY
RELEVANT!</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">We
introduce a graphical interactive tool, named </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">GOAL</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">,
that can assist the user in understand-</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">ing
Buchi automata, linear temporal logic, and their relation. B ̈chi
automata and linear temporal logic are closely related and have long
served as fundamental building blocks of linear-time model checking.
</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Understanding
their relation is instrumental in discovering algorithmic solutions
to model checking problems or simply in using those solutions, e.g.,
specifying a temporal property directly by an automaton rather than a
temporal formula so that the property can be verified by an algorithm
that operates on automata. ← for meeting, for future work as well!</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">One
main function of the GOAL tool is translation of a temporal formula
into an equivalent Buchi automaton that can be further manipulated
visually. The user may edit the resulting automaton, attempting to
optimize it, or simply run the automaton on some inputs to get a
basic understanding of how it operates. GOAL includes a large number
of translation algorithms, most of which support past temporal
operators. With the option of viewing the intermediate steps of a
translation, the user can quickly grasp how a translation algorithm
works. The tool also provides various standard operations and tests
on Buchi automata, in particular the equivalence test which is
essential for checking if a hand-drawn automaton is correct in the
sense that it is equivalent to some intended temporal formula or
reference automaton. The specification of a behavioral property
typically asserts temporal dependency between occurrences of certain
events (represented by propositions) and linear temporal logic has
thus become a particularly popular class of languages for
specification. Temporal dependency between events may also be
expressed with </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">Buchi
automata, which are finite automata operating on infinite words (that
correspond to infinite computations)</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">.</SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><SPAN STYLE="background: transparent">Indeed,
Buchi automata and linear temporal logic are closely related. It has
been shown that Buchi automata and a variant of linear temporal logic
called quantified propositional temporal logic (QPTL) are
expressively equivalent, though translation between the two
formalisms is highly complex As Buchi automata are also suitable as
abstract system models, </SPAN></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">many
researchers have advocated a unified model-checking approach based on
automata. In this automata-theoretic approach, the negation of the
temporal specification formula is translated into an automaton,
representing the bad behaviors. The intersection of the system
automaton and the negated-specification automaton is then constructed
and checked for emptiness. If the intersection automaton accepts no
input, i.e., the system and the negated specification do not have any
common behavior, then the system is correct with respect to the
original specification formula. ← we advocate the same; for future
work, for meeting also!! This is the essence of the approach</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Despite
the possibility of mechanical translation, a temporal formula and its
equivalent B ̈chi automaton are two very different artifacts and
their correspondence is not easy to grasp. Temporal formulae describe
temporal dependency without explicit references to time points and
are in general more abstract, while Buchi automata “localize”
temporal dependency to relations between states and tend to be of
lower level. Understanding their relation is instrumental in
discovering algorithmic solutions to model checking problems or
simply in using those solutions, e.g., specifying a temporal property
directly by an automaton rather than a temporal formula so that the
property can be verified by an algorithm that operates on automata.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">There
are other tools that provide translation of temporal formulae into
Buchi automata, e.g., SPIN [Hol03], LTL2BA [GO01], Wring [SB00],
MoDeLLa [ST03], and LTL2Buchi [GL02]. SPIN in particular is an
automata-theoretic model checker that has been widely used both in
practice and in education. A Buchi automaton accepts those inputs
that can drive it through some accepting state infinitely many times.
</SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Propositional
Temporal Logic to refer to the pure propositional version of LTL, for
which a state is simply a subset of atomic propositions holding in
that state. In the literature there are two versions of PTL. One has
past and future temporal operators, while the other contains only
future operators (Clarke et al.,referred to as LTL here). </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Every
PTL formula can be translated into an equivalent Buchi automaton, but
not vice versa! In the sense that each infinite sequence satisfying
the formula corresponds to an infinite word accepted by the
automaton.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">PTL
is strictly less expressive than Buchi automata. The property “p is
true at every even position” (an infinite word or sequence starts
with position 0), referred to as “Even p” here, is a typical
example for showing the difference. Model Checking Model checking
seeks to automatically verify if a given system satisfies its
specification [CGP99]. The system is typically modeled as a Kripke
structure—a state-transition graph where each state is labeled with
those propositions that hold in the state; fairness may be imposed on
how often the states should be visited. When the specification is
given by a linear temporal logic formula, the model checking problem
is to determine if every computation (sequence of states) generated
by the Kripke structure satisfies, or is a model of, the temporal
formula.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-weight: normal; line-height: 114%">
<SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">The
system may also be modeled as a Buchi automaton; in fact, every
Kripke structure (with or without the usual fairness conditions)
corresponds to some Buchi automaton. As the specification formula can
also be translated into a B ̈chi automaton, </SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><U><B><SPAN STYLE="background: transparent">this
results in a uniform treatment of both the system and its
specification</SPAN></B></U></SPAN></FONT></FONT></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><SPAN STYLE="background: transparent">
← </SPAN></SPAN></FONT></SPAN><SPAN STYLE="font-variant: normal"><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="font-style: normal"><B><SPAN STYLE="background: transparent">for
future work, for meeting!</SPAN></B></SPAN></FONT></FONT></SPAN></FONT></SPAN></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">Let
L(A) be the lnaugage of the automaton A - model of the system. Let
L(B) be the language of the automaton representing the specification
(property). Then the model checking problem translates into language
containement: whether L(A) is contained in L(B). if !L(B) is the
complement of L(B), and !B is the complement of B, then the problem
is equivalent to checking if L(A) intersection !L(B) is empty, i.e.
L(A intersection !B) is empty. But complementing Buchi automaton is
expensive. It’s better to first negate the specification formula
and obtain the automaton for it.</SPAN></B></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">Translating
QPTL (and PTL) Formulae into Buchi Automata: Nine algorithms have
been implemented for temporal formula to B ̈chi automaton
translation. Once an automaton has been defined and tested, the user
can export it in the Promela (the system modeling language of SPIN)
syntax on the screen or as a file. This makes it possible to use GOAL
as a graphical specification definition frontend to an
automata-theoretic model checker like SPIN. </SPAN></FONT></FONT></FONT>
</P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">For
a student who has taken a course on the classical theory of
computation, the key to understanding Buchi automata is to first
comprehend the concept of an infinite word and how a Buchi automaton
operates on an infinite word. One obvious thing to do is examining a
few examples of how an infinite word drives a Buchi automaton through
the different states of the automaton, which can be conveniently
carried out with GOAL.</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; font-weight: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><SPAN STYLE="background: transparent">A
Buchi automaton for &lt;&gt;[]p (p always holds from some point on)
would be a simple enough starting example for illustrating how a B
̈chi automaton operates on infinite words. In GOAL, an infinite word
pp∼pppp · · · (with p repeating indefinitely) is represented as
(p)(p)(∼p){(p)}. Understanding how a temporal formula can be
translated into a Buchi automaton is an essential step in learning
automata-theoretic model checking Buchi automata are closed under
boolean operations and these operations can be done algorithmically.
To learn any of the boolean operations, the user can perform the
operation by hand and then verify correctness by checking the
equivalence between the resulting automaton (hand-drawn using the
automaton editing function of GOAL) and the machine-computed one
(also by GOAL).</SPAN></FONT></FONT></FONT></P>
<P ALIGN=JUSTIFY STYLE="margin-bottom: 0in; font-variant: normal; font-style: normal; line-height: 114%; text-decoration: none">
<FONT COLOR="#000000"><FONT FACE="Arial"><FONT SIZE=3 STYLE="font-size: 11pt"><B><SPAN STYLE="background: transparent">GOAL
is particularly useful for learning the complementation operation,
which is very complex and difficult to understand. It should be a
helpful and interesting exercise for the student to go through the
typical verification steps: (1) prepare a system Buchi automaton for
some small verification problem, e.g., the two-process mutual
exclusion problem, (2) write a temporal formula describing the
system’s safety property (e.g., mutual exclusion) or liveness
property (e.g., starvation freedom), (3) negate the formula and
translate it into a Buchi automaton, representing all “bad”
behaviors, (4) compute the intersection of the given system automaton
and the translated negative specification automaton, and (5) check
the emptiness of the intersection. For example, besides Buchi and
generalized B ̈chi automata, we have extended GOAL to support the
editing of and a limited set of operations on Muller, Rabin, Streett,
and Parity automata. Although these variants of ω-automata do not
necessarily have a direct impact on the model-checking process, they
are powerful intermediaries for the development of automata-based
algorithms and will make GOAL complete as a learning and teaching
tool.</SPAN></B></FONT></FONT></FONT></P>
<P STYLE="font-weight: normal"><BR><BR><BR>
</P>
</BODY>
</HTML>